/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["pages/index"],{

/***/ "./node_modules/contentful/dist/contentful.browser.js":
/*!************************************************************!*\
  !*** ./node_modules/contentful/dist/contentful.browser.js ***!
  \************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("/*\n * ATTENTION: The \"eval\" devtool has been used (maybe by default in mode: \"development\").\n * This devtool is neither made for production nor for readable output files.\n * It uses \"eval()\" calls to create a separate source file in the browser devtools.\n * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)\n * or disable the default devtool with \"devtool: false\".\n * If you are looking for production-ready output files, see mode: \"production\" (https://webpack.js.org/configuration/mode/).\n */\n(function webpackUniversalModuleDefinition(root, factory) {\n\tif(true)\n\t\tmodule.exports = factory();\n\telse {}\n})(globalThis, () => {\nreturn /******/ (() => { // webpackBootstrap\n/******/ \tvar __webpack_modules__ = ({\n\n/***/ \"../node_modules/axios/index.js\":\n/*!**************************************!*\\\n  !*** ../node_modules/axios/index.js ***!\n  \\**************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"module.exports = __webpack_require__(/*! ./lib/axios */ \\\"../node_modules/axios/lib/axios.js\\\");\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/adapters/xhr.js\":\n/*!*************************************************!*\\\n  !*** ../node_modules/axios/lib/adapters/xhr.js ***!\n  \\*************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar settle = __webpack_require__(/*! ./../core/settle */ \\\"../node_modules/axios/lib/core/settle.js\\\");\\nvar cookies = __webpack_require__(/*! ./../helpers/cookies */ \\\"../node_modules/axios/lib/helpers/cookies.js\\\");\\nvar buildURL = __webpack_require__(/*! ./../helpers/buildURL */ \\\"../node_modules/axios/lib/helpers/buildURL.js\\\");\\nvar buildFullPath = __webpack_require__(/*! ../core/buildFullPath */ \\\"../node_modules/axios/lib/core/buildFullPath.js\\\");\\nvar parseHeaders = __webpack_require__(/*! ./../helpers/parseHeaders */ \\\"../node_modules/axios/lib/helpers/parseHeaders.js\\\");\\nvar isURLSameOrigin = __webpack_require__(/*! ./../helpers/isURLSameOrigin */ \\\"../node_modules/axios/lib/helpers/isURLSameOrigin.js\\\");\\nvar createError = __webpack_require__(/*! ../core/createError */ \\\"../node_modules/axios/lib/core/createError.js\\\");\\nvar transitionalDefaults = __webpack_require__(/*! ../defaults/transitional */ \\\"../node_modules/axios/lib/defaults/transitional.js\\\");\\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \\\"../node_modules/axios/lib/cancel/Cancel.js\\\");\\n\\nmodule.exports = function xhrAdapter(config) {\\n  return new Promise(function dispatchXhrRequest(resolve, reject) {\\n    var requestData = config.data;\\n    var requestHeaders = config.headers;\\n    var responseType = config.responseType;\\n    var onCanceled;\\n    function done() {\\n      if (config.cancelToken) {\\n        config.cancelToken.unsubscribe(onCanceled);\\n      }\\n\\n      if (config.signal) {\\n        config.signal.removeEventListener('abort', onCanceled);\\n      }\\n    }\\n\\n    if (utils.isFormData(requestData)) {\\n      delete requestHeaders['Content-Type']; // Let the browser set it\\n    }\\n\\n    var request = new XMLHttpRequest();\\n\\n    // HTTP basic authentication\\n    if (config.auth) {\\n      var username = config.auth.username || '';\\n      var password = config.auth.password ? unescape(encodeURIComponent(config.auth.password)) : '';\\n      requestHeaders.Authorization = 'Basic ' + btoa(username + ':' + password);\\n    }\\n\\n    var fullPath = buildFullPath(config.baseURL, config.url);\\n    request.open(config.method.toUpperCase(), buildURL(fullPath, config.params, config.paramsSerializer), true);\\n\\n    // Set the request timeout in MS\\n    request.timeout = config.timeout;\\n\\n    function onloadend() {\\n      if (!request) {\\n        return;\\n      }\\n      // Prepare the response\\n      var responseHeaders = 'getAllResponseHeaders' in request ? parseHeaders(request.getAllResponseHeaders()) : null;\\n      var responseData = !responseType || responseType === 'text' ||  responseType === 'json' ?\\n        request.responseText : request.response;\\n      var response = {\\n        data: responseData,\\n        status: request.status,\\n        statusText: request.statusText,\\n        headers: responseHeaders,\\n        config: config,\\n        request: request\\n      };\\n\\n      settle(function _resolve(value) {\\n        resolve(value);\\n        done();\\n      }, function _reject(err) {\\n        reject(err);\\n        done();\\n      }, response);\\n\\n      // Clean up request\\n      request = null;\\n    }\\n\\n    if ('onloadend' in request) {\\n      // Use onloadend if available\\n      request.onloadend = onloadend;\\n    } else {\\n      // Listen for ready state to emulate onloadend\\n      request.onreadystatechange = function handleLoad() {\\n        if (!request || request.readyState !== 4) {\\n          return;\\n        }\\n\\n        // The request errored out and we didn't get a response, this will be\\n        // handled by onerror instead\\n        // With one exception: request that using file: protocol, most browsers\\n        // will return status as 0 even though it's a successful request\\n        if (request.status === 0 && !(request.responseURL && request.responseURL.indexOf('file:') === 0)) {\\n          return;\\n        }\\n        // readystate handler is calling before onerror or ontimeout handlers,\\n        // so we should call onloadend on the next 'tick'\\n        setTimeout(onloadend);\\n      };\\n    }\\n\\n    // Handle browser request cancellation (as opposed to a manual cancellation)\\n    request.onabort = function handleAbort() {\\n      if (!request) {\\n        return;\\n      }\\n\\n      reject(createError('Request aborted', config, 'ECONNABORTED', request));\\n\\n      // Clean up request\\n      request = null;\\n    };\\n\\n    // Handle low level network errors\\n    request.onerror = function handleError() {\\n      // Real errors are hidden from us by the browser\\n      // onerror should only fire if it's a network error\\n      reject(createError('Network Error', config, null, request));\\n\\n      // Clean up request\\n      request = null;\\n    };\\n\\n    // Handle timeout\\n    request.ontimeout = function handleTimeout() {\\n      var timeoutErrorMessage = config.timeout ? 'timeout of ' + config.timeout + 'ms exceeded' : 'timeout exceeded';\\n      var transitional = config.transitional || transitionalDefaults;\\n      if (config.timeoutErrorMessage) {\\n        timeoutErrorMessage = config.timeoutErrorMessage;\\n      }\\n      reject(createError(\\n        timeoutErrorMessage,\\n        config,\\n        transitional.clarifyTimeoutError ? 'ETIMEDOUT' : 'ECONNABORTED',\\n        request));\\n\\n      // Clean up request\\n      request = null;\\n    };\\n\\n    // Add xsrf header\\n    // This is only done if running in a standard browser environment.\\n    // Specifically not if we're in a web worker, or react-native.\\n    if (utils.isStandardBrowserEnv()) {\\n      // Add xsrf header\\n      var xsrfValue = (config.withCredentials || isURLSameOrigin(fullPath)) && config.xsrfCookieName ?\\n        cookies.read(config.xsrfCookieName) :\\n        undefined;\\n\\n      if (xsrfValue) {\\n        requestHeaders[config.xsrfHeaderName] = xsrfValue;\\n      }\\n    }\\n\\n    // Add headers to the request\\n    if ('setRequestHeader' in request) {\\n      utils.forEach(requestHeaders, function setRequestHeader(val, key) {\\n        if (typeof requestData === 'undefined' && key.toLowerCase() === 'content-type') {\\n          // Remove Content-Type if data is undefined\\n          delete requestHeaders[key];\\n        } else {\\n          // Otherwise add header to the request\\n          request.setRequestHeader(key, val);\\n        }\\n      });\\n    }\\n\\n    // Add withCredentials to request if needed\\n    if (!utils.isUndefined(config.withCredentials)) {\\n      request.withCredentials = !!config.withCredentials;\\n    }\\n\\n    // Add responseType to request if needed\\n    if (responseType && responseType !== 'json') {\\n      request.responseType = config.responseType;\\n    }\\n\\n    // Handle progress if needed\\n    if (typeof config.onDownloadProgress === 'function') {\\n      request.addEventListener('progress', config.onDownloadProgress);\\n    }\\n\\n    // Not all browsers support upload events\\n    if (typeof config.onUploadProgress === 'function' && request.upload) {\\n      request.upload.addEventListener('progress', config.onUploadProgress);\\n    }\\n\\n    if (config.cancelToken || config.signal) {\\n      // Handle cancellation\\n      // eslint-disable-next-line func-names\\n      onCanceled = function(cancel) {\\n        if (!request) {\\n          return;\\n        }\\n        reject(!cancel || (cancel && cancel.type) ? new Cancel('canceled') : cancel);\\n        request.abort();\\n        request = null;\\n      };\\n\\n      config.cancelToken && config.cancelToken.subscribe(onCanceled);\\n      if (config.signal) {\\n        config.signal.aborted ? onCanceled() : config.signal.addEventListener('abort', onCanceled);\\n      }\\n    }\\n\\n    if (!requestData) {\\n      requestData = null;\\n    }\\n\\n    // Send the request\\n    request.send(requestData);\\n  });\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/adapters/xhr.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/axios.js\":\n/*!******************************************!*\\\n  !*** ../node_modules/axios/lib/axios.js ***!\n  \\******************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar bind = __webpack_require__(/*! ./helpers/bind */ \\\"../node_modules/axios/lib/helpers/bind.js\\\");\\nvar Axios = __webpack_require__(/*! ./core/Axios */ \\\"../node_modules/axios/lib/core/Axios.js\\\");\\nvar mergeConfig = __webpack_require__(/*! ./core/mergeConfig */ \\\"../node_modules/axios/lib/core/mergeConfig.js\\\");\\nvar defaults = __webpack_require__(/*! ./defaults */ \\\"../node_modules/axios/lib/defaults/index.js\\\");\\n\\n/**\\n * Create an instance of Axios\\n *\\n * @param {Object} defaultConfig The default config for the instance\\n * @return {Axios} A new instance of Axios\\n */\\nfunction createInstance(defaultConfig) {\\n  var context = new Axios(defaultConfig);\\n  var instance = bind(Axios.prototype.request, context);\\n\\n  // Copy axios.prototype to instance\\n  utils.extend(instance, Axios.prototype, context);\\n\\n  // Copy context to instance\\n  utils.extend(instance, context);\\n\\n  // Factory for creating new instances\\n  instance.create = function create(instanceConfig) {\\n    return createInstance(mergeConfig(defaultConfig, instanceConfig));\\n  };\\n\\n  return instance;\\n}\\n\\n// Create the default instance to be exported\\nvar axios = createInstance(defaults);\\n\\n// Expose Axios class to allow class inheritance\\naxios.Axios = Axios;\\n\\n// Expose Cancel & CancelToken\\naxios.Cancel = __webpack_require__(/*! ./cancel/Cancel */ \\\"../node_modules/axios/lib/cancel/Cancel.js\\\");\\naxios.CancelToken = __webpack_require__(/*! ./cancel/CancelToken */ \\\"../node_modules/axios/lib/cancel/CancelToken.js\\\");\\naxios.isCancel = __webpack_require__(/*! ./cancel/isCancel */ \\\"../node_modules/axios/lib/cancel/isCancel.js\\\");\\naxios.VERSION = (__webpack_require__(/*! ./env/data */ \\\"../node_modules/axios/lib/env/data.js\\\").version);\\n\\n// Expose all/spread\\naxios.all = function all(promises) {\\n  return Promise.all(promises);\\n};\\naxios.spread = __webpack_require__(/*! ./helpers/spread */ \\\"../node_modules/axios/lib/helpers/spread.js\\\");\\n\\n// Expose isAxiosError\\naxios.isAxiosError = __webpack_require__(/*! ./helpers/isAxiosError */ \\\"../node_modules/axios/lib/helpers/isAxiosError.js\\\");\\n\\nmodule.exports = axios;\\n\\n// Allow use of default import syntax in TypeScript\\nmodule.exports[\\\"default\\\"] = axios;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/axios.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/cancel/Cancel.js\":\n/*!**************************************************!*\\\n  !*** ../node_modules/axios/lib/cancel/Cancel.js ***!\n  \\**************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * A `Cancel` is an object that is thrown when an operation is canceled.\\n *\\n * @class\\n * @param {string=} message The message.\\n */\\nfunction Cancel(message) {\\n  this.message = message;\\n}\\n\\nCancel.prototype.toString = function toString() {\\n  return 'Cancel' + (this.message ? ': ' + this.message : '');\\n};\\n\\nCancel.prototype.__CANCEL__ = true;\\n\\nmodule.exports = Cancel;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/cancel/Cancel.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/cancel/CancelToken.js\":\n/*!*******************************************************!*\\\n  !*** ../node_modules/axios/lib/cancel/CancelToken.js ***!\n  \\*******************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar Cancel = __webpack_require__(/*! ./Cancel */ \\\"../node_modules/axios/lib/cancel/Cancel.js\\\");\\n\\n/**\\n * A `CancelToken` is an object that can be used to request cancellation of an operation.\\n *\\n * @class\\n * @param {Function} executor The executor function.\\n */\\nfunction CancelToken(executor) {\\n  if (typeof executor !== 'function') {\\n    throw new TypeError('executor must be a function.');\\n  }\\n\\n  var resolvePromise;\\n\\n  this.promise = new Promise(function promiseExecutor(resolve) {\\n    resolvePromise = resolve;\\n  });\\n\\n  var token = this;\\n\\n  // eslint-disable-next-line func-names\\n  this.promise.then(function(cancel) {\\n    if (!token._listeners) return;\\n\\n    var i;\\n    var l = token._listeners.length;\\n\\n    for (i = 0; i < l; i++) {\\n      token._listeners[i](cancel);\\n    }\\n    token._listeners = null;\\n  });\\n\\n  // eslint-disable-next-line func-names\\n  this.promise.then = function(onfulfilled) {\\n    var _resolve;\\n    // eslint-disable-next-line func-names\\n    var promise = new Promise(function(resolve) {\\n      token.subscribe(resolve);\\n      _resolve = resolve;\\n    }).then(onfulfilled);\\n\\n    promise.cancel = function reject() {\\n      token.unsubscribe(_resolve);\\n    };\\n\\n    return promise;\\n  };\\n\\n  executor(function cancel(message) {\\n    if (token.reason) {\\n      // Cancellation has already been requested\\n      return;\\n    }\\n\\n    token.reason = new Cancel(message);\\n    resolvePromise(token.reason);\\n  });\\n}\\n\\n/**\\n * Throws a `Cancel` if cancellation has been requested.\\n */\\nCancelToken.prototype.throwIfRequested = function throwIfRequested() {\\n  if (this.reason) {\\n    throw this.reason;\\n  }\\n};\\n\\n/**\\n * Subscribe to the cancel signal\\n */\\n\\nCancelToken.prototype.subscribe = function subscribe(listener) {\\n  if (this.reason) {\\n    listener(this.reason);\\n    return;\\n  }\\n\\n  if (this._listeners) {\\n    this._listeners.push(listener);\\n  } else {\\n    this._listeners = [listener];\\n  }\\n};\\n\\n/**\\n * Unsubscribe from the cancel signal\\n */\\n\\nCancelToken.prototype.unsubscribe = function unsubscribe(listener) {\\n  if (!this._listeners) {\\n    return;\\n  }\\n  var index = this._listeners.indexOf(listener);\\n  if (index !== -1) {\\n    this._listeners.splice(index, 1);\\n  }\\n};\\n\\n/**\\n * Returns an object that contains a new `CancelToken` and a function that, when called,\\n * cancels the `CancelToken`.\\n */\\nCancelToken.source = function source() {\\n  var cancel;\\n  var token = new CancelToken(function executor(c) {\\n    cancel = c;\\n  });\\n  return {\\n    token: token,\\n    cancel: cancel\\n  };\\n};\\n\\nmodule.exports = CancelToken;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/cancel/CancelToken.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/cancel/isCancel.js\":\n/*!****************************************************!*\\\n  !*** ../node_modules/axios/lib/cancel/isCancel.js ***!\n  \\****************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\nmodule.exports = function isCancel(value) {\\n  return !!(value && value.__CANCEL__);\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/cancel/isCancel.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/Axios.js\":\n/*!***********************************************!*\\\n  !*** ../node_modules/axios/lib/core/Axios.js ***!\n  \\***********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar buildURL = __webpack_require__(/*! ../helpers/buildURL */ \\\"../node_modules/axios/lib/helpers/buildURL.js\\\");\\nvar InterceptorManager = __webpack_require__(/*! ./InterceptorManager */ \\\"../node_modules/axios/lib/core/InterceptorManager.js\\\");\\nvar dispatchRequest = __webpack_require__(/*! ./dispatchRequest */ \\\"../node_modules/axios/lib/core/dispatchRequest.js\\\");\\nvar mergeConfig = __webpack_require__(/*! ./mergeConfig */ \\\"../node_modules/axios/lib/core/mergeConfig.js\\\");\\nvar validator = __webpack_require__(/*! ../helpers/validator */ \\\"../node_modules/axios/lib/helpers/validator.js\\\");\\n\\nvar validators = validator.validators;\\n/**\\n * Create a new instance of Axios\\n *\\n * @param {Object} instanceConfig The default config for the instance\\n */\\nfunction Axios(instanceConfig) {\\n  this.defaults = instanceConfig;\\n  this.interceptors = {\\n    request: new InterceptorManager(),\\n    response: new InterceptorManager()\\n  };\\n}\\n\\n/**\\n * Dispatch a request\\n *\\n * @param {Object} config The config specific for this request (merged with this.defaults)\\n */\\nAxios.prototype.request = function request(configOrUrl, config) {\\n  /*eslint no-param-reassign:0*/\\n  // Allow for axios('example/url'[, config]) a la fetch API\\n  if (typeof configOrUrl === 'string') {\\n    config = config || {};\\n    config.url = configOrUrl;\\n  } else {\\n    config = configOrUrl || {};\\n  }\\n\\n  config = mergeConfig(this.defaults, config);\\n\\n  // Set config.method\\n  if (config.method) {\\n    config.method = config.method.toLowerCase();\\n  } else if (this.defaults.method) {\\n    config.method = this.defaults.method.toLowerCase();\\n  } else {\\n    config.method = 'get';\\n  }\\n\\n  var transitional = config.transitional;\\n\\n  if (transitional !== undefined) {\\n    validator.assertOptions(transitional, {\\n      silentJSONParsing: validators.transitional(validators.boolean),\\n      forcedJSONParsing: validators.transitional(validators.boolean),\\n      clarifyTimeoutError: validators.transitional(validators.boolean)\\n    }, false);\\n  }\\n\\n  // filter out skipped interceptors\\n  var requestInterceptorChain = [];\\n  var synchronousRequestInterceptors = true;\\n  this.interceptors.request.forEach(function unshiftRequestInterceptors(interceptor) {\\n    if (typeof interceptor.runWhen === 'function' && interceptor.runWhen(config) === false) {\\n      return;\\n    }\\n\\n    synchronousRequestInterceptors = synchronousRequestInterceptors && interceptor.synchronous;\\n\\n    requestInterceptorChain.unshift(interceptor.fulfilled, interceptor.rejected);\\n  });\\n\\n  var responseInterceptorChain = [];\\n  this.interceptors.response.forEach(function pushResponseInterceptors(interceptor) {\\n    responseInterceptorChain.push(interceptor.fulfilled, interceptor.rejected);\\n  });\\n\\n  var promise;\\n\\n  if (!synchronousRequestInterceptors) {\\n    var chain = [dispatchRequest, undefined];\\n\\n    Array.prototype.unshift.apply(chain, requestInterceptorChain);\\n    chain = chain.concat(responseInterceptorChain);\\n\\n    promise = Promise.resolve(config);\\n    while (chain.length) {\\n      promise = promise.then(chain.shift(), chain.shift());\\n    }\\n\\n    return promise;\\n  }\\n\\n\\n  var newConfig = config;\\n  while (requestInterceptorChain.length) {\\n    var onFulfilled = requestInterceptorChain.shift();\\n    var onRejected = requestInterceptorChain.shift();\\n    try {\\n      newConfig = onFulfilled(newConfig);\\n    } catch (error) {\\n      onRejected(error);\\n      break;\\n    }\\n  }\\n\\n  try {\\n    promise = dispatchRequest(newConfig);\\n  } catch (error) {\\n    return Promise.reject(error);\\n  }\\n\\n  while (responseInterceptorChain.length) {\\n    promise = promise.then(responseInterceptorChain.shift(), responseInterceptorChain.shift());\\n  }\\n\\n  return promise;\\n};\\n\\nAxios.prototype.getUri = function getUri(config) {\\n  config = mergeConfig(this.defaults, config);\\n  return buildURL(config.url, config.params, config.paramsSerializer).replace(/^\\\\?/, '');\\n};\\n\\n// Provide aliases for supported request methods\\nutils.forEach(['delete', 'get', 'head', 'options'], function forEachMethodNoData(method) {\\n  /*eslint func-names:0*/\\n  Axios.prototype[method] = function(url, config) {\\n    return this.request(mergeConfig(config || {}, {\\n      method: method,\\n      url: url,\\n      data: (config || {}).data\\n    }));\\n  };\\n});\\n\\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\\n  /*eslint func-names:0*/\\n  Axios.prototype[method] = function(url, data, config) {\\n    return this.request(mergeConfig(config || {}, {\\n      method: method,\\n      url: url,\\n      data: data\\n    }));\\n  };\\n});\\n\\nmodule.exports = Axios;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/Axios.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/InterceptorManager.js\":\n/*!************************************************************!*\\\n  !*** ../node_modules/axios/lib/core/InterceptorManager.js ***!\n  \\************************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\nfunction InterceptorManager() {\\n  this.handlers = [];\\n}\\n\\n/**\\n * Add a new interceptor to the stack\\n *\\n * @param {Function} fulfilled The function to handle `then` for a `Promise`\\n * @param {Function} rejected The function to handle `reject` for a `Promise`\\n *\\n * @return {Number} An ID used to remove interceptor later\\n */\\nInterceptorManager.prototype.use = function use(fulfilled, rejected, options) {\\n  this.handlers.push({\\n    fulfilled: fulfilled,\\n    rejected: rejected,\\n    synchronous: options ? options.synchronous : false,\\n    runWhen: options ? options.runWhen : null\\n  });\\n  return this.handlers.length - 1;\\n};\\n\\n/**\\n * Remove an interceptor from the stack\\n *\\n * @param {Number} id The ID that was returned by `use`\\n */\\nInterceptorManager.prototype.eject = function eject(id) {\\n  if (this.handlers[id]) {\\n    this.handlers[id] = null;\\n  }\\n};\\n\\n/**\\n * Iterate over all the registered interceptors\\n *\\n * This method is particularly useful for skipping over any\\n * interceptors that may have become `null` calling `eject`.\\n *\\n * @param {Function} fn The function to call for each interceptor\\n */\\nInterceptorManager.prototype.forEach = function forEach(fn) {\\n  utils.forEach(this.handlers, function forEachHandler(h) {\\n    if (h !== null) {\\n      fn(h);\\n    }\\n  });\\n};\\n\\nmodule.exports = InterceptorManager;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/InterceptorManager.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/buildFullPath.js\":\n/*!*******************************************************!*\\\n  !*** ../node_modules/axios/lib/core/buildFullPath.js ***!\n  \\*******************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar isAbsoluteURL = __webpack_require__(/*! ../helpers/isAbsoluteURL */ \\\"../node_modules/axios/lib/helpers/isAbsoluteURL.js\\\");\\nvar combineURLs = __webpack_require__(/*! ../helpers/combineURLs */ \\\"../node_modules/axios/lib/helpers/combineURLs.js\\\");\\n\\n/**\\n * Creates a new URL by combining the baseURL with the requestedURL,\\n * only when the requestedURL is not already an absolute URL.\\n * If the requestURL is absolute, this function returns the requestedURL untouched.\\n *\\n * @param {string} baseURL The base URL\\n * @param {string} requestedURL Absolute or relative URL to combine\\n * @returns {string} The combined full path\\n */\\nmodule.exports = function buildFullPath(baseURL, requestedURL) {\\n  if (baseURL && !isAbsoluteURL(requestedURL)) {\\n    return combineURLs(baseURL, requestedURL);\\n  }\\n  return requestedURL;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/buildFullPath.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/createError.js\":\n/*!*****************************************************!*\\\n  !*** ../node_modules/axios/lib/core/createError.js ***!\n  \\*****************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar enhanceError = __webpack_require__(/*! ./enhanceError */ \\\"../node_modules/axios/lib/core/enhanceError.js\\\");\\n\\n/**\\n * Create an Error with the specified message, config, error code, request and response.\\n *\\n * @param {string} message The error message.\\n * @param {Object} config The config.\\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\\n * @param {Object} [request] The request.\\n * @param {Object} [response] The response.\\n * @returns {Error} The created error.\\n */\\nmodule.exports = function createError(message, config, code, request, response) {\\n  var error = new Error(message);\\n  return enhanceError(error, config, code, request, response);\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/createError.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/dispatchRequest.js\":\n/*!*********************************************************!*\\\n  !*** ../node_modules/axios/lib/core/dispatchRequest.js ***!\n  \\*********************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar transformData = __webpack_require__(/*! ./transformData */ \\\"../node_modules/axios/lib/core/transformData.js\\\");\\nvar isCancel = __webpack_require__(/*! ../cancel/isCancel */ \\\"../node_modules/axios/lib/cancel/isCancel.js\\\");\\nvar defaults = __webpack_require__(/*! ../defaults */ \\\"../node_modules/axios/lib/defaults/index.js\\\");\\nvar Cancel = __webpack_require__(/*! ../cancel/Cancel */ \\\"../node_modules/axios/lib/cancel/Cancel.js\\\");\\n\\n/**\\n * Throws a `Cancel` if cancellation has been requested.\\n */\\nfunction throwIfCancellationRequested(config) {\\n  if (config.cancelToken) {\\n    config.cancelToken.throwIfRequested();\\n  }\\n\\n  if (config.signal && config.signal.aborted) {\\n    throw new Cancel('canceled');\\n  }\\n}\\n\\n/**\\n * Dispatch a request to the server using the configured adapter.\\n *\\n * @param {object} config The config that is to be used for the request\\n * @returns {Promise} The Promise to be fulfilled\\n */\\nmodule.exports = function dispatchRequest(config) {\\n  throwIfCancellationRequested(config);\\n\\n  // Ensure headers exist\\n  config.headers = config.headers || {};\\n\\n  // Transform request data\\n  config.data = transformData.call(\\n    config,\\n    config.data,\\n    config.headers,\\n    config.transformRequest\\n  );\\n\\n  // Flatten headers\\n  config.headers = utils.merge(\\n    config.headers.common || {},\\n    config.headers[config.method] || {},\\n    config.headers\\n  );\\n\\n  utils.forEach(\\n    ['delete', 'get', 'head', 'post', 'put', 'patch', 'common'],\\n    function cleanHeaderConfig(method) {\\n      delete config.headers[method];\\n    }\\n  );\\n\\n  var adapter = config.adapter || defaults.adapter;\\n\\n  return adapter(config).then(function onAdapterResolution(response) {\\n    throwIfCancellationRequested(config);\\n\\n    // Transform response data\\n    response.data = transformData.call(\\n      config,\\n      response.data,\\n      response.headers,\\n      config.transformResponse\\n    );\\n\\n    return response;\\n  }, function onAdapterRejection(reason) {\\n    if (!isCancel(reason)) {\\n      throwIfCancellationRequested(config);\\n\\n      // Transform response data\\n      if (reason && reason.response) {\\n        reason.response.data = transformData.call(\\n          config,\\n          reason.response.data,\\n          reason.response.headers,\\n          config.transformResponse\\n        );\\n      }\\n    }\\n\\n    return Promise.reject(reason);\\n  });\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/dispatchRequest.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/enhanceError.js\":\n/*!******************************************************!*\\\n  !*** ../node_modules/axios/lib/core/enhanceError.js ***!\n  \\******************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Update an Error with the specified config, error code, and response.\\n *\\n * @param {Error} error The error to update.\\n * @param {Object} config The config.\\n * @param {string} [code] The error code (for example, 'ECONNABORTED').\\n * @param {Object} [request] The request.\\n * @param {Object} [response] The response.\\n * @returns {Error} The error.\\n */\\nmodule.exports = function enhanceError(error, config, code, request, response) {\\n  error.config = config;\\n  if (code) {\\n    error.code = code;\\n  }\\n\\n  error.request = request;\\n  error.response = response;\\n  error.isAxiosError = true;\\n\\n  error.toJSON = function toJSON() {\\n    return {\\n      // Standard\\n      message: this.message,\\n      name: this.name,\\n      // Microsoft\\n      description: this.description,\\n      number: this.number,\\n      // Mozilla\\n      fileName: this.fileName,\\n      lineNumber: this.lineNumber,\\n      columnNumber: this.columnNumber,\\n      stack: this.stack,\\n      // Axios\\n      config: this.config,\\n      code: this.code,\\n      status: this.response && this.response.status ? this.response.status : null\\n    };\\n  };\\n  return error;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/enhanceError.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/mergeConfig.js\":\n/*!*****************************************************!*\\\n  !*** ../node_modules/axios/lib/core/mergeConfig.js ***!\n  \\*****************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\n/**\\n * Config-specific merge-function which creates a new config-object\\n * by merging two configuration objects together.\\n *\\n * @param {Object} config1\\n * @param {Object} config2\\n * @returns {Object} New object resulting from merging config2 to config1\\n */\\nmodule.exports = function mergeConfig(config1, config2) {\\n  // eslint-disable-next-line no-param-reassign\\n  config2 = config2 || {};\\n  var config = {};\\n\\n  function getMergedValue(target, source) {\\n    if (utils.isPlainObject(target) && utils.isPlainObject(source)) {\\n      return utils.merge(target, source);\\n    } else if (utils.isPlainObject(source)) {\\n      return utils.merge({}, source);\\n    } else if (utils.isArray(source)) {\\n      return source.slice();\\n    }\\n    return source;\\n  }\\n\\n  // eslint-disable-next-line consistent-return\\n  function mergeDeepProperties(prop) {\\n    if (!utils.isUndefined(config2[prop])) {\\n      return getMergedValue(config1[prop], config2[prop]);\\n    } else if (!utils.isUndefined(config1[prop])) {\\n      return getMergedValue(undefined, config1[prop]);\\n    }\\n  }\\n\\n  // eslint-disable-next-line consistent-return\\n  function valueFromConfig2(prop) {\\n    if (!utils.isUndefined(config2[prop])) {\\n      return getMergedValue(undefined, config2[prop]);\\n    }\\n  }\\n\\n  // eslint-disable-next-line consistent-return\\n  function defaultToConfig2(prop) {\\n    if (!utils.isUndefined(config2[prop])) {\\n      return getMergedValue(undefined, config2[prop]);\\n    } else if (!utils.isUndefined(config1[prop])) {\\n      return getMergedValue(undefined, config1[prop]);\\n    }\\n  }\\n\\n  // eslint-disable-next-line consistent-return\\n  function mergeDirectKeys(prop) {\\n    if (prop in config2) {\\n      return getMergedValue(config1[prop], config2[prop]);\\n    } else if (prop in config1) {\\n      return getMergedValue(undefined, config1[prop]);\\n    }\\n  }\\n\\n  var mergeMap = {\\n    'url': valueFromConfig2,\\n    'method': valueFromConfig2,\\n    'data': valueFromConfig2,\\n    'baseURL': defaultToConfig2,\\n    'transformRequest': defaultToConfig2,\\n    'transformResponse': defaultToConfig2,\\n    'paramsSerializer': defaultToConfig2,\\n    'timeout': defaultToConfig2,\\n    'timeoutMessage': defaultToConfig2,\\n    'withCredentials': defaultToConfig2,\\n    'adapter': defaultToConfig2,\\n    'responseType': defaultToConfig2,\\n    'xsrfCookieName': defaultToConfig2,\\n    'xsrfHeaderName': defaultToConfig2,\\n    'onUploadProgress': defaultToConfig2,\\n    'onDownloadProgress': defaultToConfig2,\\n    'decompress': defaultToConfig2,\\n    'maxContentLength': defaultToConfig2,\\n    'maxBodyLength': defaultToConfig2,\\n    'transport': defaultToConfig2,\\n    'httpAgent': defaultToConfig2,\\n    'httpsAgent': defaultToConfig2,\\n    'cancelToken': defaultToConfig2,\\n    'socketPath': defaultToConfig2,\\n    'responseEncoding': defaultToConfig2,\\n    'validateStatus': mergeDirectKeys\\n  };\\n\\n  utils.forEach(Object.keys(config1).concat(Object.keys(config2)), function computeConfigValue(prop) {\\n    var merge = mergeMap[prop] || mergeDeepProperties;\\n    var configValue = merge(prop);\\n    (utils.isUndefined(configValue) && merge !== mergeDirectKeys) || (config[prop] = configValue);\\n  });\\n\\n  return config;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/mergeConfig.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/settle.js\":\n/*!************************************************!*\\\n  !*** ../node_modules/axios/lib/core/settle.js ***!\n  \\************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar createError = __webpack_require__(/*! ./createError */ \\\"../node_modules/axios/lib/core/createError.js\\\");\\n\\n/**\\n * Resolve or reject a Promise based on response status.\\n *\\n * @param {Function} resolve A function that resolves the promise.\\n * @param {Function} reject A function that rejects the promise.\\n * @param {object} response The response.\\n */\\nmodule.exports = function settle(resolve, reject, response) {\\n  var validateStatus = response.config.validateStatus;\\n  if (!response.status || !validateStatus || validateStatus(response.status)) {\\n    resolve(response);\\n  } else {\\n    reject(createError(\\n      'Request failed with status code ' + response.status,\\n      response.config,\\n      null,\\n      response.request,\\n      response\\n    ));\\n  }\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/settle.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/core/transformData.js\":\n/*!*******************************************************!*\\\n  !*** ../node_modules/axios/lib/core/transformData.js ***!\n  \\*******************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar defaults = __webpack_require__(/*! ../defaults */ \\\"../node_modules/axios/lib/defaults/index.js\\\");\\n\\n/**\\n * Transform the data for a request or a response\\n *\\n * @param {Object|String} data The data to be transformed\\n * @param {Array} headers The headers for the request or response\\n * @param {Array|Function} fns A single function or Array of functions\\n * @returns {*} The resulting transformed data\\n */\\nmodule.exports = function transformData(data, headers, fns) {\\n  var context = this || defaults;\\n  /*eslint no-param-reassign:0*/\\n  utils.forEach(fns, function transform(fn) {\\n    data = fn.call(context, data, headers);\\n  });\\n\\n  return data;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/core/transformData.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/defaults/index.js\":\n/*!***************************************************!*\\\n  !*** ../node_modules/axios/lib/defaults/index.js ***!\n  \\***************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\nvar normalizeHeaderName = __webpack_require__(/*! ../helpers/normalizeHeaderName */ \\\"../node_modules/axios/lib/helpers/normalizeHeaderName.js\\\");\\nvar enhanceError = __webpack_require__(/*! ../core/enhanceError */ \\\"../node_modules/axios/lib/core/enhanceError.js\\\");\\nvar transitionalDefaults = __webpack_require__(/*! ./transitional */ \\\"../node_modules/axios/lib/defaults/transitional.js\\\");\\n\\nvar DEFAULT_CONTENT_TYPE = {\\n  'Content-Type': 'application/x-www-form-urlencoded'\\n};\\n\\nfunction setContentTypeIfUnset(headers, value) {\\n  if (!utils.isUndefined(headers) && utils.isUndefined(headers['Content-Type'])) {\\n    headers['Content-Type'] = value;\\n  }\\n}\\n\\nfunction getDefaultAdapter() {\\n  var adapter;\\n  if (typeof XMLHttpRequest !== 'undefined') {\\n    // For browsers use XHR adapter\\n    adapter = __webpack_require__(/*! ../adapters/xhr */ \\\"../node_modules/axios/lib/adapters/xhr.js\\\");\\n  } else if (typeof process !== 'undefined' && Object.prototype.toString.call(process) === '[object process]') {\\n    // For node use HTTP adapter\\n    adapter = __webpack_require__(/*! ../adapters/http */ \\\"../node_modules/axios/lib/adapters/xhr.js\\\");\\n  }\\n  return adapter;\\n}\\n\\nfunction stringifySafely(rawValue, parser, encoder) {\\n  if (utils.isString(rawValue)) {\\n    try {\\n      (parser || JSON.parse)(rawValue);\\n      return utils.trim(rawValue);\\n    } catch (e) {\\n      if (e.name !== 'SyntaxError') {\\n        throw e;\\n      }\\n    }\\n  }\\n\\n  return (encoder || JSON.stringify)(rawValue);\\n}\\n\\nvar defaults = {\\n\\n  transitional: transitionalDefaults,\\n\\n  adapter: getDefaultAdapter(),\\n\\n  transformRequest: [function transformRequest(data, headers) {\\n    normalizeHeaderName(headers, 'Accept');\\n    normalizeHeaderName(headers, 'Content-Type');\\n\\n    if (utils.isFormData(data) ||\\n      utils.isArrayBuffer(data) ||\\n      utils.isBuffer(data) ||\\n      utils.isStream(data) ||\\n      utils.isFile(data) ||\\n      utils.isBlob(data)\\n    ) {\\n      return data;\\n    }\\n    if (utils.isArrayBufferView(data)) {\\n      return data.buffer;\\n    }\\n    if (utils.isURLSearchParams(data)) {\\n      setContentTypeIfUnset(headers, 'application/x-www-form-urlencoded;charset=utf-8');\\n      return data.toString();\\n    }\\n    if (utils.isObject(data) || (headers && headers['Content-Type'] === 'application/json')) {\\n      setContentTypeIfUnset(headers, 'application/json');\\n      return stringifySafely(data);\\n    }\\n    return data;\\n  }],\\n\\n  transformResponse: [function transformResponse(data) {\\n    var transitional = this.transitional || defaults.transitional;\\n    var silentJSONParsing = transitional && transitional.silentJSONParsing;\\n    var forcedJSONParsing = transitional && transitional.forcedJSONParsing;\\n    var strictJSONParsing = !silentJSONParsing && this.responseType === 'json';\\n\\n    if (strictJSONParsing || (forcedJSONParsing && utils.isString(data) && data.length)) {\\n      try {\\n        return JSON.parse(data);\\n      } catch (e) {\\n        if (strictJSONParsing) {\\n          if (e.name === 'SyntaxError') {\\n            throw enhanceError(e, this, 'E_JSON_PARSE');\\n          }\\n          throw e;\\n        }\\n      }\\n    }\\n\\n    return data;\\n  }],\\n\\n  /**\\n   * A timeout in milliseconds to abort a request. If set to 0 (default) a\\n   * timeout is not created.\\n   */\\n  timeout: 0,\\n\\n  xsrfCookieName: 'XSRF-TOKEN',\\n  xsrfHeaderName: 'X-XSRF-TOKEN',\\n\\n  maxContentLength: -1,\\n  maxBodyLength: -1,\\n\\n  validateStatus: function validateStatus(status) {\\n    return status >= 200 && status < 300;\\n  },\\n\\n  headers: {\\n    common: {\\n      'Accept': 'application/json, text/plain, */*'\\n    }\\n  }\\n};\\n\\nutils.forEach(['delete', 'get', 'head'], function forEachMethodNoData(method) {\\n  defaults.headers[method] = {};\\n});\\n\\nutils.forEach(['post', 'put', 'patch'], function forEachMethodWithData(method) {\\n  defaults.headers[method] = utils.merge(DEFAULT_CONTENT_TYPE);\\n});\\n\\nmodule.exports = defaults;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/defaults/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/defaults/transitional.js\":\n/*!**********************************************************!*\\\n  !*** ../node_modules/axios/lib/defaults/transitional.js ***!\n  \\**********************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\nmodule.exports = {\\n  silentJSONParsing: true,\\n  forcedJSONParsing: true,\\n  clarifyTimeoutError: false\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/defaults/transitional.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/env/data.js\":\n/*!*********************************************!*\\\n  !*** ../node_modules/axios/lib/env/data.js ***!\n  \\*********************************************/\n/***/ ((module) => {\n\neval(\"module.exports = {\\n  \\\"version\\\": \\\"0.26.1\\\"\\n};\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/env/data.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/bind.js\":\n/*!*************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/bind.js ***!\n  \\*************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\nmodule.exports = function bind(fn, thisArg) {\\n  return function wrap() {\\n    var args = new Array(arguments.length);\\n    for (var i = 0; i < args.length; i++) {\\n      args[i] = arguments[i];\\n    }\\n    return fn.apply(thisArg, args);\\n  };\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/bind.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/buildURL.js\":\n/*!*****************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/buildURL.js ***!\n  \\*****************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\nfunction encode(val) {\\n  return encodeURIComponent(val).\\n    replace(/%3A/gi, ':').\\n    replace(/%24/g, '$').\\n    replace(/%2C/gi, ',').\\n    replace(/%20/g, '+').\\n    replace(/%5B/gi, '[').\\n    replace(/%5D/gi, ']');\\n}\\n\\n/**\\n * Build a URL by appending params to the end\\n *\\n * @param {string} url The base of the url (e.g., http://www.google.com)\\n * @param {object} [params] The params to be appended\\n * @returns {string} The formatted url\\n */\\nmodule.exports = function buildURL(url, params, paramsSerializer) {\\n  /*eslint no-param-reassign:0*/\\n  if (!params) {\\n    return url;\\n  }\\n\\n  var serializedParams;\\n  if (paramsSerializer) {\\n    serializedParams = paramsSerializer(params);\\n  } else if (utils.isURLSearchParams(params)) {\\n    serializedParams = params.toString();\\n  } else {\\n    var parts = [];\\n\\n    utils.forEach(params, function serialize(val, key) {\\n      if (val === null || typeof val === 'undefined') {\\n        return;\\n      }\\n\\n      if (utils.isArray(val)) {\\n        key = key + '[]';\\n      } else {\\n        val = [val];\\n      }\\n\\n      utils.forEach(val, function parseValue(v) {\\n        if (utils.isDate(v)) {\\n          v = v.toISOString();\\n        } else if (utils.isObject(v)) {\\n          v = JSON.stringify(v);\\n        }\\n        parts.push(encode(key) + '=' + encode(v));\\n      });\\n    });\\n\\n    serializedParams = parts.join('&');\\n  }\\n\\n  if (serializedParams) {\\n    var hashmarkIndex = url.indexOf('#');\\n    if (hashmarkIndex !== -1) {\\n      url = url.slice(0, hashmarkIndex);\\n    }\\n\\n    url += (url.indexOf('?') === -1 ? '?' : '&') + serializedParams;\\n  }\\n\\n  return url;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/buildURL.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/combineURLs.js\":\n/*!********************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/combineURLs.js ***!\n  \\********************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Creates a new URL by combining the specified URLs\\n *\\n * @param {string} baseURL The base URL\\n * @param {string} relativeURL The relative URL\\n * @returns {string} The combined URL\\n */\\nmodule.exports = function combineURLs(baseURL, relativeURL) {\\n  return relativeURL\\n    ? baseURL.replace(/\\\\/+$/, '') + '/' + relativeURL.replace(/^\\\\/+/, '')\\n    : baseURL;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/combineURLs.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/cookies.js\":\n/*!****************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/cookies.js ***!\n  \\****************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\nmodule.exports = (\\n  utils.isStandardBrowserEnv() ?\\n\\n  // Standard browser envs support document.cookie\\n    (function standardBrowserEnv() {\\n      return {\\n        write: function write(name, value, expires, path, domain, secure) {\\n          var cookie = [];\\n          cookie.push(name + '=' + encodeURIComponent(value));\\n\\n          if (utils.isNumber(expires)) {\\n            cookie.push('expires=' + new Date(expires).toGMTString());\\n          }\\n\\n          if (utils.isString(path)) {\\n            cookie.push('path=' + path);\\n          }\\n\\n          if (utils.isString(domain)) {\\n            cookie.push('domain=' + domain);\\n          }\\n\\n          if (secure === true) {\\n            cookie.push('secure');\\n          }\\n\\n          document.cookie = cookie.join('; ');\\n        },\\n\\n        read: function read(name) {\\n          var match = document.cookie.match(new RegExp('(^|;\\\\\\\\s*)(' + name + ')=([^;]*)'));\\n          return (match ? decodeURIComponent(match[3]) : null);\\n        },\\n\\n        remove: function remove(name) {\\n          this.write(name, '', Date.now() - 86400000);\\n        }\\n      };\\n    })() :\\n\\n  // Non standard browser env (web workers, react-native) lack needed support.\\n    (function nonStandardBrowserEnv() {\\n      return {\\n        write: function write() {},\\n        read: function read() { return null; },\\n        remove: function remove() {}\\n      };\\n    })()\\n);\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/cookies.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/isAbsoluteURL.js\":\n/*!**********************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/isAbsoluteURL.js ***!\n  \\**********************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Determines whether the specified URL is absolute\\n *\\n * @param {string} url The URL to test\\n * @returns {boolean} True if the specified URL is absolute, otherwise false\\n */\\nmodule.exports = function isAbsoluteURL(url) {\\n  // A URL is considered absolute if it begins with \\\"<scheme>://\\\" or \\\"//\\\" (protocol-relative URL).\\n  // RFC 3986 defines scheme name as a sequence of characters beginning with a letter and followed\\n  // by any combination of letters, digits, plus, period, or hyphen.\\n  return /^([a-z][a-z\\\\d+\\\\-.]*:)?\\\\/\\\\//i.test(url);\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/isAbsoluteURL.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/isAxiosError.js\":\n/*!*********************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/isAxiosError.js ***!\n  \\*********************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\n/**\\n * Determines whether the payload is an error thrown by Axios\\n *\\n * @param {*} payload The value to test\\n * @returns {boolean} True if the payload is an error thrown by Axios, otherwise false\\n */\\nmodule.exports = function isAxiosError(payload) {\\n  return utils.isObject(payload) && (payload.isAxiosError === true);\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/isAxiosError.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/isURLSameOrigin.js\":\n/*!************************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/isURLSameOrigin.js ***!\n  \\************************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\nmodule.exports = (\\n  utils.isStandardBrowserEnv() ?\\n\\n  // Standard browser envs have full support of the APIs needed to test\\n  // whether the request URL is of the same origin as current location.\\n    (function standardBrowserEnv() {\\n      var msie = /(msie|trident)/i.test(navigator.userAgent);\\n      var urlParsingNode = document.createElement('a');\\n      var originURL;\\n\\n      /**\\n    * Parse a URL to discover it's components\\n    *\\n    * @param {String} url The URL to be parsed\\n    * @returns {Object}\\n    */\\n      function resolveURL(url) {\\n        var href = url;\\n\\n        if (msie) {\\n        // IE needs attribute set twice to normalize properties\\n          urlParsingNode.setAttribute('href', href);\\n          href = urlParsingNode.href;\\n        }\\n\\n        urlParsingNode.setAttribute('href', href);\\n\\n        // urlParsingNode provides the UrlUtils interface - http://url.spec.whatwg.org/#urlutils\\n        return {\\n          href: urlParsingNode.href,\\n          protocol: urlParsingNode.protocol ? urlParsingNode.protocol.replace(/:$/, '') : '',\\n          host: urlParsingNode.host,\\n          search: urlParsingNode.search ? urlParsingNode.search.replace(/^\\\\?/, '') : '',\\n          hash: urlParsingNode.hash ? urlParsingNode.hash.replace(/^#/, '') : '',\\n          hostname: urlParsingNode.hostname,\\n          port: urlParsingNode.port,\\n          pathname: (urlParsingNode.pathname.charAt(0) === '/') ?\\n            urlParsingNode.pathname :\\n            '/' + urlParsingNode.pathname\\n        };\\n      }\\n\\n      originURL = resolveURL(window.location.href);\\n\\n      /**\\n    * Determine if a URL shares the same origin as the current location\\n    *\\n    * @param {String} requestURL The URL to test\\n    * @returns {boolean} True if URL shares the same origin, otherwise false\\n    */\\n      return function isURLSameOrigin(requestURL) {\\n        var parsed = (utils.isString(requestURL)) ? resolveURL(requestURL) : requestURL;\\n        return (parsed.protocol === originURL.protocol &&\\n            parsed.host === originURL.host);\\n      };\\n    })() :\\n\\n  // Non standard browser envs (web workers, react-native) lack needed support.\\n    (function nonStandardBrowserEnv() {\\n      return function isURLSameOrigin() {\\n        return true;\\n      };\\n    })()\\n);\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/isURLSameOrigin.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/normalizeHeaderName.js\":\n/*!****************************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/normalizeHeaderName.js ***!\n  \\****************************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\nmodule.exports = function normalizeHeaderName(headers, normalizedName) {\\n  utils.forEach(headers, function processHeader(value, name) {\\n    if (name !== normalizedName && name.toUpperCase() === normalizedName.toUpperCase()) {\\n      headers[normalizedName] = value;\\n      delete headers[name];\\n    }\\n  });\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/normalizeHeaderName.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/parseHeaders.js\":\n/*!*********************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/parseHeaders.js ***!\n  \\*********************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./../utils */ \\\"../node_modules/axios/lib/utils.js\\\");\\n\\n// Headers whose duplicates are ignored by node\\n// c.f. https://nodejs.org/api/http.html#http_message_headers\\nvar ignoreDuplicateOf = [\\n  'age', 'authorization', 'content-length', 'content-type', 'etag',\\n  'expires', 'from', 'host', 'if-modified-since', 'if-unmodified-since',\\n  'last-modified', 'location', 'max-forwards', 'proxy-authorization',\\n  'referer', 'retry-after', 'user-agent'\\n];\\n\\n/**\\n * Parse headers into an object\\n *\\n * ```\\n * Date: Wed, 27 Aug 2014 08:58:49 GMT\\n * Content-Type: application/json\\n * Connection: keep-alive\\n * Transfer-Encoding: chunked\\n * ```\\n *\\n * @param {String} headers Headers needing to be parsed\\n * @returns {Object} Headers parsed into an object\\n */\\nmodule.exports = function parseHeaders(headers) {\\n  var parsed = {};\\n  var key;\\n  var val;\\n  var i;\\n\\n  if (!headers) { return parsed; }\\n\\n  utils.forEach(headers.split('\\\\n'), function parser(line) {\\n    i = line.indexOf(':');\\n    key = utils.trim(line.substr(0, i)).toLowerCase();\\n    val = utils.trim(line.substr(i + 1));\\n\\n    if (key) {\\n      if (parsed[key] && ignoreDuplicateOf.indexOf(key) >= 0) {\\n        return;\\n      }\\n      if (key === 'set-cookie') {\\n        parsed[key] = (parsed[key] ? parsed[key] : []).concat([val]);\\n      } else {\\n        parsed[key] = parsed[key] ? parsed[key] + ', ' + val : val;\\n      }\\n    }\\n  });\\n\\n  return parsed;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/parseHeaders.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/spread.js\":\n/*!***************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/spread.js ***!\n  \\***************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/**\\n * Syntactic sugar for invoking a function and expanding an array for arguments.\\n *\\n * Common use case would be to use `Function.prototype.apply`.\\n *\\n *  ```js\\n *  function f(x, y, z) {}\\n *  var args = [1, 2, 3];\\n *  f.apply(null, args);\\n *  ```\\n *\\n * With `spread` this example can be re-written.\\n *\\n *  ```js\\n *  spread(function(x, y, z) {})([1, 2, 3]);\\n *  ```\\n *\\n * @param {Function} callback\\n * @returns {Function}\\n */\\nmodule.exports = function spread(callback) {\\n  return function wrap(arr) {\\n    return callback.apply(null, arr);\\n  };\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/spread.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/helpers/validator.js\":\n/*!******************************************************!*\\\n  !*** ../node_modules/axios/lib/helpers/validator.js ***!\n  \\******************************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar VERSION = (__webpack_require__(/*! ../env/data */ \\\"../node_modules/axios/lib/env/data.js\\\").version);\\n\\nvar validators = {};\\n\\n// eslint-disable-next-line func-names\\n['object', 'boolean', 'number', 'function', 'string', 'symbol'].forEach(function(type, i) {\\n  validators[type] = function validator(thing) {\\n    return typeof thing === type || 'a' + (i < 1 ? 'n ' : ' ') + type;\\n  };\\n});\\n\\nvar deprecatedWarnings = {};\\n\\n/**\\n * Transitional option validator\\n * @param {function|boolean?} validator - set to false if the transitional option has been removed\\n * @param {string?} version - deprecated version / removed since version\\n * @param {string?} message - some message with additional info\\n * @returns {function}\\n */\\nvalidators.transitional = function transitional(validator, version, message) {\\n  function formatMessage(opt, desc) {\\n    return '[Axios v' + VERSION + '] Transitional option \\\\'' + opt + '\\\\'' + desc + (message ? '. ' + message : '');\\n  }\\n\\n  // eslint-disable-next-line func-names\\n  return function(value, opt, opts) {\\n    if (validator === false) {\\n      throw new Error(formatMessage(opt, ' has been removed' + (version ? ' in ' + version : '')));\\n    }\\n\\n    if (version && !deprecatedWarnings[opt]) {\\n      deprecatedWarnings[opt] = true;\\n      // eslint-disable-next-line no-console\\n      console.warn(\\n        formatMessage(\\n          opt,\\n          ' has been deprecated since v' + version + ' and will be removed in the near future'\\n        )\\n      );\\n    }\\n\\n    return validator ? validator(value, opt, opts) : true;\\n  };\\n};\\n\\n/**\\n * Assert object's properties type\\n * @param {object} options\\n * @param {object} schema\\n * @param {boolean?} allowUnknown\\n */\\n\\nfunction assertOptions(options, schema, allowUnknown) {\\n  if (typeof options !== 'object') {\\n    throw new TypeError('options must be an object');\\n  }\\n  var keys = Object.keys(options);\\n  var i = keys.length;\\n  while (i-- > 0) {\\n    var opt = keys[i];\\n    var validator = schema[opt];\\n    if (validator) {\\n      var value = options[opt];\\n      var result = value === undefined || validator(value, opt, options);\\n      if (result !== true) {\\n        throw new TypeError('option ' + opt + ' must be ' + result);\\n      }\\n      continue;\\n    }\\n    if (allowUnknown !== true) {\\n      throw Error('Unknown option ' + opt);\\n    }\\n  }\\n}\\n\\nmodule.exports = {\\n  assertOptions: assertOptions,\\n  validators: validators\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/helpers/validator.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/axios/lib/utils.js\":\n/*!******************************************!*\\\n  !*** ../node_modules/axios/lib/utils.js ***!\n  \\******************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar bind = __webpack_require__(/*! ./helpers/bind */ \\\"../node_modules/axios/lib/helpers/bind.js\\\");\\n\\n// utils is a library of generic helper functions non-specific to axios\\n\\nvar toString = Object.prototype.toString;\\n\\n/**\\n * Determine if a value is an Array\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is an Array, otherwise false\\n */\\nfunction isArray(val) {\\n  return Array.isArray(val);\\n}\\n\\n/**\\n * Determine if a value is undefined\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if the value is undefined, otherwise false\\n */\\nfunction isUndefined(val) {\\n  return typeof val === 'undefined';\\n}\\n\\n/**\\n * Determine if a value is a Buffer\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Buffer, otherwise false\\n */\\nfunction isBuffer(val) {\\n  return val !== null && !isUndefined(val) && val.constructor !== null && !isUndefined(val.constructor)\\n    && typeof val.constructor.isBuffer === 'function' && val.constructor.isBuffer(val);\\n}\\n\\n/**\\n * Determine if a value is an ArrayBuffer\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is an ArrayBuffer, otherwise false\\n */\\nfunction isArrayBuffer(val) {\\n  return toString.call(val) === '[object ArrayBuffer]';\\n}\\n\\n/**\\n * Determine if a value is a FormData\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is an FormData, otherwise false\\n */\\nfunction isFormData(val) {\\n  return toString.call(val) === '[object FormData]';\\n}\\n\\n/**\\n * Determine if a value is a view on an ArrayBuffer\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a view on an ArrayBuffer, otherwise false\\n */\\nfunction isArrayBufferView(val) {\\n  var result;\\n  if ((typeof ArrayBuffer !== 'undefined') && (ArrayBuffer.isView)) {\\n    result = ArrayBuffer.isView(val);\\n  } else {\\n    result = (val) && (val.buffer) && (isArrayBuffer(val.buffer));\\n  }\\n  return result;\\n}\\n\\n/**\\n * Determine if a value is a String\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a String, otherwise false\\n */\\nfunction isString(val) {\\n  return typeof val === 'string';\\n}\\n\\n/**\\n * Determine if a value is a Number\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Number, otherwise false\\n */\\nfunction isNumber(val) {\\n  return typeof val === 'number';\\n}\\n\\n/**\\n * Determine if a value is an Object\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is an Object, otherwise false\\n */\\nfunction isObject(val) {\\n  return val !== null && typeof val === 'object';\\n}\\n\\n/**\\n * Determine if a value is a plain Object\\n *\\n * @param {Object} val The value to test\\n * @return {boolean} True if value is a plain Object, otherwise false\\n */\\nfunction isPlainObject(val) {\\n  if (toString.call(val) !== '[object Object]') {\\n    return false;\\n  }\\n\\n  var prototype = Object.getPrototypeOf(val);\\n  return prototype === null || prototype === Object.prototype;\\n}\\n\\n/**\\n * Determine if a value is a Date\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Date, otherwise false\\n */\\nfunction isDate(val) {\\n  return toString.call(val) === '[object Date]';\\n}\\n\\n/**\\n * Determine if a value is a File\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a File, otherwise false\\n */\\nfunction isFile(val) {\\n  return toString.call(val) === '[object File]';\\n}\\n\\n/**\\n * Determine if a value is a Blob\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Blob, otherwise false\\n */\\nfunction isBlob(val) {\\n  return toString.call(val) === '[object Blob]';\\n}\\n\\n/**\\n * Determine if a value is a Function\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Function, otherwise false\\n */\\nfunction isFunction(val) {\\n  return toString.call(val) === '[object Function]';\\n}\\n\\n/**\\n * Determine if a value is a Stream\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a Stream, otherwise false\\n */\\nfunction isStream(val) {\\n  return isObject(val) && isFunction(val.pipe);\\n}\\n\\n/**\\n * Determine if a value is a URLSearchParams object\\n *\\n * @param {Object} val The value to test\\n * @returns {boolean} True if value is a URLSearchParams object, otherwise false\\n */\\nfunction isURLSearchParams(val) {\\n  return toString.call(val) === '[object URLSearchParams]';\\n}\\n\\n/**\\n * Trim excess whitespace off the beginning and end of a string\\n *\\n * @param {String} str The String to trim\\n * @returns {String} The String freed of excess whitespace\\n */\\nfunction trim(str) {\\n  return str.trim ? str.trim() : str.replace(/^\\\\s+|\\\\s+$/g, '');\\n}\\n\\n/**\\n * Determine if we're running in a standard browser environment\\n *\\n * This allows axios to run in a web worker, and react-native.\\n * Both environments support XMLHttpRequest, but not fully standard globals.\\n *\\n * web workers:\\n *  typeof window -> undefined\\n *  typeof document -> undefined\\n *\\n * react-native:\\n *  navigator.product -> 'ReactNative'\\n * nativescript\\n *  navigator.product -> 'NativeScript' or 'NS'\\n */\\nfunction isStandardBrowserEnv() {\\n  if (typeof navigator !== 'undefined' && (navigator.product === 'ReactNative' ||\\n                                           navigator.product === 'NativeScript' ||\\n                                           navigator.product === 'NS')) {\\n    return false;\\n  }\\n  return (\\n    typeof window !== 'undefined' &&\\n    typeof document !== 'undefined'\\n  );\\n}\\n\\n/**\\n * Iterate over an Array or an Object invoking a function for each item.\\n *\\n * If `obj` is an Array callback will be called passing\\n * the value, index, and complete array for each item.\\n *\\n * If 'obj' is an Object callback will be called passing\\n * the value, key, and complete object for each property.\\n *\\n * @param {Object|Array} obj The object to iterate\\n * @param {Function} fn The callback to invoke for each item\\n */\\nfunction forEach(obj, fn) {\\n  // Don't bother if no value provided\\n  if (obj === null || typeof obj === 'undefined') {\\n    return;\\n  }\\n\\n  // Force an array if not already something iterable\\n  if (typeof obj !== 'object') {\\n    /*eslint no-param-reassign:0*/\\n    obj = [obj];\\n  }\\n\\n  if (isArray(obj)) {\\n    // Iterate over array values\\n    for (var i = 0, l = obj.length; i < l; i++) {\\n      fn.call(null, obj[i], i, obj);\\n    }\\n  } else {\\n    // Iterate over object keys\\n    for (var key in obj) {\\n      if (Object.prototype.hasOwnProperty.call(obj, key)) {\\n        fn.call(null, obj[key], key, obj);\\n      }\\n    }\\n  }\\n}\\n\\n/**\\n * Accepts varargs expecting each argument to be an object, then\\n * immutably merges the properties of each object and returns result.\\n *\\n * When multiple objects contain the same key the later object in\\n * the arguments list will take precedence.\\n *\\n * Example:\\n *\\n * ```js\\n * var result = merge({foo: 123}, {foo: 456});\\n * console.log(result.foo); // outputs 456\\n * ```\\n *\\n * @param {Object} obj1 Object to merge\\n * @returns {Object} Result of all merge properties\\n */\\nfunction merge(/* obj1, obj2, obj3, ... */) {\\n  var result = {};\\n  function assignValue(val, key) {\\n    if (isPlainObject(result[key]) && isPlainObject(val)) {\\n      result[key] = merge(result[key], val);\\n    } else if (isPlainObject(val)) {\\n      result[key] = merge({}, val);\\n    } else if (isArray(val)) {\\n      result[key] = val.slice();\\n    } else {\\n      result[key] = val;\\n    }\\n  }\\n\\n  for (var i = 0, l = arguments.length; i < l; i++) {\\n    forEach(arguments[i], assignValue);\\n  }\\n  return result;\\n}\\n\\n/**\\n * Extends object a by mutably adding to it the properties of object b.\\n *\\n * @param {Object} a The object to be extended\\n * @param {Object} b The object to copy properties from\\n * @param {Object} thisArg The object to bind function to\\n * @return {Object} The resulting value of object a\\n */\\nfunction extend(a, b, thisArg) {\\n  forEach(b, function assignValue(val, key) {\\n    if (thisArg && typeof val === 'function') {\\n      a[key] = bind(val, thisArg);\\n    } else {\\n      a[key] = val;\\n    }\\n  });\\n  return a;\\n}\\n\\n/**\\n * Remove byte order marker. This catches EF BB BF (the UTF-8 BOM)\\n *\\n * @param {string} content with BOM\\n * @return {string} content value without BOM\\n */\\nfunction stripBOM(content) {\\n  if (content.charCodeAt(0) === 0xFEFF) {\\n    content = content.slice(1);\\n  }\\n  return content;\\n}\\n\\nmodule.exports = {\\n  isArray: isArray,\\n  isArrayBuffer: isArrayBuffer,\\n  isBuffer: isBuffer,\\n  isFormData: isFormData,\\n  isArrayBufferView: isArrayBufferView,\\n  isString: isString,\\n  isNumber: isNumber,\\n  isObject: isObject,\\n  isPlainObject: isPlainObject,\\n  isUndefined: isUndefined,\\n  isDate: isDate,\\n  isFile: isFile,\\n  isBlob: isBlob,\\n  isFunction: isFunction,\\n  isStream: isStream,\\n  isURLSearchParams: isURLSearchParams,\\n  isStandardBrowserEnv: isStandardBrowserEnv,\\n  forEach: forEach,\\n  merge: merge,\\n  extend: extend,\\n  trim: trim,\\n  stripBOM: stripBOM\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/axios/lib/utils.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/call-bind/callBound.js\":\n/*!**********************************************!*\\\n  !*** ../node_modules/call-bind/callBound.js ***!\n  \\**********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \\\"../node_modules/get-intrinsic/index.js\\\");\\n\\nvar callBind = __webpack_require__(/*! ./ */ \\\"../node_modules/call-bind/index.js\\\");\\n\\nvar $indexOf = callBind(GetIntrinsic('String.prototype.indexOf'));\\n\\nmodule.exports = function callBoundIntrinsic(name, allowMissing) {\\n\\tvar intrinsic = GetIntrinsic(name, !!allowMissing);\\n\\tif (typeof intrinsic === 'function' && $indexOf(name, '.prototype.') > -1) {\\n\\t\\treturn callBind(intrinsic);\\n\\t}\\n\\treturn intrinsic;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/call-bind/callBound.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/call-bind/index.js\":\n/*!******************************************!*\\\n  !*** ../node_modules/call-bind/index.js ***!\n  \\******************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar bind = __webpack_require__(/*! function-bind */ \\\"../node_modules/function-bind/index.js\\\");\\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \\\"../node_modules/get-intrinsic/index.js\\\");\\n\\nvar $apply = GetIntrinsic('%Function.prototype.apply%');\\nvar $call = GetIntrinsic('%Function.prototype.call%');\\nvar $reflectApply = GetIntrinsic('%Reflect.apply%', true) || bind.call($call, $apply);\\n\\nvar $gOPD = GetIntrinsic('%Object.getOwnPropertyDescriptor%', true);\\nvar $defineProperty = GetIntrinsic('%Object.defineProperty%', true);\\nvar $max = GetIntrinsic('%Math.max%');\\n\\nif ($defineProperty) {\\n\\ttry {\\n\\t\\t$defineProperty({}, 'a', { value: 1 });\\n\\t} catch (e) {\\n\\t\\t// IE 8 has a broken defineProperty\\n\\t\\t$defineProperty = null;\\n\\t}\\n}\\n\\nmodule.exports = function callBind(originalFunction) {\\n\\tvar func = $reflectApply(bind, $call, arguments);\\n\\tif ($gOPD && $defineProperty) {\\n\\t\\tvar desc = $gOPD(func, 'length');\\n\\t\\tif (desc.configurable) {\\n\\t\\t\\t// original length, plus the receiver, minus any additional arguments (after the receiver)\\n\\t\\t\\t$defineProperty(\\n\\t\\t\\t\\tfunc,\\n\\t\\t\\t\\t'length',\\n\\t\\t\\t\\t{ value: 1 + $max(0, originalFunction.length - (arguments.length - 1)) }\\n\\t\\t\\t);\\n\\t\\t}\\n\\t}\\n\\treturn func;\\n};\\n\\nvar applyBind = function applyBind() {\\n\\treturn $reflectApply(bind, $apply, arguments);\\n};\\n\\nif ($defineProperty) {\\n\\t$defineProperty(module.exports, 'apply', { value: applyBind });\\n} else {\\n\\tmodule.exports.apply = applyBind;\\n}\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/call-bind/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/contentful-resolve-response/dist/esm/index.js\":\n/*!*********************************************************************!*\\\n  !*** ../node_modules/contentful-resolve-response/dist/esm/index.js ***!\n  \\*********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (__WEBPACK_DEFAULT_EXPORT__)\\n/* harmony export */ });\\n/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-copy */ \\\"../node_modules/fast-copy/dist/fast-copy.js\\\");\\n/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_copy__WEBPACK_IMPORTED_MODULE_0__);\\nvar _typeof = typeof Symbol === \\\"function\\\" && typeof Symbol.iterator === \\\"symbol\\\" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === \\\"function\\\" && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj; };\\n\\nvar _slicedToArray = function () { function sliceIterator(arr, i) { var _arr = []; var _n = true; var _d = false; var _e = undefined; try { for (var _i = arr[Symbol.iterator](), _s; !(_n = (_s = _i.next()).done); _n = true) { _arr.push(_s.value); if (i && _arr.length === i) break; } } catch (err) { _d = true; _e = err; } finally { try { if (!_n && _i[\\\"return\\\"]) _i[\\\"return\\\"](); } finally { if (_d) throw _e; } } return _arr; } return function (arr, i) { if (Array.isArray(arr)) { return arr; } else if (Symbol.iterator in Object(arr)) { return sliceIterator(arr, i); } else { throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance\\\"); } }; }();\\n\\nfunction _toConsumableArray(arr) { if (Array.isArray(arr)) { for (var i = 0, arr2 = Array(arr.length); i < arr.length; i++) { arr2[i] = arr[i]; } return arr2; } else { return Array.from(arr); } }\\n\\n\\n\\nvar UNRESOLVED_LINK = {}; // unique object to avoid polyfill bloat using Symbol()\\n\\n/**\\n * isLink Function\\n * Checks if the object has sys.type \\\"Link\\\"\\n * @param object\\n */\\nvar isLink = function isLink(object) {\\n  return object && object.sys && object.sys.type === 'Link';\\n};\\n\\n/**\\n * isResourceLink Function\\n * Checks if the object has sys.type \\\"ResourceLink\\\"\\n * @param object\\n */\\nvar isResourceLink = function isResourceLink(object) {\\n  return object && object.sys && object.sys.type === 'ResourceLink';\\n};\\n\\n/**\\n * Creates a key with spaceId and a key without for entityMap\\n *\\n * @param {*} sys\\n * @param {String} sys.type\\n * @param {String} sys.id\\n * @param {*} sys.space\\n * @param {*} sys.space.sys\\n * @param {String} sys.space.id\\n * @return {string[]}\\n */\\nvar makeEntityMapKeys = function makeEntityMapKeys(sys) {\\n  return sys.space ? [sys.type + '!' + sys.id, sys.space.sys.id + '!' + sys.type + '!' + sys.id] : [sys.type + '!' + sys.id];\\n};\\n\\n/**\\n * Looks up in entityMap\\n *\\n * @param entityMap\\n * @param {*} linkData\\n * @param {String} linkData.type\\n * @param {String} linkData.linkType\\n * @param {String} linkData.id\\n * @param {String} linkData.urn\\n * @return {String}\\n */\\nvar lookupInEntityMap = function lookupInEntityMap(entityMap, linkData) {\\n  var entryId = linkData.entryId,\\n      linkType = linkData.linkType,\\n      spaceId = linkData.spaceId;\\n\\n  if (spaceId) {\\n    return entityMap.get(spaceId + '!' + linkType + '!' + entryId);\\n  }\\n  return entityMap.get(linkType + '!' + entryId);\\n};\\n\\n/**\\n * getResolvedLink Function\\n *\\n * @param entityMap\\n * @param link\\n * @return {undefined}\\n */\\nvar getResolvedLink = function getResolvedLink(entityMap, link) {\\n  var _link$sys = link.sys,\\n      type = _link$sys.type,\\n      linkType = _link$sys.linkType;\\n\\n  if (type === 'ResourceLink') {\\n    var urn = link.sys.urn;\\n\\n    var regExp = /.*:spaces\\\\/([A-Za-z0-9]*)\\\\/entries\\\\/([A-Za-z0-9]*)/;\\n    if (!regExp.test(urn)) {\\n      return UNRESOLVED_LINK;\\n    }\\n\\n    var _urn$match = urn.match(regExp),\\n        _urn$match2 = _slicedToArray(_urn$match, 3),\\n        _ = _urn$match2[0],\\n        spaceId = _urn$match2[1],\\n        _entryId = _urn$match2[2];\\n\\n    var extractedLinkType = linkType.split(':')[1];\\n    return lookupInEntityMap(entityMap, { linkType: extractedLinkType, entryId: _entryId, spaceId: spaceId }) || UNRESOLVED_LINK;\\n  }\\n  var entryId = link.sys.id;\\n\\n  return lookupInEntityMap(entityMap, { linkType: linkType, entryId: entryId }) || UNRESOLVED_LINK;\\n};\\n\\n/**\\n * cleanUpLinks Function\\n * - Removes unresolvable links from Arrays and Objects\\n *\\n * @param {Object[]|Object} input\\n */\\nvar cleanUpLinks = function cleanUpLinks(input) {\\n  if (Array.isArray(input)) {\\n    return input.filter(function (val) {\\n      return val !== UNRESOLVED_LINK;\\n    });\\n  }\\n  for (var key in input) {\\n    if (input[key] === UNRESOLVED_LINK) {\\n      delete input[key];\\n    }\\n  }\\n  return input;\\n};\\n\\n/**\\n * walkMutate Function\\n * @param input\\n * @param predicate\\n * @param mutator\\n * @param removeUnresolved\\n * @return {*}\\n */\\nvar walkMutate = function walkMutate(input, predicate, mutator, removeUnresolved) {\\n  if (predicate(input)) {\\n    return mutator(input);\\n  }\\n\\n  if (input && (typeof input === 'undefined' ? 'undefined' : _typeof(input)) === 'object') {\\n    for (var key in input) {\\n      // eslint-disable-next-line no-prototype-builtins\\n      if (input.hasOwnProperty(key)) {\\n        input[key] = walkMutate(input[key], predicate, mutator, removeUnresolved);\\n      }\\n    }\\n    if (removeUnresolved) {\\n      input = cleanUpLinks(input);\\n    }\\n  }\\n  return input;\\n};\\n\\nvar normalizeLink = function normalizeLink(entityMap, link, removeUnresolved) {\\n  var resolvedLink = getResolvedLink(entityMap, link);\\n  if (resolvedLink === UNRESOLVED_LINK) {\\n    return removeUnresolved ? resolvedLink : link;\\n  }\\n  return resolvedLink;\\n};\\n\\nvar makeEntryObject = function makeEntryObject(item, itemEntryPoints) {\\n  if (!Array.isArray(itemEntryPoints)) {\\n    return item;\\n  }\\n\\n  var entryPoints = Object.keys(item).filter(function (ownKey) {\\n    return itemEntryPoints.indexOf(ownKey) !== -1;\\n  });\\n\\n  return entryPoints.reduce(function (entryObj, entryPoint) {\\n    entryObj[entryPoint] = item[entryPoint];\\n    return entryObj;\\n  }, {});\\n};\\n\\n/**\\n * resolveResponse Function\\n * Resolves contentful response to normalized form.\\n * @param {Object} response Contentful response\\n * @param {{removeUnresolved: Boolean, itemEntryPoints: Array<String>}|{}} options\\n * @param {Boolean} options.removeUnresolved - Remove unresolved links default:false\\n * @param {Array<String>} options.itemEntryPoints - Resolve links only in those item properties\\n * @return {Object}\\n */\\nvar resolveResponse = function resolveResponse(response, options) {\\n  options = options || {};\\n  if (!response.items) {\\n    return [];\\n  }\\n  var responseClone = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(response);\\n  var allIncludes = Object.keys(responseClone.includes || {}).reduce(function (all, type) {\\n    return [].concat(_toConsumableArray(all), _toConsumableArray(response.includes[type]));\\n  }, []);\\n\\n  var allEntries = [].concat(_toConsumableArray(responseClone.items), _toConsumableArray(allIncludes)).filter(function (entity) {\\n    return Boolean(entity.sys);\\n  });\\n\\n  var entityMap = new Map(allEntries.reduce(function (acc, entity) {\\n    var entries = makeEntityMapKeys(entity.sys).map(function (key) {\\n      return [key, entity];\\n    });\\n    acc.push.apply(acc, _toConsumableArray(entries));\\n    return acc;\\n  }, []));\\n\\n  allEntries.forEach(function (item) {\\n    var entryObject = makeEntryObject(item, options.itemEntryPoints);\\n\\n    Object.assign(item, walkMutate(entryObject, function (x) {\\n      return isLink(x) || isResourceLink(x);\\n    }, function (link) {\\n      return normalizeLink(entityMap, link, options.removeUnresolved);\\n    }, options.removeUnresolved));\\n  });\\n\\n  return responseClone.items;\\n};\\n\\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (resolveResponse);\\n\\n//# sourceURL=webpack://contentful/../node_modules/contentful-resolve-response/dist/esm/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/contentful-sdk-core/dist/index.es-modules.js\":\n/*!********************************************************************!*\\\n  !*** ../node_modules/contentful-sdk-core/dist/index.es-modules.js ***!\n  \\********************************************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createHttpClient\\\": () => (/* binding */ createHttpClient),\\n/* harmony export */   \\\"createRequestConfig\\\": () => (/* binding */ createRequestConfig),\\n/* harmony export */   \\\"enforceObjPath\\\": () => (/* binding */ enforceObjPath),\\n/* harmony export */   \\\"errorHandler\\\": () => (/* binding */ errorHandler),\\n/* harmony export */   \\\"freezeSys\\\": () => (/* binding */ freezeSys),\\n/* harmony export */   \\\"getUserAgentHeader\\\": () => (/* binding */ getUserAgentHeader),\\n/* harmony export */   \\\"toPlainObject\\\": () => (/* binding */ toPlainObject)\\n/* harmony export */ });\\n/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! fast-copy */ \\\"../node_modules/fast-copy/dist/fast-copy.js\\\");\\n/* harmony import */ var fast_copy__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(fast_copy__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! qs */ \\\"../node_modules/qs/lib/index.js\\\");\\n/* harmony import */ var qs__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(qs__WEBPACK_IMPORTED_MODULE_1__);\\n/* harmony import */ var lodash_isstring__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.isstring */ \\\"../node_modules/lodash.isstring/index.js\\\");\\n/* harmony import */ var lodash_isstring__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_isstring__WEBPACK_IMPORTED_MODULE_2__);\\n/* harmony import */ var p_throttle__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! p-throttle */ \\\"../node_modules/p-throttle/index.js\\\");\\n/* harmony import */ var p_throttle__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(p_throttle__WEBPACK_IMPORTED_MODULE_3__);\\n/* harmony import */ var lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! lodash.isplainobject */ \\\"../node_modules/lodash.isplainobject/index.js\\\");\\n/* harmony import */ var lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4__);\\n\\n\\n\\n\\n\\n\\nfunction _iterableToArrayLimit(arr, i) {\\n  var _i = null == arr ? null : \\\"undefined\\\" != typeof Symbol && arr[Symbol.iterator] || arr[\\\"@@iterator\\\"];\\n  if (null != _i) {\\n    var _s,\\n      _e,\\n      _x,\\n      _r,\\n      _arr = [],\\n      _n = !0,\\n      _d = !1;\\n    try {\\n      if (_x = (_i = _i.call(arr)).next, 0 === i) {\\n        if (Object(_i) !== _i) return;\\n        _n = !1;\\n      } else for (; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\\n    } catch (err) {\\n      _d = !0, _e = err;\\n    } finally {\\n      try {\\n        if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\\n      } finally {\\n        if (_d) throw _e;\\n      }\\n    }\\n    return _arr;\\n  }\\n}\\nfunction ownKeys(object, enumerableOnly) {\\n  var keys = Object.keys(object);\\n  if (Object.getOwnPropertySymbols) {\\n    var symbols = Object.getOwnPropertySymbols(object);\\n    enumerableOnly && (symbols = symbols.filter(function (sym) {\\n      return Object.getOwnPropertyDescriptor(object, sym).enumerable;\\n    })), keys.push.apply(keys, symbols);\\n  }\\n  return keys;\\n}\\nfunction _objectSpread2(target) {\\n  for (var i = 1; i < arguments.length; i++) {\\n    var source = null != arguments[i] ? arguments[i] : {};\\n    i % 2 ? ownKeys(Object(source), !0).forEach(function (key) {\\n      _defineProperty(target, key, source[key]);\\n    }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function (key) {\\n      Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\\n    });\\n  }\\n  return target;\\n}\\nfunction _typeof(obj) {\\n  \\\"@babel/helpers - typeof\\\";\\n\\n  return _typeof = \\\"function\\\" == typeof Symbol && \\\"symbol\\\" == typeof Symbol.iterator ? function (obj) {\\n    return typeof obj;\\n  } : function (obj) {\\n    return obj && \\\"function\\\" == typeof Symbol && obj.constructor === Symbol && obj !== Symbol.prototype ? \\\"symbol\\\" : typeof obj;\\n  }, _typeof(obj);\\n}\\nfunction _wrapRegExp() {\\n  _wrapRegExp = function (re, groups) {\\n    return new BabelRegExp(re, void 0, groups);\\n  };\\n  var _super = RegExp.prototype,\\n    _groups = new WeakMap();\\n  function BabelRegExp(re, flags, groups) {\\n    var _this = new RegExp(re, flags);\\n    return _groups.set(_this, groups || _groups.get(re)), _setPrototypeOf(_this, BabelRegExp.prototype);\\n  }\\n  function buildGroups(result, re) {\\n    var g = _groups.get(re);\\n    return Object.keys(g).reduce(function (groups, name) {\\n      var i = g[name];\\n      if (\\\"number\\\" == typeof i) groups[name] = result[i];else {\\n        for (var k = 0; void 0 === result[i[k]] && k + 1 < i.length;) k++;\\n        groups[name] = result[i[k]];\\n      }\\n      return groups;\\n    }, Object.create(null));\\n  }\\n  return _inherits(BabelRegExp, RegExp), BabelRegExp.prototype.exec = function (str) {\\n    var result = _super.exec.call(this, str);\\n    if (result) {\\n      result.groups = buildGroups(result, this);\\n      var indices = result.indices;\\n      indices && (indices.groups = buildGroups(indices, this));\\n    }\\n    return result;\\n  }, BabelRegExp.prototype[Symbol.replace] = function (str, substitution) {\\n    if (\\\"string\\\" == typeof substitution) {\\n      var groups = _groups.get(this);\\n      return _super[Symbol.replace].call(this, str, substitution.replace(/\\\\$<([^>]+)>/g, function (_, name) {\\n        var group = groups[name];\\n        return \\\"$\\\" + (Array.isArray(group) ? group.join(\\\"$\\\") : group);\\n      }));\\n    }\\n    if (\\\"function\\\" == typeof substitution) {\\n      var _this = this;\\n      return _super[Symbol.replace].call(this, str, function () {\\n        var args = arguments;\\n        return \\\"object\\\" != typeof args[args.length - 1] && (args = [].slice.call(args)).push(buildGroups(args, _this)), substitution.apply(this, args);\\n      });\\n    }\\n    return _super[Symbol.replace].call(this, str, substitution);\\n  }, _wrapRegExp.apply(this, arguments);\\n}\\nfunction _defineProperty(obj, key, value) {\\n  key = _toPropertyKey(key);\\n  if (key in obj) {\\n    Object.defineProperty(obj, key, {\\n      value: value,\\n      enumerable: true,\\n      configurable: true,\\n      writable: true\\n    });\\n  } else {\\n    obj[key] = value;\\n  }\\n  return obj;\\n}\\nfunction _inherits(subClass, superClass) {\\n  if (typeof superClass !== \\\"function\\\" && superClass !== null) {\\n    throw new TypeError(\\\"Super expression must either be null or a function\\\");\\n  }\\n  subClass.prototype = Object.create(superClass && superClass.prototype, {\\n    constructor: {\\n      value: subClass,\\n      writable: true,\\n      configurable: true\\n    }\\n  });\\n  Object.defineProperty(subClass, \\\"prototype\\\", {\\n    writable: false\\n  });\\n  if (superClass) _setPrototypeOf(subClass, superClass);\\n}\\nfunction _setPrototypeOf(o, p) {\\n  _setPrototypeOf = Object.setPrototypeOf ? Object.setPrototypeOf.bind() : function _setPrototypeOf(o, p) {\\n    o.__proto__ = p;\\n    return o;\\n  };\\n  return _setPrototypeOf(o, p);\\n}\\nfunction _slicedToArray(arr, i) {\\n  return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\\n}\\nfunction _arrayWithHoles(arr) {\\n  if (Array.isArray(arr)) return arr;\\n}\\nfunction _unsupportedIterableToArray(o, minLen) {\\n  if (!o) return;\\n  if (typeof o === \\\"string\\\") return _arrayLikeToArray(o, minLen);\\n  var n = Object.prototype.toString.call(o).slice(8, -1);\\n  if (n === \\\"Object\\\" && o.constructor) n = o.constructor.name;\\n  if (n === \\\"Map\\\" || n === \\\"Set\\\") return Array.from(o);\\n  if (n === \\\"Arguments\\\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\\n}\\nfunction _arrayLikeToArray(arr, len) {\\n  if (len == null || len > arr.length) len = arr.length;\\n  for (var i = 0, arr2 = new Array(len); i < len; i++) arr2[i] = arr[i];\\n  return arr2;\\n}\\nfunction _nonIterableRest() {\\n  throw new TypeError(\\\"Invalid attempt to destructure non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\");\\n}\\nfunction _createForOfIteratorHelper(o, allowArrayLike) {\\n  var it = typeof Symbol !== \\\"undefined\\\" && o[Symbol.iterator] || o[\\\"@@iterator\\\"];\\n  if (!it) {\\n    if (Array.isArray(o) || (it = _unsupportedIterableToArray(o)) || allowArrayLike && o && typeof o.length === \\\"number\\\") {\\n      if (it) o = it;\\n      var i = 0;\\n      var F = function () {};\\n      return {\\n        s: F,\\n        n: function () {\\n          if (i >= o.length) return {\\n            done: true\\n          };\\n          return {\\n            done: false,\\n            value: o[i++]\\n          };\\n        },\\n        e: function (e) {\\n          throw e;\\n        },\\n        f: F\\n      };\\n    }\\n    throw new TypeError(\\\"Invalid attempt to iterate non-iterable instance.\\\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\\\");\\n  }\\n  var normalCompletion = true,\\n    didErr = false,\\n    err;\\n  return {\\n    s: function () {\\n      it = it.call(o);\\n    },\\n    n: function () {\\n      var step = it.next();\\n      normalCompletion = step.done;\\n      return step;\\n    },\\n    e: function (e) {\\n      didErr = true;\\n      err = e;\\n    },\\n    f: function () {\\n      try {\\n        if (!normalCompletion && it.return != null) it.return();\\n      } finally {\\n        if (didErr) throw err;\\n      }\\n    }\\n  };\\n}\\nfunction _toPrimitive(input, hint) {\\n  if (typeof input !== \\\"object\\\" || input === null) return input;\\n  var prim = input[Symbol.toPrimitive];\\n  if (prim !== undefined) {\\n    var res = prim.call(input, hint || \\\"default\\\");\\n    if (typeof res !== \\\"object\\\") return res;\\n    throw new TypeError(\\\"@@toPrimitive must return a primitive value.\\\");\\n  }\\n  return (hint === \\\"string\\\" ? String : Number)(input);\\n}\\nfunction _toPropertyKey(arg) {\\n  var key = _toPrimitive(arg, \\\"string\\\");\\n  return typeof key === \\\"symbol\\\" ? key : String(key);\\n}\\n\\nfunction isNode() {\\n  /**\\n   * Polyfills of 'process' might set process.browser === true\\n   *\\n   * See:\\n   * https://github.com/webpack/node-libs-browser/blob/master/mock/process.js#L8\\n   * https://github.com/defunctzombie/node-process/blob/master/browser.js#L156\\n   **/\\n  return typeof process !== 'undefined' && !process.browser;\\n}\\nfunction isReactNative() {\\n  return typeof window !== 'undefined' && 'navigator' in window && 'product' in window.navigator && window.navigator.product === 'ReactNative';\\n}\\nfunction getNodeVersion() {\\n  return process.versions && process.versions.node ? \\\"v\\\".concat(process.versions.node) : process.version;\\n}\\nfunction getWindow() {\\n  return window;\\n}\\nfunction noop() {\\n  return undefined;\\n}\\n\\nvar PERCENTAGE_REGEX = /*#__PURE__*/_wrapRegExp(/(\\\\d+)(%)/, {\\n  value: 1\\n});\\nfunction calculateLimit(type) {\\n  var max = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 7;\\n  var limit = max;\\n  if (PERCENTAGE_REGEX.test(type)) {\\n    var _type$match;\\n    var groups = (_type$match = type.match(PERCENTAGE_REGEX)) === null || _type$match === void 0 ? void 0 : _type$match.groups;\\n    if (groups && groups.value) {\\n      var percentage = parseInt(groups.value) / 100;\\n      limit = Math.round(max * percentage);\\n    }\\n  }\\n  return Math.min(30, Math.max(1, limit));\\n}\\nfunction createThrottle(limit, logger) {\\n  logger('info', \\\"Throttle request to \\\".concat(limit, \\\"/s\\\"));\\n  return p_throttle__WEBPACK_IMPORTED_MODULE_3___default()({\\n    limit: limit,\\n    interval: 1000,\\n    strict: false\\n  });\\n}\\nvar rateLimitThrottle = (function (axiosInstance) {\\n  var type = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 'auto';\\n  var _axiosInstance$defaul = axiosInstance.defaults.logHandler,\\n    logHandler = _axiosInstance$defaul === void 0 ? noop : _axiosInstance$defaul;\\n  var limit = lodash_isstring__WEBPACK_IMPORTED_MODULE_2___default()(type) ? calculateLimit(type) : calculateLimit('auto', type);\\n  var throttle = createThrottle(limit, logHandler);\\n  var isCalculated = false;\\n  var requestInterceptorId = axiosInstance.interceptors.request.use(function (config) {\\n    return throttle(function () {\\n      return config;\\n    })();\\n  }, function (error) {\\n    return Promise.reject(error);\\n  });\\n  var responseInterceptorId = axiosInstance.interceptors.response.use(function (response) {\\n    if (!isCalculated && lodash_isstring__WEBPACK_IMPORTED_MODULE_2___default()(type) && (type === 'auto' || PERCENTAGE_REGEX.test(type)) && response.headers && response.headers['x-contentful-ratelimit-second-limit']) {\\n      var rawLimit = parseInt(response.headers['x-contentful-ratelimit-second-limit']);\\n      var nextLimit = calculateLimit(type, rawLimit);\\n      if (nextLimit !== limit) {\\n        if (requestInterceptorId) {\\n          axiosInstance.interceptors.request.eject(requestInterceptorId);\\n        }\\n        limit = nextLimit;\\n        throttle = createThrottle(nextLimit, logHandler);\\n        requestInterceptorId = axiosInstance.interceptors.request.use(function (config) {\\n          return throttle(function () {\\n            return config;\\n          })();\\n        }, function (error) {\\n          return Promise.reject(error);\\n        });\\n      }\\n      isCalculated = true;\\n    }\\n    return response;\\n  }, function (error) {\\n    return Promise.reject(error);\\n  });\\n  return function () {\\n    axiosInstance.interceptors.request.eject(requestInterceptorId);\\n    axiosInstance.interceptors.response.eject(responseInterceptorId);\\n  };\\n});\\n\\nvar delay = function delay(ms) {\\n  return new Promise(function (resolve) {\\n    setTimeout(resolve, ms);\\n  });\\n};\\nvar defaultWait = function defaultWait(attempts) {\\n  return Math.pow(Math.SQRT2, attempts);\\n};\\nfunction rateLimit(instance) {\\n  var maxRetry = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 5;\\n  var _instance$defaults = instance.defaults,\\n    _instance$defaults$re = _instance$defaults.responseLogger,\\n    responseLogger = _instance$defaults$re === void 0 ? noop : _instance$defaults$re,\\n    _instance$defaults$re2 = _instance$defaults.requestLogger,\\n    requestLogger = _instance$defaults$re2 === void 0 ? noop : _instance$defaults$re2;\\n  instance.interceptors.request.use(function (config) {\\n    requestLogger(config);\\n    return config;\\n  }, function (error) {\\n    requestLogger(error);\\n    return Promise.reject(error);\\n  });\\n  instance.interceptors.response.use(function (response) {\\n    // we don't need to do anything here\\n    responseLogger(response);\\n    return response;\\n  }, function (error) {\\n    var response = error.response;\\n    var config = error.config;\\n    responseLogger(error);\\n    // Do not retry if it is disabled or no request config exists (not an axios error)\\n    if (!config || !instance.defaults.retryOnError) {\\n      return Promise.reject(error);\\n    }\\n\\n    // Retried already for max attempts\\n    var doneAttempts = config.attempts || 1;\\n    if (doneAttempts > maxRetry) {\\n      error.attempts = config.attempts;\\n      return Promise.reject(error);\\n    }\\n    var retryErrorType = null;\\n    var wait = defaultWait(doneAttempts);\\n\\n    // Errors without response did not receive anything from the server\\n    if (!response) {\\n      retryErrorType = 'Connection';\\n    } else if (response.status >= 500 && response.status < 600) {\\n      // 5** errors are server related\\n      retryErrorType = \\\"Server \\\".concat(response.status);\\n    } else if (response.status === 429) {\\n      // 429 errors are exceeded rate limit exceptions\\n      retryErrorType = 'Rate limit';\\n      // all headers are lowercased by axios https://github.com/mzabriskie/axios/issues/413\\n      if (response.headers && error.response.headers['x-contentful-ratelimit-reset']) {\\n        wait = response.headers['x-contentful-ratelimit-reset'];\\n      }\\n    }\\n    if (retryErrorType) {\\n      // convert to ms and add jitter\\n      wait = Math.floor(wait * 1000 + Math.random() * 200 + 500);\\n      instance.defaults.logHandler('warning', \\\"\\\".concat(retryErrorType, \\\" error occurred. Waiting for \\\").concat(wait, \\\" ms before retrying...\\\"));\\n\\n      // increase attempts counter\\n      config.attempts = doneAttempts + 1;\\n\\n      /* Somehow between the interceptor and retrying the request the httpAgent/httpsAgent gets transformed from an Agent-like object\\n       to a regular object, causing failures on retries after rate limits. Removing these properties here fixes the error, but retry\\n       requests still use the original http/httpsAgent property */\\n      delete config.httpAgent;\\n      delete config.httpsAgent;\\n      return delay(wait).then(function () {\\n        return instance(config);\\n      });\\n    }\\n    return Promise.reject(error);\\n  });\\n}\\n\\nfunction asyncToken(instance, getToken) {\\n  instance.interceptors.request.use(function (config) {\\n    return getToken().then(function (accessToken) {\\n      config.headers = _objectSpread2(_objectSpread2({}, config.headers), {}, {\\n        Authorization: \\\"Bearer \\\".concat(accessToken)\\n      });\\n      return config;\\n    });\\n  });\\n}\\n\\n// Matches 'sub.host:port' or 'host:port' and extracts hostname and port\\n// Also enforces toplevel domain specified, no spaces and no protocol\\nvar HOST_REGEX = /^(?!\\\\w+:\\\\/\\\\/)([^\\\\s:]+\\\\.?[^\\\\s:]+)(?::(\\\\d+))?(?!:)$/;\\n\\n/**\\n * Create pre configured axios instance\\n * @private\\n * @param {AxiosStatic} axios - Axios library\\n * @param {CreateHttpClientParams} options - Initialization parameters for the HTTP client\\n * @return {ContentfulAxiosInstance} Initialized axios instance\\n */\\nfunction createHttpClient(axios, options) {\\n  var defaultConfig = {\\n    insecure: false,\\n    retryOnError: true,\\n    // eslint-disable-next-line @typescript-eslint/no-explicit-any\\n    logHandler: function logHandler(level, data) {\\n      if (level === 'error' && data) {\\n        var title = [data.name, data.message].filter(function (a) {\\n          return a;\\n        }).join(' - ');\\n        console.error(\\\"[error] \\\".concat(title));\\n        console.error(data);\\n        return;\\n      }\\n      console.log(\\\"[\\\".concat(level, \\\"] \\\").concat(data));\\n    },\\n    // Passed to axios\\n    headers: {},\\n    httpAgent: false,\\n    httpsAgent: false,\\n    timeout: 30000,\\n    throttle: 0,\\n    proxy: false,\\n    basePath: '',\\n    adapter: undefined,\\n    maxContentLength: 1073741824,\\n    // 1GB\\n    maxBodyLength: 1073741824 // 1GB\\n  };\\n\\n  var config = _objectSpread2(_objectSpread2({}, defaultConfig), options);\\n  if (!config.accessToken) {\\n    var missingAccessTokenError = new TypeError('Expected parameter accessToken');\\n    config.logHandler('error', missingAccessTokenError);\\n    throw missingAccessTokenError;\\n  }\\n\\n  // Construct axios baseURL option\\n  var protocol = config.insecure ? 'http' : 'https';\\n  var space = config.space ? \\\"\\\".concat(config.space, \\\"/\\\") : '';\\n  var hostname = config.defaultHostname;\\n  var port = config.insecure ? 80 : 443;\\n  if (config.host && HOST_REGEX.test(config.host)) {\\n    var parsed = config.host.split(':');\\n    if (parsed.length === 2) {\\n      var _parsed = _slicedToArray(parsed, 2);\\n      hostname = _parsed[0];\\n      port = _parsed[1];\\n    } else {\\n      hostname = parsed[0];\\n    }\\n  }\\n\\n  // Ensure that basePath does start but not end with a slash\\n  if (config.basePath) {\\n    config.basePath = \\\"/\\\".concat(config.basePath.split('/').filter(Boolean).join('/'));\\n  }\\n  var baseURL = options.baseURL || \\\"\\\".concat(protocol, \\\"://\\\").concat(hostname, \\\":\\\").concat(port).concat(config.basePath, \\\"/spaces/\\\").concat(space);\\n  if (!config.headers.Authorization && typeof config.accessToken !== 'function') {\\n    config.headers.Authorization = 'Bearer ' + config.accessToken;\\n  }\\n  var axiosOptions = {\\n    // Axios\\n    baseURL: baseURL,\\n    headers: config.headers,\\n    httpAgent: config.httpAgent,\\n    httpsAgent: config.httpsAgent,\\n    paramsSerializer: (qs__WEBPACK_IMPORTED_MODULE_1___default().stringify),\\n    proxy: config.proxy,\\n    timeout: config.timeout,\\n    adapter: config.adapter,\\n    maxContentLength: config.maxContentLength,\\n    maxBodyLength: config.maxBodyLength,\\n    // Contentful\\n    logHandler: config.logHandler,\\n    responseLogger: config.responseLogger,\\n    requestLogger: config.requestLogger,\\n    retryOnError: config.retryOnError\\n  };\\n  var instance = axios.create(axiosOptions);\\n  instance.httpClientParams = options;\\n\\n  /**\\n   * Creates a new axios instance with the same default base parameters as the\\n   * current one, and with any overrides passed to the newParams object\\n   * This is useful as the SDKs use dependency injection to get the axios library\\n   * and the version of the library comes from different places depending\\n   * on whether it's a browser build or a node.js build.\\n   * @private\\n   * @param {CreateHttpClientParams} httpClientParams - Initialization parameters for the HTTP client\\n   * @return {ContentfulAxiosInstance} Initialized axios instance\\n   */\\n  instance.cloneWithNewParams = function (newParams) {\\n    return createHttpClient(axios, _objectSpread2(_objectSpread2({}, fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(options)), newParams));\\n  };\\n\\n  /**\\n   * Apply interceptors.\\n   * Please note that the order of interceptors is important\\n   */\\n\\n  if (config.onBeforeRequest) {\\n    instance.interceptors.request.use(config.onBeforeRequest);\\n  }\\n  if (typeof config.accessToken === 'function') {\\n    asyncToken(instance, config.accessToken);\\n  }\\n  if (config.throttle) {\\n    rateLimitThrottle(instance, config.throttle);\\n  }\\n  rateLimit(instance, config.retryLimit);\\n  if (config.onError) {\\n    instance.interceptors.response.use(function (response) {\\n      return response;\\n    }, config.onError);\\n  }\\n  return instance;\\n}\\n\\n/* eslint-disable @typescript-eslint/no-explicit-any */\\n/**\\n * Creates request parameters configuration by parsing an existing query object\\n * @private\\n * @param {Object} query\\n * @return {Object} Config object with `params` property, ready to be used in axios\\n */\\nfunction createRequestConfig(_ref) {\\n  var query = _ref.query;\\n  var config = {};\\n  delete query.resolveLinks;\\n  config.params = fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(query);\\n  return config;\\n}\\n\\n// eslint-disable-next-line @typescript-eslint/no-explicit-any\\nfunction enforceObjPath(obj, path) {\\n  if (!(path in obj)) {\\n    var err = new Error();\\n    err.name = 'PropertyMissing';\\n    err.message = \\\"Required property \\\".concat(path, \\\" missing from:\\\\n\\\\n\\\").concat(JSON.stringify(obj), \\\"\\\\n\\\\n\\\");\\n    throw err;\\n  }\\n  return true;\\n}\\n\\n// copied from https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/freeze\\n\\nfunction deepFreeze(object) {\\n  var propNames = Object.getOwnPropertyNames(object);\\n  var _iterator = _createForOfIteratorHelper(propNames),\\n    _step;\\n  try {\\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\\n      var name = _step.value;\\n      var value = object[name];\\n      if (value && _typeof(value) === 'object') {\\n        deepFreeze(value);\\n      }\\n    }\\n  } catch (err) {\\n    _iterator.e(err);\\n  } finally {\\n    _iterator.f();\\n  }\\n  return Object.freeze(object);\\n}\\nfunction freezeSys(obj) {\\n  deepFreeze(obj.sys || {});\\n  return obj;\\n}\\n\\nfunction getBrowserOS() {\\n  var win = getWindow();\\n  if (!win) {\\n    return null;\\n  }\\n  var userAgent = win.navigator.userAgent;\\n  // TODO: platform is deprecated.\\n  var platform = win.navigator.platform;\\n  var macosPlatforms = ['Macintosh', 'MacIntel', 'MacPPC', 'Mac68K'];\\n  var windowsPlatforms = ['Win32', 'Win64', 'Windows', 'WinCE'];\\n  var iosPlatforms = ['iPhone', 'iPad', 'iPod'];\\n  if (macosPlatforms.indexOf(platform) !== -1) {\\n    return 'macOS';\\n  } else if (iosPlatforms.indexOf(platform) !== -1) {\\n    return 'iOS';\\n  } else if (windowsPlatforms.indexOf(platform) !== -1) {\\n    return 'Windows';\\n  } else if (/Android/.test(userAgent)) {\\n    return 'Android';\\n  } else if (/Linux/.test(platform)) {\\n    return 'Linux';\\n  }\\n  return null;\\n}\\nfunction getNodeOS() {\\n  var platform = process.platform || 'linux';\\n  var version = process.version || '0.0.0';\\n  var platformMap = {\\n    android: 'Android',\\n    aix: 'Linux',\\n    darwin: 'macOS',\\n    freebsd: 'Linux',\\n    linux: 'Linux',\\n    openbsd: 'Linux',\\n    sunos: 'Linux',\\n    win32: 'Windows'\\n  };\\n  if (platform in platformMap) {\\n    return \\\"\\\".concat(platformMap[platform] || 'Linux', \\\"/\\\").concat(version);\\n  }\\n  return null;\\n}\\nfunction getUserAgentHeader(sdk, application, integration, feature) {\\n  var headerParts = [];\\n  if (application) {\\n    headerParts.push(\\\"app \\\".concat(application));\\n  }\\n  if (integration) {\\n    headerParts.push(\\\"integration \\\".concat(integration));\\n  }\\n  if (feature) {\\n    headerParts.push('feature ' + feature);\\n  }\\n  headerParts.push(\\\"sdk \\\".concat(sdk));\\n  var platform = null;\\n  try {\\n    if (isReactNative()) {\\n      platform = getBrowserOS();\\n      headerParts.push('platform ReactNative');\\n    } else if (isNode()) {\\n      platform = getNodeOS();\\n      headerParts.push(\\\"platform node.js/\\\".concat(getNodeVersion()));\\n    } else {\\n      platform = getBrowserOS();\\n      headerParts.push('platform browser');\\n    }\\n  } catch (e) {\\n    platform = null;\\n  }\\n  if (platform) {\\n    headerParts.push(\\\"os \\\".concat(platform));\\n  }\\n  return \\\"\\\".concat(headerParts.filter(function (item) {\\n    return item !== '';\\n  }).join('; '), \\\";\\\");\\n}\\n\\n/**\\n * Mixes in a method to return just a plain object with no additional methods\\n * @private\\n * @param data - Any plain JSON response returned from the API\\n * @return Enhanced object with toPlainObject method\\n */\\nfunction toPlainObject(data) {\\n  // eslint-disable-next-line @typescript-eslint/ban-ts-comment\\n  // @ts-expect-error\\n  return Object.defineProperty(data, 'toPlainObject', {\\n    enumerable: false,\\n    configurable: false,\\n    writable: false,\\n    value: function value() {\\n      return fast_copy__WEBPACK_IMPORTED_MODULE_0___default()(this);\\n    }\\n  });\\n}\\n\\n/**\\n * Handles errors received from the server. Parses the error into a more useful\\n * format, places it in an exception and throws it.\\n * See https://www.contentful.com/developers/docs/references/errors/\\n * for more details on the data received on the errorResponse.data property\\n * and the expected error codes.\\n * @private\\n */\\nfunction errorHandler(errorResponse) {\\n  var config = errorResponse.config,\\n    response = errorResponse.response;\\n  var errorName;\\n\\n  // Obscure the Management token\\n  if (config && config.headers && config.headers['Authorization']) {\\n    var token = \\\"...\\\".concat(config.headers['Authorization'].toString().substr(-5));\\n    config.headers['Authorization'] = \\\"Bearer \\\".concat(token);\\n  }\\n  if (!lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4___default()(response) || !lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4___default()(config)) {\\n    throw errorResponse;\\n  }\\n  var data = response === null || response === void 0 ? void 0 : response.data;\\n  var errorData = {\\n    status: response === null || response === void 0 ? void 0 : response.status,\\n    statusText: response === null || response === void 0 ? void 0 : response.statusText,\\n    message: '',\\n    details: {}\\n  };\\n  if (lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4___default()(config)) {\\n    errorData.request = {\\n      url: config.url,\\n      headers: config.headers,\\n      method: config.method,\\n      payloadData: config.data\\n    };\\n  }\\n  if (data && lodash_isplainobject__WEBPACK_IMPORTED_MODULE_4___default()(data)) {\\n    if ('requestId' in data) {\\n      errorData.requestId = data.requestId || 'UNKNOWN';\\n    }\\n    if ('message' in data) {\\n      errorData.message = data.message || '';\\n    }\\n    if ('details' in data) {\\n      errorData.details = data.details || {};\\n    }\\n    if ('sys' in data) {\\n      if ('id' in data.sys) {\\n        errorName = data.sys.id;\\n      }\\n    }\\n  }\\n  var error = new Error();\\n  error.name = errorName && errorName !== 'Unknown' ? errorName : \\\"\\\".concat(response === null || response === void 0 ? void 0 : response.status, \\\" \\\").concat(response === null || response === void 0 ? void 0 : response.statusText);\\n  try {\\n    error.message = JSON.stringify(errorData, null, '  ');\\n  } catch (_unused) {\\n    var _errorData$message;\\n    error.message = (_errorData$message = errorData === null || errorData === void 0 ? void 0 : errorData.message) !== null && _errorData$message !== void 0 ? _errorData$message : '';\\n  }\\n  throw error;\\n}\\n\\n\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/contentful-sdk-core/dist/index.es-modules.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/fast-copy/dist/fast-copy.js\":\n/*!***************************************************!*\\\n  !*** ../node_modules/fast-copy/dist/fast-copy.js ***!\n  \\***************************************************/\n/***/ (function(module, __unused_webpack_exports, __webpack_require__) {\n\neval(\"(function (global, factory) {\\n     true ? module.exports = factory() :\\n    0;\\n})(this, (function () { 'use strict';\\n\\n    var toStringFunction = Function.prototype.toString;\\n    var create = Object.create, defineProperty = Object.defineProperty, getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor, getOwnPropertyNames = Object.getOwnPropertyNames, getOwnPropertySymbols = Object.getOwnPropertySymbols, getPrototypeOf$1 = Object.getPrototypeOf;\\n    var _a = Object.prototype, hasOwnProperty = _a.hasOwnProperty, propertyIsEnumerable = _a.propertyIsEnumerable;\\n    var SYMBOL_PROPERTIES = typeof getOwnPropertySymbols === 'function';\\n    var WEAK_MAP = typeof WeakMap === 'function';\\n    /**\\n     * @function createCache\\n     *\\n     * @description\\n     * get a new cache object to prevent circular references\\n     *\\n     * @returns the new cache object\\n     */\\n    var createCache = (function () {\\n        if (WEAK_MAP) {\\n            return function () { return new WeakMap(); };\\n        }\\n        var Cache = /** @class */ (function () {\\n            function Cache() {\\n                this._keys = [];\\n                this._values = [];\\n            }\\n            Cache.prototype.has = function (key) {\\n                return !!~this._keys.indexOf(key);\\n            };\\n            Cache.prototype.get = function (key) {\\n                return this._values[this._keys.indexOf(key)];\\n            };\\n            Cache.prototype.set = function (key, value) {\\n                this._keys.push(key);\\n                this._values.push(value);\\n            };\\n            return Cache;\\n        }());\\n        return function () { return new Cache(); };\\n    })();\\n    /**\\n     * @function getCleanClone\\n     *\\n     * @description\\n     * get an empty version of the object with the same prototype it has\\n     *\\n     * @param object the object to build a clean clone from\\n     * @param realm the realm the object resides in\\n     * @returns the empty cloned object\\n     */\\n    var getCleanClone = function (object, realm) {\\n        var prototype = object.__proto__ || getPrototypeOf$1(object);\\n        if (!prototype) {\\n            return create(null);\\n        }\\n        var Constructor = prototype.constructor;\\n        if (Constructor === realm.Object) {\\n            return prototype === realm.Object.prototype ? {} : create(prototype);\\n        }\\n        if (~toStringFunction.call(Constructor).indexOf('[native code]')) {\\n            try {\\n                return new Constructor();\\n            }\\n            catch (_a) { }\\n        }\\n        return create(prototype);\\n    };\\n    /**\\n     * @function getObjectCloneLoose\\n     *\\n     * @description\\n     * get a copy of the object based on loose rules, meaning all enumerable keys\\n     * and symbols are copied, but property descriptors are not considered\\n     *\\n     * @param object the object to clone\\n     * @param realm the realm the object resides in\\n     * @param handleCopy the function that handles copying the object\\n     * @returns the copied object\\n     */\\n    var getObjectCloneLoose = function (object, realm, handleCopy, cache) {\\n        var clone = getCleanClone(object, realm);\\n        // set in the cache immediately to be able to reuse the object recursively\\n        cache.set(object, clone);\\n        for (var key in object) {\\n            if (hasOwnProperty.call(object, key)) {\\n                clone[key] = handleCopy(object[key], cache);\\n            }\\n        }\\n        if (SYMBOL_PROPERTIES) {\\n            var symbols = getOwnPropertySymbols(object);\\n            for (var index = 0, length_1 = symbols.length, symbol = void 0; index < length_1; ++index) {\\n                symbol = symbols[index];\\n                if (propertyIsEnumerable.call(object, symbol)) {\\n                    clone[symbol] = handleCopy(object[symbol], cache);\\n                }\\n            }\\n        }\\n        return clone;\\n    };\\n    /**\\n     * @function getObjectCloneStrict\\n     *\\n     * @description\\n     * get a copy of the object based on strict rules, meaning all keys and symbols\\n     * are copied based on the original property descriptors\\n     *\\n     * @param object the object to clone\\n     * @param realm the realm the object resides in\\n     * @param handleCopy the function that handles copying the object\\n     * @returns the copied object\\n     */\\n    var getObjectCloneStrict = function (object, realm, handleCopy, cache) {\\n        var clone = getCleanClone(object, realm);\\n        // set in the cache immediately to be able to reuse the object recursively\\n        cache.set(object, clone);\\n        var properties = SYMBOL_PROPERTIES\\n            ? getOwnPropertyNames(object).concat(getOwnPropertySymbols(object))\\n            : getOwnPropertyNames(object);\\n        for (var index = 0, length_2 = properties.length, property = void 0, descriptor = void 0; index < length_2; ++index) {\\n            property = properties[index];\\n            if (property !== 'callee' && property !== 'caller') {\\n                descriptor = getOwnPropertyDescriptor(object, property);\\n                if (descriptor) {\\n                    // Only clone the value if actually a value, not a getter / setter.\\n                    if (!descriptor.get && !descriptor.set) {\\n                        descriptor.value = handleCopy(object[property], cache);\\n                    }\\n                    try {\\n                        defineProperty(clone, property, descriptor);\\n                    }\\n                    catch (error) {\\n                        // Tee above can fail on node in edge cases, so fall back to the loose assignment.\\n                        clone[property] = descriptor.value;\\n                    }\\n                }\\n                else {\\n                    // In extra edge cases where the property descriptor cannot be retrived, fall back to\\n                    // the loose assignment.\\n                    clone[property] = handleCopy(object[property], cache);\\n                }\\n            }\\n        }\\n        return clone;\\n    };\\n    /**\\n     * @function getRegExpFlags\\n     *\\n     * @description\\n     * get the flags to apply to the copied regexp\\n     *\\n     * @param regExp the regexp to get the flags of\\n     * @returns the flags for the regexp\\n     */\\n    var getRegExpFlags = function (regExp) {\\n        var flags = '';\\n        if (regExp.global) {\\n            flags += 'g';\\n        }\\n        if (regExp.ignoreCase) {\\n            flags += 'i';\\n        }\\n        if (regExp.multiline) {\\n            flags += 'm';\\n        }\\n        if (regExp.unicode) {\\n            flags += 'u';\\n        }\\n        if (regExp.sticky) {\\n            flags += 'y';\\n        }\\n        return flags;\\n    };\\n\\n    // utils\\n    var isArray = Array.isArray;\\n    var getPrototypeOf = Object.getPrototypeOf;\\n    var GLOBAL_THIS = (function () {\\n        if (typeof globalThis !== 'undefined') {\\n            return globalThis;\\n        }\\n        if (typeof self !== 'undefined') {\\n            return self;\\n        }\\n        if (typeof window !== 'undefined') {\\n            return window;\\n        }\\n        if (typeof __webpack_require__.g !== 'undefined') {\\n            return __webpack_require__.g;\\n        }\\n        if (console && console.error) {\\n            console.error('Unable to locate global object, returning \\\"this\\\".');\\n        }\\n        return this;\\n    })();\\n    /**\\n     * @function copy\\n     *\\n     * @description\\n     * copy an value deeply as much as possible\\n     *\\n     * If `strict` is applied, then all properties (including non-enumerable ones)\\n     * are copied with their original property descriptors on both objects and arrays.\\n     *\\n     * The value is compared to the global constructors in the `realm` provided,\\n     * and the native constructor is always used to ensure that extensions of native\\n     * objects (allows in ES2015+) are maintained.\\n     *\\n     * @param value the value to copy\\n     * @param [options] the options for copying with\\n     * @param [options.isStrict] should the copy be strict\\n     * @param [options.realm] the realm (this) value the value is copied from\\n     * @returns the copied value\\n     */\\n    function copy(value, options) {\\n        // manually coalesced instead of default parameters for performance\\n        var isStrict = !!(options && options.isStrict);\\n        var realm = (options && options.realm) || GLOBAL_THIS;\\n        var getObjectClone = isStrict ? getObjectCloneStrict : getObjectCloneLoose;\\n        /**\\n         * @function handleCopy\\n         *\\n         * @description\\n         * copy the value recursively based on its type\\n         *\\n         * @param value the value to copy\\n         * @returns the copied value\\n         */\\n        var handleCopy = function (value, cache) {\\n            if (!value || typeof value !== 'object') {\\n                return value;\\n            }\\n            if (cache.has(value)) {\\n                return cache.get(value);\\n            }\\n            var prototype = value.__proto__ || getPrototypeOf(value);\\n            var Constructor = prototype && prototype.constructor;\\n            // plain objects\\n            if (!Constructor || Constructor === realm.Object) {\\n                return getObjectClone(value, realm, handleCopy, cache);\\n            }\\n            var clone;\\n            // arrays\\n            if (isArray(value)) {\\n                // if strict, include non-standard properties\\n                if (isStrict) {\\n                    return getObjectCloneStrict(value, realm, handleCopy, cache);\\n                }\\n                clone = new Constructor();\\n                cache.set(value, clone);\\n                for (var index = 0, length_1 = value.length; index < length_1; ++index) {\\n                    clone[index] = handleCopy(value[index], cache);\\n                }\\n                return clone;\\n            }\\n            // dates\\n            if (value instanceof realm.Date) {\\n                return new Constructor(value.getTime());\\n            }\\n            // regexps\\n            if (value instanceof realm.RegExp) {\\n                clone = new Constructor(value.source, value.flags || getRegExpFlags(value));\\n                clone.lastIndex = value.lastIndex;\\n                return clone;\\n            }\\n            // maps\\n            if (realm.Map && value instanceof realm.Map) {\\n                clone = new Constructor();\\n                cache.set(value, clone);\\n                value.forEach(function (value, key) {\\n                    clone.set(key, handleCopy(value, cache));\\n                });\\n                return clone;\\n            }\\n            // sets\\n            if (realm.Set && value instanceof realm.Set) {\\n                clone = new Constructor();\\n                cache.set(value, clone);\\n                value.forEach(function (value) {\\n                    clone.add(handleCopy(value, cache));\\n                });\\n                return clone;\\n            }\\n            // blobs\\n            if (realm.Blob && value instanceof realm.Blob) {\\n                return value.slice(0, value.size, value.type);\\n            }\\n            // buffers (node-only)\\n            if (realm.Buffer && realm.Buffer.isBuffer(value)) {\\n                clone = realm.Buffer.allocUnsafe\\n                    ? realm.Buffer.allocUnsafe(value.length)\\n                    : new Constructor(value.length);\\n                cache.set(value, clone);\\n                value.copy(clone);\\n                return clone;\\n            }\\n            // arraybuffers / dataviews\\n            if (realm.ArrayBuffer) {\\n                // dataviews\\n                if (realm.ArrayBuffer.isView(value)) {\\n                    clone = new Constructor(value.buffer.slice(0));\\n                    cache.set(value, clone);\\n                    return clone;\\n                }\\n                // arraybuffers\\n                if (value instanceof realm.ArrayBuffer) {\\n                    clone = value.slice(0);\\n                    cache.set(value, clone);\\n                    return clone;\\n                }\\n            }\\n            // if the value cannot / should not be cloned, don't\\n            if (\\n            // promise-like\\n            typeof value.then === 'function' ||\\n                // errors\\n                value instanceof Error ||\\n                // weakmaps\\n                (realm.WeakMap && value instanceof realm.WeakMap) ||\\n                // weaksets\\n                (realm.WeakSet && value instanceof realm.WeakSet)) {\\n                return value;\\n            }\\n            // assume anything left is a custom constructor\\n            return getObjectClone(value, realm, handleCopy, cache);\\n        };\\n        return handleCopy(value, createCache());\\n    }\\n    // Adding reference to allow usage in CommonJS libraries compiled using TSC, which\\n    // expects there to be a default property on the exported value. See\\n    // [#37](https://github.com/planttheidea/fast-copy/issues/37) for details.\\n    copy.default = copy;\\n    /**\\n     * @function strictCopy\\n     *\\n     * @description\\n     * copy the value with `strict` option pre-applied\\n     *\\n     * @param value the value to copy\\n     * @param [options] the options for copying with\\n     * @param [options.realm] the realm (this) value the value is copied from\\n     * @returns the copied value\\n     */\\n    copy.strict = function strictCopy(value, options) {\\n        return copy(value, {\\n            isStrict: true,\\n            realm: options ? options.realm : void 0,\\n        });\\n    };\\n\\n    return copy;\\n\\n}));\\n//# sourceMappingURL=fast-copy.js.map\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/fast-copy/dist/fast-copy.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/function-bind/implementation.js\":\n/*!*******************************************************!*\\\n  !*** ../node_modules/function-bind/implementation.js ***!\n  \\*******************************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/* eslint no-invalid-this: 1 */\\n\\nvar ERROR_MESSAGE = 'Function.prototype.bind called on incompatible ';\\nvar slice = Array.prototype.slice;\\nvar toStr = Object.prototype.toString;\\nvar funcType = '[object Function]';\\n\\nmodule.exports = function bind(that) {\\n    var target = this;\\n    if (typeof target !== 'function' || toStr.call(target) !== funcType) {\\n        throw new TypeError(ERROR_MESSAGE + target);\\n    }\\n    var args = slice.call(arguments, 1);\\n\\n    var bound;\\n    var binder = function () {\\n        if (this instanceof bound) {\\n            var result = target.apply(\\n                this,\\n                args.concat(slice.call(arguments))\\n            );\\n            if (Object(result) === result) {\\n                return result;\\n            }\\n            return this;\\n        } else {\\n            return target.apply(\\n                that,\\n                args.concat(slice.call(arguments))\\n            );\\n        }\\n    };\\n\\n    var boundLength = Math.max(0, target.length - args.length);\\n    var boundArgs = [];\\n    for (var i = 0; i < boundLength; i++) {\\n        boundArgs.push('$' + i);\\n    }\\n\\n    bound = Function('binder', 'return function (' + boundArgs.join(',') + '){ return binder.apply(this,arguments); }')(binder);\\n\\n    if (target.prototype) {\\n        var Empty = function Empty() {};\\n        Empty.prototype = target.prototype;\\n        bound.prototype = new Empty();\\n        Empty.prototype = null;\\n    }\\n\\n    return bound;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/function-bind/implementation.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/function-bind/index.js\":\n/*!**********************************************!*\\\n  !*** ../node_modules/function-bind/index.js ***!\n  \\**********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar implementation = __webpack_require__(/*! ./implementation */ \\\"../node_modules/function-bind/implementation.js\\\");\\n\\nmodule.exports = Function.prototype.bind || implementation;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/function-bind/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/get-intrinsic/index.js\":\n/*!**********************************************!*\\\n  !*** ../node_modules/get-intrinsic/index.js ***!\n  \\**********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar undefined;\\n\\nvar $SyntaxError = SyntaxError;\\nvar $Function = Function;\\nvar $TypeError = TypeError;\\n\\n// eslint-disable-next-line consistent-return\\nvar getEvalledConstructor = function (expressionSyntax) {\\n\\ttry {\\n\\t\\treturn $Function('\\\"use strict\\\"; return (' + expressionSyntax + ').constructor;')();\\n\\t} catch (e) {}\\n};\\n\\nvar $gOPD = Object.getOwnPropertyDescriptor;\\nif ($gOPD) {\\n\\ttry {\\n\\t\\t$gOPD({}, '');\\n\\t} catch (e) {\\n\\t\\t$gOPD = null; // this is IE 8, which has a broken gOPD\\n\\t}\\n}\\n\\nvar throwTypeError = function () {\\n\\tthrow new $TypeError();\\n};\\nvar ThrowTypeError = $gOPD\\n\\t? (function () {\\n\\t\\ttry {\\n\\t\\t\\t// eslint-disable-next-line no-unused-expressions, no-caller, no-restricted-properties\\n\\t\\t\\targuments.callee; // IE 8 does not throw here\\n\\t\\t\\treturn throwTypeError;\\n\\t\\t} catch (calleeThrows) {\\n\\t\\t\\ttry {\\n\\t\\t\\t\\t// IE 8 throws on Object.getOwnPropertyDescriptor(arguments, '')\\n\\t\\t\\t\\treturn $gOPD(arguments, 'callee').get;\\n\\t\\t\\t} catch (gOPDthrows) {\\n\\t\\t\\t\\treturn throwTypeError;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}())\\n\\t: throwTypeError;\\n\\nvar hasSymbols = __webpack_require__(/*! has-symbols */ \\\"../node_modules/has-symbols/index.js\\\")();\\n\\nvar getProto = Object.getPrototypeOf || function (x) { return x.__proto__; }; // eslint-disable-line no-proto\\n\\nvar needsEval = {};\\n\\nvar TypedArray = typeof Uint8Array === 'undefined' ? undefined : getProto(Uint8Array);\\n\\nvar INTRINSICS = {\\n\\t'%AggregateError%': typeof AggregateError === 'undefined' ? undefined : AggregateError,\\n\\t'%Array%': Array,\\n\\t'%ArrayBuffer%': typeof ArrayBuffer === 'undefined' ? undefined : ArrayBuffer,\\n\\t'%ArrayIteratorPrototype%': hasSymbols ? getProto([][Symbol.iterator]()) : undefined,\\n\\t'%AsyncFromSyncIteratorPrototype%': undefined,\\n\\t'%AsyncFunction%': needsEval,\\n\\t'%AsyncGenerator%': needsEval,\\n\\t'%AsyncGeneratorFunction%': needsEval,\\n\\t'%AsyncIteratorPrototype%': needsEval,\\n\\t'%Atomics%': typeof Atomics === 'undefined' ? undefined : Atomics,\\n\\t'%BigInt%': typeof BigInt === 'undefined' ? undefined : BigInt,\\n\\t'%Boolean%': Boolean,\\n\\t'%DataView%': typeof DataView === 'undefined' ? undefined : DataView,\\n\\t'%Date%': Date,\\n\\t'%decodeURI%': decodeURI,\\n\\t'%decodeURIComponent%': decodeURIComponent,\\n\\t'%encodeURI%': encodeURI,\\n\\t'%encodeURIComponent%': encodeURIComponent,\\n\\t'%Error%': Error,\\n\\t'%eval%': eval, // eslint-disable-line no-eval\\n\\t'%EvalError%': EvalError,\\n\\t'%Float32Array%': typeof Float32Array === 'undefined' ? undefined : Float32Array,\\n\\t'%Float64Array%': typeof Float64Array === 'undefined' ? undefined : Float64Array,\\n\\t'%FinalizationRegistry%': typeof FinalizationRegistry === 'undefined' ? undefined : FinalizationRegistry,\\n\\t'%Function%': $Function,\\n\\t'%GeneratorFunction%': needsEval,\\n\\t'%Int8Array%': typeof Int8Array === 'undefined' ? undefined : Int8Array,\\n\\t'%Int16Array%': typeof Int16Array === 'undefined' ? undefined : Int16Array,\\n\\t'%Int32Array%': typeof Int32Array === 'undefined' ? undefined : Int32Array,\\n\\t'%isFinite%': isFinite,\\n\\t'%isNaN%': isNaN,\\n\\t'%IteratorPrototype%': hasSymbols ? getProto(getProto([][Symbol.iterator]())) : undefined,\\n\\t'%JSON%': typeof JSON === 'object' ? JSON : undefined,\\n\\t'%Map%': typeof Map === 'undefined' ? undefined : Map,\\n\\t'%MapIteratorPrototype%': typeof Map === 'undefined' || !hasSymbols ? undefined : getProto(new Map()[Symbol.iterator]()),\\n\\t'%Math%': Math,\\n\\t'%Number%': Number,\\n\\t'%Object%': Object,\\n\\t'%parseFloat%': parseFloat,\\n\\t'%parseInt%': parseInt,\\n\\t'%Promise%': typeof Promise === 'undefined' ? undefined : Promise,\\n\\t'%Proxy%': typeof Proxy === 'undefined' ? undefined : Proxy,\\n\\t'%RangeError%': RangeError,\\n\\t'%ReferenceError%': ReferenceError,\\n\\t'%Reflect%': typeof Reflect === 'undefined' ? undefined : Reflect,\\n\\t'%RegExp%': RegExp,\\n\\t'%Set%': typeof Set === 'undefined' ? undefined : Set,\\n\\t'%SetIteratorPrototype%': typeof Set === 'undefined' || !hasSymbols ? undefined : getProto(new Set()[Symbol.iterator]()),\\n\\t'%SharedArrayBuffer%': typeof SharedArrayBuffer === 'undefined' ? undefined : SharedArrayBuffer,\\n\\t'%String%': String,\\n\\t'%StringIteratorPrototype%': hasSymbols ? getProto(''[Symbol.iterator]()) : undefined,\\n\\t'%Symbol%': hasSymbols ? Symbol : undefined,\\n\\t'%SyntaxError%': $SyntaxError,\\n\\t'%ThrowTypeError%': ThrowTypeError,\\n\\t'%TypedArray%': TypedArray,\\n\\t'%TypeError%': $TypeError,\\n\\t'%Uint8Array%': typeof Uint8Array === 'undefined' ? undefined : Uint8Array,\\n\\t'%Uint8ClampedArray%': typeof Uint8ClampedArray === 'undefined' ? undefined : Uint8ClampedArray,\\n\\t'%Uint16Array%': typeof Uint16Array === 'undefined' ? undefined : Uint16Array,\\n\\t'%Uint32Array%': typeof Uint32Array === 'undefined' ? undefined : Uint32Array,\\n\\t'%URIError%': URIError,\\n\\t'%WeakMap%': typeof WeakMap === 'undefined' ? undefined : WeakMap,\\n\\t'%WeakRef%': typeof WeakRef === 'undefined' ? undefined : WeakRef,\\n\\t'%WeakSet%': typeof WeakSet === 'undefined' ? undefined : WeakSet\\n};\\n\\nvar doEval = function doEval(name) {\\n\\tvar value;\\n\\tif (name === '%AsyncFunction%') {\\n\\t\\tvalue = getEvalledConstructor('async function () {}');\\n\\t} else if (name === '%GeneratorFunction%') {\\n\\t\\tvalue = getEvalledConstructor('function* () {}');\\n\\t} else if (name === '%AsyncGeneratorFunction%') {\\n\\t\\tvalue = getEvalledConstructor('async function* () {}');\\n\\t} else if (name === '%AsyncGenerator%') {\\n\\t\\tvar fn = doEval('%AsyncGeneratorFunction%');\\n\\t\\tif (fn) {\\n\\t\\t\\tvalue = fn.prototype;\\n\\t\\t}\\n\\t} else if (name === '%AsyncIteratorPrototype%') {\\n\\t\\tvar gen = doEval('%AsyncGenerator%');\\n\\t\\tif (gen) {\\n\\t\\t\\tvalue = getProto(gen.prototype);\\n\\t\\t}\\n\\t}\\n\\n\\tINTRINSICS[name] = value;\\n\\n\\treturn value;\\n};\\n\\nvar LEGACY_ALIASES = {\\n\\t'%ArrayBufferPrototype%': ['ArrayBuffer', 'prototype'],\\n\\t'%ArrayPrototype%': ['Array', 'prototype'],\\n\\t'%ArrayProto_entries%': ['Array', 'prototype', 'entries'],\\n\\t'%ArrayProto_forEach%': ['Array', 'prototype', 'forEach'],\\n\\t'%ArrayProto_keys%': ['Array', 'prototype', 'keys'],\\n\\t'%ArrayProto_values%': ['Array', 'prototype', 'values'],\\n\\t'%AsyncFunctionPrototype%': ['AsyncFunction', 'prototype'],\\n\\t'%AsyncGenerator%': ['AsyncGeneratorFunction', 'prototype'],\\n\\t'%AsyncGeneratorPrototype%': ['AsyncGeneratorFunction', 'prototype', 'prototype'],\\n\\t'%BooleanPrototype%': ['Boolean', 'prototype'],\\n\\t'%DataViewPrototype%': ['DataView', 'prototype'],\\n\\t'%DatePrototype%': ['Date', 'prototype'],\\n\\t'%ErrorPrototype%': ['Error', 'prototype'],\\n\\t'%EvalErrorPrototype%': ['EvalError', 'prototype'],\\n\\t'%Float32ArrayPrototype%': ['Float32Array', 'prototype'],\\n\\t'%Float64ArrayPrototype%': ['Float64Array', 'prototype'],\\n\\t'%FunctionPrototype%': ['Function', 'prototype'],\\n\\t'%Generator%': ['GeneratorFunction', 'prototype'],\\n\\t'%GeneratorPrototype%': ['GeneratorFunction', 'prototype', 'prototype'],\\n\\t'%Int8ArrayPrototype%': ['Int8Array', 'prototype'],\\n\\t'%Int16ArrayPrototype%': ['Int16Array', 'prototype'],\\n\\t'%Int32ArrayPrototype%': ['Int32Array', 'prototype'],\\n\\t'%JSONParse%': ['JSON', 'parse'],\\n\\t'%JSONStringify%': ['JSON', 'stringify'],\\n\\t'%MapPrototype%': ['Map', 'prototype'],\\n\\t'%NumberPrototype%': ['Number', 'prototype'],\\n\\t'%ObjectPrototype%': ['Object', 'prototype'],\\n\\t'%ObjProto_toString%': ['Object', 'prototype', 'toString'],\\n\\t'%ObjProto_valueOf%': ['Object', 'prototype', 'valueOf'],\\n\\t'%PromisePrototype%': ['Promise', 'prototype'],\\n\\t'%PromiseProto_then%': ['Promise', 'prototype', 'then'],\\n\\t'%Promise_all%': ['Promise', 'all'],\\n\\t'%Promise_reject%': ['Promise', 'reject'],\\n\\t'%Promise_resolve%': ['Promise', 'resolve'],\\n\\t'%RangeErrorPrototype%': ['RangeError', 'prototype'],\\n\\t'%ReferenceErrorPrototype%': ['ReferenceError', 'prototype'],\\n\\t'%RegExpPrototype%': ['RegExp', 'prototype'],\\n\\t'%SetPrototype%': ['Set', 'prototype'],\\n\\t'%SharedArrayBufferPrototype%': ['SharedArrayBuffer', 'prototype'],\\n\\t'%StringPrototype%': ['String', 'prototype'],\\n\\t'%SymbolPrototype%': ['Symbol', 'prototype'],\\n\\t'%SyntaxErrorPrototype%': ['SyntaxError', 'prototype'],\\n\\t'%TypedArrayPrototype%': ['TypedArray', 'prototype'],\\n\\t'%TypeErrorPrototype%': ['TypeError', 'prototype'],\\n\\t'%Uint8ArrayPrototype%': ['Uint8Array', 'prototype'],\\n\\t'%Uint8ClampedArrayPrototype%': ['Uint8ClampedArray', 'prototype'],\\n\\t'%Uint16ArrayPrototype%': ['Uint16Array', 'prototype'],\\n\\t'%Uint32ArrayPrototype%': ['Uint32Array', 'prototype'],\\n\\t'%URIErrorPrototype%': ['URIError', 'prototype'],\\n\\t'%WeakMapPrototype%': ['WeakMap', 'prototype'],\\n\\t'%WeakSetPrototype%': ['WeakSet', 'prototype']\\n};\\n\\nvar bind = __webpack_require__(/*! function-bind */ \\\"../node_modules/function-bind/index.js\\\");\\nvar hasOwn = __webpack_require__(/*! has */ \\\"../node_modules/has/src/index.js\\\");\\nvar $concat = bind.call(Function.call, Array.prototype.concat);\\nvar $spliceApply = bind.call(Function.apply, Array.prototype.splice);\\nvar $replace = bind.call(Function.call, String.prototype.replace);\\nvar $strSlice = bind.call(Function.call, String.prototype.slice);\\nvar $exec = bind.call(Function.call, RegExp.prototype.exec);\\n\\n/* adapted from https://github.com/lodash/lodash/blob/4.17.15/dist/lodash.js#L6735-L6744 */\\nvar rePropName = /[^%.[\\\\]]+|\\\\[(?:(-?\\\\d+(?:\\\\.\\\\d+)?)|([\\\"'])((?:(?!\\\\2)[^\\\\\\\\]|\\\\\\\\.)*?)\\\\2)\\\\]|(?=(?:\\\\.|\\\\[\\\\])(?:\\\\.|\\\\[\\\\]|%$))/g;\\nvar reEscapeChar = /\\\\\\\\(\\\\\\\\)?/g; /** Used to match backslashes in property paths. */\\nvar stringToPath = function stringToPath(string) {\\n\\tvar first = $strSlice(string, 0, 1);\\n\\tvar last = $strSlice(string, -1);\\n\\tif (first === '%' && last !== '%') {\\n\\t\\tthrow new $SyntaxError('invalid intrinsic syntax, expected closing `%`');\\n\\t} else if (last === '%' && first !== '%') {\\n\\t\\tthrow new $SyntaxError('invalid intrinsic syntax, expected opening `%`');\\n\\t}\\n\\tvar result = [];\\n\\t$replace(string, rePropName, function (match, number, quote, subString) {\\n\\t\\tresult[result.length] = quote ? $replace(subString, reEscapeChar, '$1') : number || match;\\n\\t});\\n\\treturn result;\\n};\\n/* end adaptation */\\n\\nvar getBaseIntrinsic = function getBaseIntrinsic(name, allowMissing) {\\n\\tvar intrinsicName = name;\\n\\tvar alias;\\n\\tif (hasOwn(LEGACY_ALIASES, intrinsicName)) {\\n\\t\\talias = LEGACY_ALIASES[intrinsicName];\\n\\t\\tintrinsicName = '%' + alias[0] + '%';\\n\\t}\\n\\n\\tif (hasOwn(INTRINSICS, intrinsicName)) {\\n\\t\\tvar value = INTRINSICS[intrinsicName];\\n\\t\\tif (value === needsEval) {\\n\\t\\t\\tvalue = doEval(intrinsicName);\\n\\t\\t}\\n\\t\\tif (typeof value === 'undefined' && !allowMissing) {\\n\\t\\t\\tthrow new $TypeError('intrinsic ' + name + ' exists, but is not available. Please file an issue!');\\n\\t\\t}\\n\\n\\t\\treturn {\\n\\t\\t\\talias: alias,\\n\\t\\t\\tname: intrinsicName,\\n\\t\\t\\tvalue: value\\n\\t\\t};\\n\\t}\\n\\n\\tthrow new $SyntaxError('intrinsic ' + name + ' does not exist!');\\n};\\n\\nmodule.exports = function GetIntrinsic(name, allowMissing) {\\n\\tif (typeof name !== 'string' || name.length === 0) {\\n\\t\\tthrow new $TypeError('intrinsic name must be a non-empty string');\\n\\t}\\n\\tif (arguments.length > 1 && typeof allowMissing !== 'boolean') {\\n\\t\\tthrow new $TypeError('\\\"allowMissing\\\" argument must be a boolean');\\n\\t}\\n\\n\\tif ($exec(/^%?[^%]*%?$/, name) === null) {\\n\\t\\tthrow new $SyntaxError('`%` may not be present anywhere but at the beginning and end of the intrinsic name');\\n\\t}\\n\\tvar parts = stringToPath(name);\\n\\tvar intrinsicBaseName = parts.length > 0 ? parts[0] : '';\\n\\n\\tvar intrinsic = getBaseIntrinsic('%' + intrinsicBaseName + '%', allowMissing);\\n\\tvar intrinsicRealName = intrinsic.name;\\n\\tvar value = intrinsic.value;\\n\\tvar skipFurtherCaching = false;\\n\\n\\tvar alias = intrinsic.alias;\\n\\tif (alias) {\\n\\t\\tintrinsicBaseName = alias[0];\\n\\t\\t$spliceApply(parts, $concat([0, 1], alias));\\n\\t}\\n\\n\\tfor (var i = 1, isOwn = true; i < parts.length; i += 1) {\\n\\t\\tvar part = parts[i];\\n\\t\\tvar first = $strSlice(part, 0, 1);\\n\\t\\tvar last = $strSlice(part, -1);\\n\\t\\tif (\\n\\t\\t\\t(\\n\\t\\t\\t\\t(first === '\\\"' || first === \\\"'\\\" || first === '`')\\n\\t\\t\\t\\t|| (last === '\\\"' || last === \\\"'\\\" || last === '`')\\n\\t\\t\\t)\\n\\t\\t\\t&& first !== last\\n\\t\\t) {\\n\\t\\t\\tthrow new $SyntaxError('property names with quotes must have matching quotes');\\n\\t\\t}\\n\\t\\tif (part === 'constructor' || !isOwn) {\\n\\t\\t\\tskipFurtherCaching = true;\\n\\t\\t}\\n\\n\\t\\tintrinsicBaseName += '.' + part;\\n\\t\\tintrinsicRealName = '%' + intrinsicBaseName + '%';\\n\\n\\t\\tif (hasOwn(INTRINSICS, intrinsicRealName)) {\\n\\t\\t\\tvalue = INTRINSICS[intrinsicRealName];\\n\\t\\t} else if (value != null) {\\n\\t\\t\\tif (!(part in value)) {\\n\\t\\t\\t\\tif (!allowMissing) {\\n\\t\\t\\t\\t\\tthrow new $TypeError('base intrinsic for ' + name + ' exists, but the property is not available.');\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\treturn void undefined;\\n\\t\\t\\t}\\n\\t\\t\\tif ($gOPD && (i + 1) >= parts.length) {\\n\\t\\t\\t\\tvar desc = $gOPD(value, part);\\n\\t\\t\\t\\tisOwn = !!desc;\\n\\n\\t\\t\\t\\t// By convention, when a data property is converted to an accessor\\n\\t\\t\\t\\t// property to emulate a data property that does not suffer from\\n\\t\\t\\t\\t// the override mistake, that accessor's getter is marked with\\n\\t\\t\\t\\t// an `originalValue` property. Here, when we detect this, we\\n\\t\\t\\t\\t// uphold the illusion by pretending to see that original data\\n\\t\\t\\t\\t// property, i.e., returning the value rather than the getter\\n\\t\\t\\t\\t// itself.\\n\\t\\t\\t\\tif (isOwn && 'get' in desc && !('originalValue' in desc.get)) {\\n\\t\\t\\t\\t\\tvalue = desc.get;\\n\\t\\t\\t\\t} else {\\n\\t\\t\\t\\t\\tvalue = value[part];\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tisOwn = hasOwn(value, part);\\n\\t\\t\\t\\tvalue = value[part];\\n\\t\\t\\t}\\n\\n\\t\\t\\tif (isOwn && !skipFurtherCaching) {\\n\\t\\t\\t\\tINTRINSICS[intrinsicRealName] = value;\\n\\t\\t\\t}\\n\\t\\t}\\n\\t}\\n\\treturn value;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/get-intrinsic/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/has-symbols/index.js\":\n/*!********************************************!*\\\n  !*** ../node_modules/has-symbols/index.js ***!\n  \\********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar origSymbol = typeof Symbol !== 'undefined' && Symbol;\\nvar hasSymbolSham = __webpack_require__(/*! ./shams */ \\\"../node_modules/has-symbols/shams.js\\\");\\n\\nmodule.exports = function hasNativeSymbols() {\\n\\tif (typeof origSymbol !== 'function') { return false; }\\n\\tif (typeof Symbol !== 'function') { return false; }\\n\\tif (typeof origSymbol('foo') !== 'symbol') { return false; }\\n\\tif (typeof Symbol('bar') !== 'symbol') { return false; }\\n\\n\\treturn hasSymbolSham();\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/has-symbols/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/has-symbols/shams.js\":\n/*!********************************************!*\\\n  !*** ../node_modules/has-symbols/shams.js ***!\n  \\********************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\n/* eslint complexity: [2, 18], max-statements: [2, 33] */\\nmodule.exports = function hasSymbols() {\\n\\tif (typeof Symbol !== 'function' || typeof Object.getOwnPropertySymbols !== 'function') { return false; }\\n\\tif (typeof Symbol.iterator === 'symbol') { return true; }\\n\\n\\tvar obj = {};\\n\\tvar sym = Symbol('test');\\n\\tvar symObj = Object(sym);\\n\\tif (typeof sym === 'string') { return false; }\\n\\n\\tif (Object.prototype.toString.call(sym) !== '[object Symbol]') { return false; }\\n\\tif (Object.prototype.toString.call(symObj) !== '[object Symbol]') { return false; }\\n\\n\\t// temp disabled per https://github.com/ljharb/object.assign/issues/17\\n\\t// if (sym instanceof Symbol) { return false; }\\n\\t// temp disabled per https://github.com/WebReflection/get-own-property-symbols/issues/4\\n\\t// if (!(symObj instanceof Symbol)) { return false; }\\n\\n\\t// if (typeof Symbol.prototype.toString !== 'function') { return false; }\\n\\t// if (String(sym) !== Symbol.prototype.toString.call(sym)) { return false; }\\n\\n\\tvar symVal = 42;\\n\\tobj[sym] = symVal;\\n\\tfor (sym in obj) { return false; } // eslint-disable-line no-restricted-syntax, no-unreachable-loop\\n\\tif (typeof Object.keys === 'function' && Object.keys(obj).length !== 0) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyNames === 'function' && Object.getOwnPropertyNames(obj).length !== 0) { return false; }\\n\\n\\tvar syms = Object.getOwnPropertySymbols(obj);\\n\\tif (syms.length !== 1 || syms[0] !== sym) { return false; }\\n\\n\\tif (!Object.prototype.propertyIsEnumerable.call(obj, sym)) { return false; }\\n\\n\\tif (typeof Object.getOwnPropertyDescriptor === 'function') {\\n\\t\\tvar descriptor = Object.getOwnPropertyDescriptor(obj, sym);\\n\\t\\tif (descriptor.value !== symVal || descriptor.enumerable !== true) { return false; }\\n\\t}\\n\\n\\treturn true;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/has-symbols/shams.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/has/src/index.js\":\n/*!****************************************!*\\\n  !*** ../node_modules/has/src/index.js ***!\n  \\****************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar bind = __webpack_require__(/*! function-bind */ \\\"../node_modules/function-bind/index.js\\\");\\n\\nmodule.exports = bind.call(Function.call, Object.prototype.hasOwnProperty);\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/has/src/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/json-stringify-safe/stringify.js\":\n/*!********************************************************!*\\\n  !*** ../node_modules/json-stringify-safe/stringify.js ***!\n  \\********************************************************/\n/***/ ((module, exports) => {\n\neval(\"exports = module.exports = stringify\\nexports.getSerialize = serializer\\n\\nfunction stringify(obj, replacer, spaces, cycleReplacer) {\\n  return JSON.stringify(obj, serializer(replacer, cycleReplacer), spaces)\\n}\\n\\nfunction serializer(replacer, cycleReplacer) {\\n  var stack = [], keys = []\\n\\n  if (cycleReplacer == null) cycleReplacer = function(key, value) {\\n    if (stack[0] === value) return \\\"[Circular ~]\\\"\\n    return \\\"[Circular ~.\\\" + keys.slice(0, stack.indexOf(value)).join(\\\".\\\") + \\\"]\\\"\\n  }\\n\\n  return function(key, value) {\\n    if (stack.length > 0) {\\n      var thisPos = stack.indexOf(this)\\n      ~thisPos ? stack.splice(thisPos + 1) : stack.push(this)\\n      ~thisPos ? keys.splice(thisPos, Infinity, key) : keys.push(key)\\n      if (~stack.indexOf(value)) value = cycleReplacer.call(this, key, value)\\n    }\\n    else stack.push(value)\\n\\n    return replacer == null ? value : replacer.call(this, key, value)\\n  }\\n}\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/json-stringify-safe/stringify.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/lodash.isplainobject/index.js\":\n/*!*****************************************************!*\\\n  !*** ../node_modules/lodash.isplainobject/index.js ***!\n  \\*****************************************************/\n/***/ ((module) => {\n\neval(\"/**\\n * lodash (Custom Build) <https://lodash.com/>\\n * Build: `lodash modularize exports=\\\"npm\\\" -o ./`\\n * Copyright jQuery Foundation and other contributors <https://jquery.org/>\\n * Released under MIT license <https://lodash.com/license>\\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\\n * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\\n */\\n\\n/** `Object#toString` result references. */\\nvar objectTag = '[object Object]';\\n\\n/**\\n * Checks if `value` is a host object in IE < 9.\\n *\\n * @private\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a host object, else `false`.\\n */\\nfunction isHostObject(value) {\\n  // Many host objects are `Object` objects that can coerce to strings\\n  // despite having improperly defined `toString` methods.\\n  var result = false;\\n  if (value != null && typeof value.toString != 'function') {\\n    try {\\n      result = !!(value + '');\\n    } catch (e) {}\\n  }\\n  return result;\\n}\\n\\n/**\\n * Creates a unary function that invokes `func` with its argument transformed.\\n *\\n * @private\\n * @param {Function} func The function to wrap.\\n * @param {Function} transform The argument transform.\\n * @returns {Function} Returns the new function.\\n */\\nfunction overArg(func, transform) {\\n  return function(arg) {\\n    return func(transform(arg));\\n  };\\n}\\n\\n/** Used for built-in method references. */\\nvar funcProto = Function.prototype,\\n    objectProto = Object.prototype;\\n\\n/** Used to resolve the decompiled source of functions. */\\nvar funcToString = funcProto.toString;\\n\\n/** Used to check objects for own properties. */\\nvar hasOwnProperty = objectProto.hasOwnProperty;\\n\\n/** Used to infer the `Object` constructor. */\\nvar objectCtorString = funcToString.call(Object);\\n\\n/**\\n * Used to resolve the\\n * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objectToString = objectProto.toString;\\n\\n/** Built-in value references. */\\nvar getPrototype = overArg(Object.getPrototypeOf, Object);\\n\\n/**\\n * Checks if `value` is object-like. A value is object-like if it's not `null`\\n * and has a `typeof` result of \\\"object\\\".\\n *\\n * @static\\n * @memberOf _\\n * @since 4.0.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n * @example\\n *\\n * _.isObjectLike({});\\n * // => true\\n *\\n * _.isObjectLike([1, 2, 3]);\\n * // => true\\n *\\n * _.isObjectLike(_.noop);\\n * // => false\\n *\\n * _.isObjectLike(null);\\n * // => false\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\n/**\\n * Checks if `value` is a plain object, that is, an object created by the\\n * `Object` constructor or one with a `[[Prototype]]` of `null`.\\n *\\n * @static\\n * @memberOf _\\n * @since 0.8.0\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.\\n * @example\\n *\\n * function Foo() {\\n *   this.a = 1;\\n * }\\n *\\n * _.isPlainObject(new Foo);\\n * // => false\\n *\\n * _.isPlainObject([1, 2, 3]);\\n * // => false\\n *\\n * _.isPlainObject({ 'x': 0, 'y': 0 });\\n * // => true\\n *\\n * _.isPlainObject(Object.create(null));\\n * // => true\\n */\\nfunction isPlainObject(value) {\\n  if (!isObjectLike(value) ||\\n      objectToString.call(value) != objectTag || isHostObject(value)) {\\n    return false;\\n  }\\n  var proto = getPrototype(value);\\n  if (proto === null) {\\n    return true;\\n  }\\n  var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;\\n  return (typeof Ctor == 'function' &&\\n    Ctor instanceof Ctor && funcToString.call(Ctor) == objectCtorString);\\n}\\n\\nmodule.exports = isPlainObject;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/lodash.isplainobject/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/lodash.isstring/index.js\":\n/*!************************************************!*\\\n  !*** ../node_modules/lodash.isstring/index.js ***!\n  \\************************************************/\n/***/ ((module) => {\n\neval(\"/**\\n * lodash 4.0.1 (Custom Build) <https://lodash.com/>\\n * Build: `lodash modularize exports=\\\"npm\\\" -o ./`\\n * Copyright 2012-2016 The Dojo Foundation <http://dojofoundation.org/>\\n * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>\\n * Copyright 2009-2016 Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors\\n * Available under MIT license <https://lodash.com/license>\\n */\\n\\n/** `Object#toString` result references. */\\nvar stringTag = '[object String]';\\n\\n/** Used for built-in method references. */\\nvar objectProto = Object.prototype;\\n\\n/**\\n * Used to resolve the [`toStringTag`](http://ecma-international.org/ecma-262/6.0/#sec-object.prototype.tostring)\\n * of values.\\n */\\nvar objectToString = objectProto.toString;\\n\\n/**\\n * Checks if `value` is classified as an `Array` object.\\n *\\n * @static\\n * @memberOf _\\n * @type Function\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isArray([1, 2, 3]);\\n * // => true\\n *\\n * _.isArray(document.body.children);\\n * // => false\\n *\\n * _.isArray('abc');\\n * // => false\\n *\\n * _.isArray(_.noop);\\n * // => false\\n */\\nvar isArray = Array.isArray;\\n\\n/**\\n * Checks if `value` is object-like. A value is object-like if it's not `null`\\n * and has a `typeof` result of \\\"object\\\".\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is object-like, else `false`.\\n * @example\\n *\\n * _.isObjectLike({});\\n * // => true\\n *\\n * _.isObjectLike([1, 2, 3]);\\n * // => true\\n *\\n * _.isObjectLike(_.noop);\\n * // => false\\n *\\n * _.isObjectLike(null);\\n * // => false\\n */\\nfunction isObjectLike(value) {\\n  return !!value && typeof value == 'object';\\n}\\n\\n/**\\n * Checks if `value` is classified as a `String` primitive or object.\\n *\\n * @static\\n * @memberOf _\\n * @category Lang\\n * @param {*} value The value to check.\\n * @returns {boolean} Returns `true` if `value` is correctly classified, else `false`.\\n * @example\\n *\\n * _.isString('abc');\\n * // => true\\n *\\n * _.isString(1);\\n * // => false\\n */\\nfunction isString(value) {\\n  return typeof value == 'string' ||\\n    (!isArray(value) && isObjectLike(value) && objectToString.call(value) == stringTag);\\n}\\n\\nmodule.exports = isString;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/lodash.isstring/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/object-inspect/index.js\":\n/*!***********************************************!*\\\n  !*** ../node_modules/object-inspect/index.js ***!\n  \\***********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\neval(\"var hasMap = typeof Map === 'function' && Map.prototype;\\nvar mapSizeDescriptor = Object.getOwnPropertyDescriptor && hasMap ? Object.getOwnPropertyDescriptor(Map.prototype, 'size') : null;\\nvar mapSize = hasMap && mapSizeDescriptor && typeof mapSizeDescriptor.get === 'function' ? mapSizeDescriptor.get : null;\\nvar mapForEach = hasMap && Map.prototype.forEach;\\nvar hasSet = typeof Set === 'function' && Set.prototype;\\nvar setSizeDescriptor = Object.getOwnPropertyDescriptor && hasSet ? Object.getOwnPropertyDescriptor(Set.prototype, 'size') : null;\\nvar setSize = hasSet && setSizeDescriptor && typeof setSizeDescriptor.get === 'function' ? setSizeDescriptor.get : null;\\nvar setForEach = hasSet && Set.prototype.forEach;\\nvar hasWeakMap = typeof WeakMap === 'function' && WeakMap.prototype;\\nvar weakMapHas = hasWeakMap ? WeakMap.prototype.has : null;\\nvar hasWeakSet = typeof WeakSet === 'function' && WeakSet.prototype;\\nvar weakSetHas = hasWeakSet ? WeakSet.prototype.has : null;\\nvar hasWeakRef = typeof WeakRef === 'function' && WeakRef.prototype;\\nvar weakRefDeref = hasWeakRef ? WeakRef.prototype.deref : null;\\nvar booleanValueOf = Boolean.prototype.valueOf;\\nvar objectToString = Object.prototype.toString;\\nvar functionToString = Function.prototype.toString;\\nvar $match = String.prototype.match;\\nvar $slice = String.prototype.slice;\\nvar $replace = String.prototype.replace;\\nvar $toUpperCase = String.prototype.toUpperCase;\\nvar $toLowerCase = String.prototype.toLowerCase;\\nvar $test = RegExp.prototype.test;\\nvar $concat = Array.prototype.concat;\\nvar $join = Array.prototype.join;\\nvar $arrSlice = Array.prototype.slice;\\nvar $floor = Math.floor;\\nvar bigIntValueOf = typeof BigInt === 'function' ? BigInt.prototype.valueOf : null;\\nvar gOPS = Object.getOwnPropertySymbols;\\nvar symToString = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ? Symbol.prototype.toString : null;\\nvar hasShammedSymbols = typeof Symbol === 'function' && typeof Symbol.iterator === 'object';\\n// ie, `has-tostringtag/shams\\nvar toStringTag = typeof Symbol === 'function' && Symbol.toStringTag && (typeof Symbol.toStringTag === hasShammedSymbols ? 'object' : 'symbol')\\n    ? Symbol.toStringTag\\n    : null;\\nvar isEnumerable = Object.prototype.propertyIsEnumerable;\\n\\nvar gPO = (typeof Reflect === 'function' ? Reflect.getPrototypeOf : Object.getPrototypeOf) || (\\n    [].__proto__ === Array.prototype // eslint-disable-line no-proto\\n        ? function (O) {\\n            return O.__proto__; // eslint-disable-line no-proto\\n        }\\n        : null\\n);\\n\\nfunction addNumericSeparator(num, str) {\\n    if (\\n        num === Infinity\\n        || num === -Infinity\\n        || num !== num\\n        || (num && num > -1000 && num < 1000)\\n        || $test.call(/e/, str)\\n    ) {\\n        return str;\\n    }\\n    var sepRegex = /[0-9](?=(?:[0-9]{3})+(?![0-9]))/g;\\n    if (typeof num === 'number') {\\n        var int = num < 0 ? -$floor(-num) : $floor(num); // trunc(num)\\n        if (int !== num) {\\n            var intStr = String(int);\\n            var dec = $slice.call(str, intStr.length + 1);\\n            return $replace.call(intStr, sepRegex, '$&_') + '.' + $replace.call($replace.call(dec, /([0-9]{3})/g, '$&_'), /_$/, '');\\n        }\\n    }\\n    return $replace.call(str, sepRegex, '$&_');\\n}\\n\\nvar utilInspect = __webpack_require__(/*! ./util.inspect */ \\\"?d91c\\\");\\nvar inspectCustom = utilInspect.custom;\\nvar inspectSymbol = isSymbol(inspectCustom) ? inspectCustom : null;\\n\\nmodule.exports = function inspect_(obj, options, depth, seen) {\\n    var opts = options || {};\\n\\n    if (has(opts, 'quoteStyle') && (opts.quoteStyle !== 'single' && opts.quoteStyle !== 'double')) {\\n        throw new TypeError('option \\\"quoteStyle\\\" must be \\\"single\\\" or \\\"double\\\"');\\n    }\\n    if (\\n        has(opts, 'maxStringLength') && (typeof opts.maxStringLength === 'number'\\n            ? opts.maxStringLength < 0 && opts.maxStringLength !== Infinity\\n            : opts.maxStringLength !== null\\n        )\\n    ) {\\n        throw new TypeError('option \\\"maxStringLength\\\", if provided, must be a positive integer, Infinity, or `null`');\\n    }\\n    var customInspect = has(opts, 'customInspect') ? opts.customInspect : true;\\n    if (typeof customInspect !== 'boolean' && customInspect !== 'symbol') {\\n        throw new TypeError('option \\\"customInspect\\\", if provided, must be `true`, `false`, or `\\\\'symbol\\\\'`');\\n    }\\n\\n    if (\\n        has(opts, 'indent')\\n        && opts.indent !== null\\n        && opts.indent !== '\\\\t'\\n        && !(parseInt(opts.indent, 10) === opts.indent && opts.indent > 0)\\n    ) {\\n        throw new TypeError('option \\\"indent\\\" must be \\\"\\\\\\\\t\\\", an integer > 0, or `null`');\\n    }\\n    if (has(opts, 'numericSeparator') && typeof opts.numericSeparator !== 'boolean') {\\n        throw new TypeError('option \\\"numericSeparator\\\", if provided, must be `true` or `false`');\\n    }\\n    var numericSeparator = opts.numericSeparator;\\n\\n    if (typeof obj === 'undefined') {\\n        return 'undefined';\\n    }\\n    if (obj === null) {\\n        return 'null';\\n    }\\n    if (typeof obj === 'boolean') {\\n        return obj ? 'true' : 'false';\\n    }\\n\\n    if (typeof obj === 'string') {\\n        return inspectString(obj, opts);\\n    }\\n    if (typeof obj === 'number') {\\n        if (obj === 0) {\\n            return Infinity / obj > 0 ? '0' : '-0';\\n        }\\n        var str = String(obj);\\n        return numericSeparator ? addNumericSeparator(obj, str) : str;\\n    }\\n    if (typeof obj === 'bigint') {\\n        var bigIntStr = String(obj) + 'n';\\n        return numericSeparator ? addNumericSeparator(obj, bigIntStr) : bigIntStr;\\n    }\\n\\n    var maxDepth = typeof opts.depth === 'undefined' ? 5 : opts.depth;\\n    if (typeof depth === 'undefined') { depth = 0; }\\n    if (depth >= maxDepth && maxDepth > 0 && typeof obj === 'object') {\\n        return isArray(obj) ? '[Array]' : '[Object]';\\n    }\\n\\n    var indent = getIndent(opts, depth);\\n\\n    if (typeof seen === 'undefined') {\\n        seen = [];\\n    } else if (indexOf(seen, obj) >= 0) {\\n        return '[Circular]';\\n    }\\n\\n    function inspect(value, from, noIndent) {\\n        if (from) {\\n            seen = $arrSlice.call(seen);\\n            seen.push(from);\\n        }\\n        if (noIndent) {\\n            var newOpts = {\\n                depth: opts.depth\\n            };\\n            if (has(opts, 'quoteStyle')) {\\n                newOpts.quoteStyle = opts.quoteStyle;\\n            }\\n            return inspect_(value, newOpts, depth + 1, seen);\\n        }\\n        return inspect_(value, opts, depth + 1, seen);\\n    }\\n\\n    if (typeof obj === 'function' && !isRegExp(obj)) { // in older engines, regexes are callable\\n        var name = nameOf(obj);\\n        var keys = arrObjKeys(obj, inspect);\\n        return '[Function' + (name ? ': ' + name : ' (anonymous)') + ']' + (keys.length > 0 ? ' { ' + $join.call(keys, ', ') + ' }' : '');\\n    }\\n    if (isSymbol(obj)) {\\n        var symString = hasShammedSymbols ? $replace.call(String(obj), /^(Symbol\\\\(.*\\\\))_[^)]*$/, '$1') : symToString.call(obj);\\n        return typeof obj === 'object' && !hasShammedSymbols ? markBoxed(symString) : symString;\\n    }\\n    if (isElement(obj)) {\\n        var s = '<' + $toLowerCase.call(String(obj.nodeName));\\n        var attrs = obj.attributes || [];\\n        for (var i = 0; i < attrs.length; i++) {\\n            s += ' ' + attrs[i].name + '=' + wrapQuotes(quote(attrs[i].value), 'double', opts);\\n        }\\n        s += '>';\\n        if (obj.childNodes && obj.childNodes.length) { s += '...'; }\\n        s += '</' + $toLowerCase.call(String(obj.nodeName)) + '>';\\n        return s;\\n    }\\n    if (isArray(obj)) {\\n        if (obj.length === 0) { return '[]'; }\\n        var xs = arrObjKeys(obj, inspect);\\n        if (indent && !singleLineValues(xs)) {\\n            return '[' + indentedJoin(xs, indent) + ']';\\n        }\\n        return '[ ' + $join.call(xs, ', ') + ' ]';\\n    }\\n    if (isError(obj)) {\\n        var parts = arrObjKeys(obj, inspect);\\n        if (!('cause' in Error.prototype) && 'cause' in obj && !isEnumerable.call(obj, 'cause')) {\\n            return '{ [' + String(obj) + '] ' + $join.call($concat.call('[cause]: ' + inspect(obj.cause), parts), ', ') + ' }';\\n        }\\n        if (parts.length === 0) { return '[' + String(obj) + ']'; }\\n        return '{ [' + String(obj) + '] ' + $join.call(parts, ', ') + ' }';\\n    }\\n    if (typeof obj === 'object' && customInspect) {\\n        if (inspectSymbol && typeof obj[inspectSymbol] === 'function' && utilInspect) {\\n            return utilInspect(obj, { depth: maxDepth - depth });\\n        } else if (customInspect !== 'symbol' && typeof obj.inspect === 'function') {\\n            return obj.inspect();\\n        }\\n    }\\n    if (isMap(obj)) {\\n        var mapParts = [];\\n        if (mapForEach) {\\n            mapForEach.call(obj, function (value, key) {\\n                mapParts.push(inspect(key, obj, true) + ' => ' + inspect(value, obj));\\n            });\\n        }\\n        return collectionOf('Map', mapSize.call(obj), mapParts, indent);\\n    }\\n    if (isSet(obj)) {\\n        var setParts = [];\\n        if (setForEach) {\\n            setForEach.call(obj, function (value) {\\n                setParts.push(inspect(value, obj));\\n            });\\n        }\\n        return collectionOf('Set', setSize.call(obj), setParts, indent);\\n    }\\n    if (isWeakMap(obj)) {\\n        return weakCollectionOf('WeakMap');\\n    }\\n    if (isWeakSet(obj)) {\\n        return weakCollectionOf('WeakSet');\\n    }\\n    if (isWeakRef(obj)) {\\n        return weakCollectionOf('WeakRef');\\n    }\\n    if (isNumber(obj)) {\\n        return markBoxed(inspect(Number(obj)));\\n    }\\n    if (isBigInt(obj)) {\\n        return markBoxed(inspect(bigIntValueOf.call(obj)));\\n    }\\n    if (isBoolean(obj)) {\\n        return markBoxed(booleanValueOf.call(obj));\\n    }\\n    if (isString(obj)) {\\n        return markBoxed(inspect(String(obj)));\\n    }\\n    if (!isDate(obj) && !isRegExp(obj)) {\\n        var ys = arrObjKeys(obj, inspect);\\n        var isPlainObject = gPO ? gPO(obj) === Object.prototype : obj instanceof Object || obj.constructor === Object;\\n        var protoTag = obj instanceof Object ? '' : 'null prototype';\\n        var stringTag = !isPlainObject && toStringTag && Object(obj) === obj && toStringTag in obj ? $slice.call(toStr(obj), 8, -1) : protoTag ? 'Object' : '';\\n        var constructorTag = isPlainObject || typeof obj.constructor !== 'function' ? '' : obj.constructor.name ? obj.constructor.name + ' ' : '';\\n        var tag = constructorTag + (stringTag || protoTag ? '[' + $join.call($concat.call([], stringTag || [], protoTag || []), ': ') + '] ' : '');\\n        if (ys.length === 0) { return tag + '{}'; }\\n        if (indent) {\\n            return tag + '{' + indentedJoin(ys, indent) + '}';\\n        }\\n        return tag + '{ ' + $join.call(ys, ', ') + ' }';\\n    }\\n    return String(obj);\\n};\\n\\nfunction wrapQuotes(s, defaultStyle, opts) {\\n    var quoteChar = (opts.quoteStyle || defaultStyle) === 'double' ? '\\\"' : \\\"'\\\";\\n    return quoteChar + s + quoteChar;\\n}\\n\\nfunction quote(s) {\\n    return $replace.call(String(s), /\\\"/g, '&quot;');\\n}\\n\\nfunction isArray(obj) { return toStr(obj) === '[object Array]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isDate(obj) { return toStr(obj) === '[object Date]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isRegExp(obj) { return toStr(obj) === '[object RegExp]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isError(obj) { return toStr(obj) === '[object Error]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isString(obj) { return toStr(obj) === '[object String]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isNumber(obj) { return toStr(obj) === '[object Number]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\nfunction isBoolean(obj) { return toStr(obj) === '[object Boolean]' && (!toStringTag || !(typeof obj === 'object' && toStringTag in obj)); }\\n\\n// Symbol and BigInt do have Symbol.toStringTag by spec, so that can't be used to eliminate false positives\\nfunction isSymbol(obj) {\\n    if (hasShammedSymbols) {\\n        return obj && typeof obj === 'object' && obj instanceof Symbol;\\n    }\\n    if (typeof obj === 'symbol') {\\n        return true;\\n    }\\n    if (!obj || typeof obj !== 'object' || !symToString) {\\n        return false;\\n    }\\n    try {\\n        symToString.call(obj);\\n        return true;\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isBigInt(obj) {\\n    if (!obj || typeof obj !== 'object' || !bigIntValueOf) {\\n        return false;\\n    }\\n    try {\\n        bigIntValueOf.call(obj);\\n        return true;\\n    } catch (e) {}\\n    return false;\\n}\\n\\nvar hasOwn = Object.prototype.hasOwnProperty || function (key) { return key in this; };\\nfunction has(obj, key) {\\n    return hasOwn.call(obj, key);\\n}\\n\\nfunction toStr(obj) {\\n    return objectToString.call(obj);\\n}\\n\\nfunction nameOf(f) {\\n    if (f.name) { return f.name; }\\n    var m = $match.call(functionToString.call(f), /^function\\\\s*([\\\\w$]+)/);\\n    if (m) { return m[1]; }\\n    return null;\\n}\\n\\nfunction indexOf(xs, x) {\\n    if (xs.indexOf) { return xs.indexOf(x); }\\n    for (var i = 0, l = xs.length; i < l; i++) {\\n        if (xs[i] === x) { return i; }\\n    }\\n    return -1;\\n}\\n\\nfunction isMap(x) {\\n    if (!mapSize || !x || typeof x !== 'object') {\\n        return false;\\n    }\\n    try {\\n        mapSize.call(x);\\n        try {\\n            setSize.call(x);\\n        } catch (s) {\\n            return true;\\n        }\\n        return x instanceof Map; // core-js workaround, pre-v2.5.0\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isWeakMap(x) {\\n    if (!weakMapHas || !x || typeof x !== 'object') {\\n        return false;\\n    }\\n    try {\\n        weakMapHas.call(x, weakMapHas);\\n        try {\\n            weakSetHas.call(x, weakSetHas);\\n        } catch (s) {\\n            return true;\\n        }\\n        return x instanceof WeakMap; // core-js workaround, pre-v2.5.0\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isWeakRef(x) {\\n    if (!weakRefDeref || !x || typeof x !== 'object') {\\n        return false;\\n    }\\n    try {\\n        weakRefDeref.call(x);\\n        return true;\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isSet(x) {\\n    if (!setSize || !x || typeof x !== 'object') {\\n        return false;\\n    }\\n    try {\\n        setSize.call(x);\\n        try {\\n            mapSize.call(x);\\n        } catch (m) {\\n            return true;\\n        }\\n        return x instanceof Set; // core-js workaround, pre-v2.5.0\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isWeakSet(x) {\\n    if (!weakSetHas || !x || typeof x !== 'object') {\\n        return false;\\n    }\\n    try {\\n        weakSetHas.call(x, weakSetHas);\\n        try {\\n            weakMapHas.call(x, weakMapHas);\\n        } catch (s) {\\n            return true;\\n        }\\n        return x instanceof WeakSet; // core-js workaround, pre-v2.5.0\\n    } catch (e) {}\\n    return false;\\n}\\n\\nfunction isElement(x) {\\n    if (!x || typeof x !== 'object') { return false; }\\n    if (typeof HTMLElement !== 'undefined' && x instanceof HTMLElement) {\\n        return true;\\n    }\\n    return typeof x.nodeName === 'string' && typeof x.getAttribute === 'function';\\n}\\n\\nfunction inspectString(str, opts) {\\n    if (str.length > opts.maxStringLength) {\\n        var remaining = str.length - opts.maxStringLength;\\n        var trailer = '... ' + remaining + ' more character' + (remaining > 1 ? 's' : '');\\n        return inspectString($slice.call(str, 0, opts.maxStringLength), opts) + trailer;\\n    }\\n    // eslint-disable-next-line no-control-regex\\n    var s = $replace.call($replace.call(str, /(['\\\\\\\\])/g, '\\\\\\\\$1'), /[\\\\x00-\\\\x1f]/g, lowbyte);\\n    return wrapQuotes(s, 'single', opts);\\n}\\n\\nfunction lowbyte(c) {\\n    var n = c.charCodeAt(0);\\n    var x = {\\n        8: 'b',\\n        9: 't',\\n        10: 'n',\\n        12: 'f',\\n        13: 'r'\\n    }[n];\\n    if (x) { return '\\\\\\\\' + x; }\\n    return '\\\\\\\\x' + (n < 0x10 ? '0' : '') + $toUpperCase.call(n.toString(16));\\n}\\n\\nfunction markBoxed(str) {\\n    return 'Object(' + str + ')';\\n}\\n\\nfunction weakCollectionOf(type) {\\n    return type + ' { ? }';\\n}\\n\\nfunction collectionOf(type, size, entries, indent) {\\n    var joinedEntries = indent ? indentedJoin(entries, indent) : $join.call(entries, ', ');\\n    return type + ' (' + size + ') {' + joinedEntries + '}';\\n}\\n\\nfunction singleLineValues(xs) {\\n    for (var i = 0; i < xs.length; i++) {\\n        if (indexOf(xs[i], '\\\\n') >= 0) {\\n            return false;\\n        }\\n    }\\n    return true;\\n}\\n\\nfunction getIndent(opts, depth) {\\n    var baseIndent;\\n    if (opts.indent === '\\\\t') {\\n        baseIndent = '\\\\t';\\n    } else if (typeof opts.indent === 'number' && opts.indent > 0) {\\n        baseIndent = $join.call(Array(opts.indent + 1), ' ');\\n    } else {\\n        return null;\\n    }\\n    return {\\n        base: baseIndent,\\n        prev: $join.call(Array(depth + 1), baseIndent)\\n    };\\n}\\n\\nfunction indentedJoin(xs, indent) {\\n    if (xs.length === 0) { return ''; }\\n    var lineJoiner = '\\\\n' + indent.prev + indent.base;\\n    return lineJoiner + $join.call(xs, ',' + lineJoiner) + '\\\\n' + indent.prev;\\n}\\n\\nfunction arrObjKeys(obj, inspect) {\\n    var isArr = isArray(obj);\\n    var xs = [];\\n    if (isArr) {\\n        xs.length = obj.length;\\n        for (var i = 0; i < obj.length; i++) {\\n            xs[i] = has(obj, i) ? inspect(obj[i], obj) : '';\\n        }\\n    }\\n    var syms = typeof gOPS === 'function' ? gOPS(obj) : [];\\n    var symMap;\\n    if (hasShammedSymbols) {\\n        symMap = {};\\n        for (var k = 0; k < syms.length; k++) {\\n            symMap['$' + syms[k]] = syms[k];\\n        }\\n    }\\n\\n    for (var key in obj) { // eslint-disable-line no-restricted-syntax\\n        if (!has(obj, key)) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\\n        if (isArr && String(Number(key)) === key && key < obj.length) { continue; } // eslint-disable-line no-restricted-syntax, no-continue\\n        if (hasShammedSymbols && symMap['$' + key] instanceof Symbol) {\\n            // this is to prevent shammed Symbols, which are stored as strings, from being included in the string key section\\n            continue; // eslint-disable-line no-restricted-syntax, no-continue\\n        } else if ($test.call(/[^\\\\w$]/, key)) {\\n            xs.push(inspect(key, obj) + ': ' + inspect(obj[key], obj));\\n        } else {\\n            xs.push(key + ': ' + inspect(obj[key], obj));\\n        }\\n    }\\n    if (typeof gOPS === 'function') {\\n        for (var j = 0; j < syms.length; j++) {\\n            if (isEnumerable.call(obj, syms[j])) {\\n                xs.push('[' + inspect(syms[j]) + ']: ' + inspect(obj[syms[j]], obj));\\n            }\\n        }\\n    }\\n    return xs;\\n}\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/object-inspect/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/p-throttle/index.js\":\n/*!*******************************************!*\\\n  !*** ../node_modules/p-throttle/index.js ***!\n  \\*******************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\nclass AbortError extends Error {\\n\\tconstructor() {\\n\\t\\tsuper('Throttled function aborted');\\n\\t\\tthis.name = 'AbortError';\\n\\t}\\n}\\n\\nconst pThrottle = ({limit, interval, strict}) => {\\n\\tif (!Number.isFinite(limit)) {\\n\\t\\tthrow new TypeError('Expected `limit` to be a finite number');\\n\\t}\\n\\n\\tif (!Number.isFinite(interval)) {\\n\\t\\tthrow new TypeError('Expected `interval` to be a finite number');\\n\\t}\\n\\n\\tconst queue = new Map();\\n\\n\\tlet currentTick = 0;\\n\\tlet activeCount = 0;\\n\\n\\tfunction windowedDelay() {\\n\\t\\tconst now = Date.now();\\n\\n\\t\\tif ((now - currentTick) > interval) {\\n\\t\\t\\tactiveCount = 1;\\n\\t\\t\\tcurrentTick = now;\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tif (activeCount < limit) {\\n\\t\\t\\tactiveCount++;\\n\\t\\t} else {\\n\\t\\t\\tcurrentTick += interval;\\n\\t\\t\\tactiveCount = 1;\\n\\t\\t}\\n\\n\\t\\treturn currentTick - now;\\n\\t}\\n\\n\\tconst strictTicks = [];\\n\\n\\tfunction strictDelay() {\\n\\t\\tconst now = Date.now();\\n\\n\\t\\tif (strictTicks.length < limit) {\\n\\t\\t\\tstrictTicks.push(now);\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tconst earliestTime = strictTicks.shift() + interval;\\n\\n\\t\\tif (now >= earliestTime) {\\n\\t\\t\\tstrictTicks.push(now);\\n\\t\\t\\treturn 0;\\n\\t\\t}\\n\\n\\t\\tstrictTicks.push(earliestTime);\\n\\t\\treturn earliestTime - now;\\n\\t}\\n\\n\\tconst getDelay = strict ? strictDelay : windowedDelay;\\n\\n\\treturn function_ => {\\n\\t\\tconst throttled = function (...args) {\\n\\t\\t\\tif (!throttled.isEnabled) {\\n\\t\\t\\t\\treturn (async () => function_.apply(this, args))();\\n\\t\\t\\t}\\n\\n\\t\\t\\tlet timeout;\\n\\t\\t\\treturn new Promise((resolve, reject) => {\\n\\t\\t\\t\\tconst execute = () => {\\n\\t\\t\\t\\t\\tresolve(function_.apply(this, args));\\n\\t\\t\\t\\t\\tqueue.delete(timeout);\\n\\t\\t\\t\\t};\\n\\n\\t\\t\\t\\ttimeout = setTimeout(execute, getDelay());\\n\\n\\t\\t\\t\\tqueue.set(timeout, reject);\\n\\t\\t\\t});\\n\\t\\t};\\n\\n\\t\\tthrottled.abort = () => {\\n\\t\\t\\tfor (const timeout of queue.keys()) {\\n\\t\\t\\t\\tclearTimeout(timeout);\\n\\t\\t\\t\\tqueue.get(timeout)(new AbortError());\\n\\t\\t\\t}\\n\\n\\t\\t\\tqueue.clear();\\n\\t\\t\\tstrictTicks.splice(0, strictTicks.length);\\n\\t\\t};\\n\\n\\t\\tthrottled.isEnabled = true;\\n\\n\\t\\treturn throttled;\\n\\t};\\n};\\n\\nmodule.exports = pThrottle;\\nmodule.exports.AbortError = AbortError;\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/p-throttle/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/qs/lib/formats.js\":\n/*!*****************************************!*\\\n  !*** ../node_modules/qs/lib/formats.js ***!\n  \\*****************************************/\n/***/ ((module) => {\n\n\"use strict\";\neval(\"\\n\\nvar replace = String.prototype.replace;\\nvar percentTwenties = /%20/g;\\n\\nvar Format = {\\n    RFC1738: 'RFC1738',\\n    RFC3986: 'RFC3986'\\n};\\n\\nmodule.exports = {\\n    'default': Format.RFC3986,\\n    formatters: {\\n        RFC1738: function (value) {\\n            return replace.call(value, percentTwenties, '+');\\n        },\\n        RFC3986: function (value) {\\n            return String(value);\\n        }\\n    },\\n    RFC1738: Format.RFC1738,\\n    RFC3986: Format.RFC3986\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/qs/lib/formats.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/qs/lib/index.js\":\n/*!***************************************!*\\\n  !*** ../node_modules/qs/lib/index.js ***!\n  \\***************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar stringify = __webpack_require__(/*! ./stringify */ \\\"../node_modules/qs/lib/stringify.js\\\");\\nvar parse = __webpack_require__(/*! ./parse */ \\\"../node_modules/qs/lib/parse.js\\\");\\nvar formats = __webpack_require__(/*! ./formats */ \\\"../node_modules/qs/lib/formats.js\\\");\\n\\nmodule.exports = {\\n    formats: formats,\\n    parse: parse,\\n    stringify: stringify\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/qs/lib/index.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/qs/lib/parse.js\":\n/*!***************************************!*\\\n  !*** ../node_modules/qs/lib/parse.js ***!\n  \\***************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar utils = __webpack_require__(/*! ./utils */ \\\"../node_modules/qs/lib/utils.js\\\");\\n\\nvar has = Object.prototype.hasOwnProperty;\\nvar isArray = Array.isArray;\\n\\nvar defaults = {\\n    allowDots: false,\\n    allowPrototypes: false,\\n    allowSparse: false,\\n    arrayLimit: 20,\\n    charset: 'utf-8',\\n    charsetSentinel: false,\\n    comma: false,\\n    decoder: utils.decode,\\n    delimiter: '&',\\n    depth: 5,\\n    ignoreQueryPrefix: false,\\n    interpretNumericEntities: false,\\n    parameterLimit: 1000,\\n    parseArrays: true,\\n    plainObjects: false,\\n    strictNullHandling: false\\n};\\n\\nvar interpretNumericEntities = function (str) {\\n    return str.replace(/&#(\\\\d+);/g, function ($0, numberStr) {\\n        return String.fromCharCode(parseInt(numberStr, 10));\\n    });\\n};\\n\\nvar parseArrayValue = function (val, options) {\\n    if (val && typeof val === 'string' && options.comma && val.indexOf(',') > -1) {\\n        return val.split(',');\\n    }\\n\\n    return val;\\n};\\n\\n// This is what browsers will submit when the  character occurs in an\\n// application/x-www-form-urlencoded body and the encoding of the page containing\\n// the form is iso-8859-1, or when the submitted form has an accept-charset\\n// attribute of iso-8859-1. Presumably also with other charsets that do not contain\\n// the  character, such as us-ascii.\\nvar isoSentinel = 'utf8=%26%2310003%3B'; // encodeURIComponent('&#10003;')\\n\\n// These are the percent-encoded utf-8 octets representing a checkmark, indicating that the request actually is utf-8 encoded.\\nvar charsetSentinel = 'utf8=%E2%9C%93'; // encodeURIComponent('')\\n\\nvar parseValues = function parseQueryStringValues(str, options) {\\n    var obj = {};\\n    var cleanStr = options.ignoreQueryPrefix ? str.replace(/^\\\\?/, '') : str;\\n    var limit = options.parameterLimit === Infinity ? undefined : options.parameterLimit;\\n    var parts = cleanStr.split(options.delimiter, limit);\\n    var skipIndex = -1; // Keep track of where the utf8 sentinel was found\\n    var i;\\n\\n    var charset = options.charset;\\n    if (options.charsetSentinel) {\\n        for (i = 0; i < parts.length; ++i) {\\n            if (parts[i].indexOf('utf8=') === 0) {\\n                if (parts[i] === charsetSentinel) {\\n                    charset = 'utf-8';\\n                } else if (parts[i] === isoSentinel) {\\n                    charset = 'iso-8859-1';\\n                }\\n                skipIndex = i;\\n                i = parts.length; // The eslint settings do not allow break;\\n            }\\n        }\\n    }\\n\\n    for (i = 0; i < parts.length; ++i) {\\n        if (i === skipIndex) {\\n            continue;\\n        }\\n        var part = parts[i];\\n\\n        var bracketEqualsPos = part.indexOf(']=');\\n        var pos = bracketEqualsPos === -1 ? part.indexOf('=') : bracketEqualsPos + 1;\\n\\n        var key, val;\\n        if (pos === -1) {\\n            key = options.decoder(part, defaults.decoder, charset, 'key');\\n            val = options.strictNullHandling ? null : '';\\n        } else {\\n            key = options.decoder(part.slice(0, pos), defaults.decoder, charset, 'key');\\n            val = utils.maybeMap(\\n                parseArrayValue(part.slice(pos + 1), options),\\n                function (encodedVal) {\\n                    return options.decoder(encodedVal, defaults.decoder, charset, 'value');\\n                }\\n            );\\n        }\\n\\n        if (val && options.interpretNumericEntities && charset === 'iso-8859-1') {\\n            val = interpretNumericEntities(val);\\n        }\\n\\n        if (part.indexOf('[]=') > -1) {\\n            val = isArray(val) ? [val] : val;\\n        }\\n\\n        if (has.call(obj, key)) {\\n            obj[key] = utils.combine(obj[key], val);\\n        } else {\\n            obj[key] = val;\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\nvar parseObject = function (chain, val, options, valuesParsed) {\\n    var leaf = valuesParsed ? val : parseArrayValue(val, options);\\n\\n    for (var i = chain.length - 1; i >= 0; --i) {\\n        var obj;\\n        var root = chain[i];\\n\\n        if (root === '[]' && options.parseArrays) {\\n            obj = [].concat(leaf);\\n        } else {\\n            obj = options.plainObjects ? Object.create(null) : {};\\n            var cleanRoot = root.charAt(0) === '[' && root.charAt(root.length - 1) === ']' ? root.slice(1, -1) : root;\\n            var index = parseInt(cleanRoot, 10);\\n            if (!options.parseArrays && cleanRoot === '') {\\n                obj = { 0: leaf };\\n            } else if (\\n                !isNaN(index)\\n                && root !== cleanRoot\\n                && String(index) === cleanRoot\\n                && index >= 0\\n                && (options.parseArrays && index <= options.arrayLimit)\\n            ) {\\n                obj = [];\\n                obj[index] = leaf;\\n            } else if (cleanRoot !== '__proto__') {\\n                obj[cleanRoot] = leaf;\\n            }\\n        }\\n\\n        leaf = obj;\\n    }\\n\\n    return leaf;\\n};\\n\\nvar parseKeys = function parseQueryStringKeys(givenKey, val, options, valuesParsed) {\\n    if (!givenKey) {\\n        return;\\n    }\\n\\n    // Transform dot notation to bracket notation\\n    var key = options.allowDots ? givenKey.replace(/\\\\.([^.[]+)/g, '[$1]') : givenKey;\\n\\n    // The regex chunks\\n\\n    var brackets = /(\\\\[[^[\\\\]]*])/;\\n    var child = /(\\\\[[^[\\\\]]*])/g;\\n\\n    // Get the parent\\n\\n    var segment = options.depth > 0 && brackets.exec(key);\\n    var parent = segment ? key.slice(0, segment.index) : key;\\n\\n    // Stash the parent if it exists\\n\\n    var keys = [];\\n    if (parent) {\\n        // If we aren't using plain objects, optionally prefix keys that would overwrite object prototype properties\\n        if (!options.plainObjects && has.call(Object.prototype, parent)) {\\n            if (!options.allowPrototypes) {\\n                return;\\n            }\\n        }\\n\\n        keys.push(parent);\\n    }\\n\\n    // Loop through children appending to the array until we hit depth\\n\\n    var i = 0;\\n    while (options.depth > 0 && (segment = child.exec(key)) !== null && i < options.depth) {\\n        i += 1;\\n        if (!options.plainObjects && has.call(Object.prototype, segment[1].slice(1, -1))) {\\n            if (!options.allowPrototypes) {\\n                return;\\n            }\\n        }\\n        keys.push(segment[1]);\\n    }\\n\\n    // If there's a remainder, just add whatever is left\\n\\n    if (segment) {\\n        keys.push('[' + key.slice(segment.index) + ']');\\n    }\\n\\n    return parseObject(keys, val, options, valuesParsed);\\n};\\n\\nvar normalizeParseOptions = function normalizeParseOptions(opts) {\\n    if (!opts) {\\n        return defaults;\\n    }\\n\\n    if (opts.decoder !== null && opts.decoder !== undefined && typeof opts.decoder !== 'function') {\\n        throw new TypeError('Decoder has to be a function.');\\n    }\\n\\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\\n    }\\n    var charset = typeof opts.charset === 'undefined' ? defaults.charset : opts.charset;\\n\\n    return {\\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\\n        allowPrototypes: typeof opts.allowPrototypes === 'boolean' ? opts.allowPrototypes : defaults.allowPrototypes,\\n        allowSparse: typeof opts.allowSparse === 'boolean' ? opts.allowSparse : defaults.allowSparse,\\n        arrayLimit: typeof opts.arrayLimit === 'number' ? opts.arrayLimit : defaults.arrayLimit,\\n        charset: charset,\\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\\n        comma: typeof opts.comma === 'boolean' ? opts.comma : defaults.comma,\\n        decoder: typeof opts.decoder === 'function' ? opts.decoder : defaults.decoder,\\n        delimiter: typeof opts.delimiter === 'string' || utils.isRegExp(opts.delimiter) ? opts.delimiter : defaults.delimiter,\\n        // eslint-disable-next-line no-implicit-coercion, no-extra-parens\\n        depth: (typeof opts.depth === 'number' || opts.depth === false) ? +opts.depth : defaults.depth,\\n        ignoreQueryPrefix: opts.ignoreQueryPrefix === true,\\n        interpretNumericEntities: typeof opts.interpretNumericEntities === 'boolean' ? opts.interpretNumericEntities : defaults.interpretNumericEntities,\\n        parameterLimit: typeof opts.parameterLimit === 'number' ? opts.parameterLimit : defaults.parameterLimit,\\n        parseArrays: opts.parseArrays !== false,\\n        plainObjects: typeof opts.plainObjects === 'boolean' ? opts.plainObjects : defaults.plainObjects,\\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\\n    };\\n};\\n\\nmodule.exports = function (str, opts) {\\n    var options = normalizeParseOptions(opts);\\n\\n    if (str === '' || str === null || typeof str === 'undefined') {\\n        return options.plainObjects ? Object.create(null) : {};\\n    }\\n\\n    var tempObj = typeof str === 'string' ? parseValues(str, options) : str;\\n    var obj = options.plainObjects ? Object.create(null) : {};\\n\\n    // Iterate over the keys and setup the new object\\n\\n    var keys = Object.keys(tempObj);\\n    for (var i = 0; i < keys.length; ++i) {\\n        var key = keys[i];\\n        var newObj = parseKeys(key, tempObj[key], options, typeof str === 'string');\\n        obj = utils.merge(obj, newObj, options);\\n    }\\n\\n    if (options.allowSparse === true) {\\n        return obj;\\n    }\\n\\n    return utils.compact(obj);\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/qs/lib/parse.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/qs/lib/stringify.js\":\n/*!*******************************************!*\\\n  !*** ../node_modules/qs/lib/stringify.js ***!\n  \\*******************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar getSideChannel = __webpack_require__(/*! side-channel */ \\\"../node_modules/side-channel/index.js\\\");\\nvar utils = __webpack_require__(/*! ./utils */ \\\"../node_modules/qs/lib/utils.js\\\");\\nvar formats = __webpack_require__(/*! ./formats */ \\\"../node_modules/qs/lib/formats.js\\\");\\nvar has = Object.prototype.hasOwnProperty;\\n\\nvar arrayPrefixGenerators = {\\n    brackets: function brackets(prefix) {\\n        return prefix + '[]';\\n    },\\n    comma: 'comma',\\n    indices: function indices(prefix, key) {\\n        return prefix + '[' + key + ']';\\n    },\\n    repeat: function repeat(prefix) {\\n        return prefix;\\n    }\\n};\\n\\nvar isArray = Array.isArray;\\nvar split = String.prototype.split;\\nvar push = Array.prototype.push;\\nvar pushToArray = function (arr, valueOrArray) {\\n    push.apply(arr, isArray(valueOrArray) ? valueOrArray : [valueOrArray]);\\n};\\n\\nvar toISO = Date.prototype.toISOString;\\n\\nvar defaultFormat = formats['default'];\\nvar defaults = {\\n    addQueryPrefix: false,\\n    allowDots: false,\\n    charset: 'utf-8',\\n    charsetSentinel: false,\\n    delimiter: '&',\\n    encode: true,\\n    encoder: utils.encode,\\n    encodeValuesOnly: false,\\n    format: defaultFormat,\\n    formatter: formats.formatters[defaultFormat],\\n    // deprecated\\n    indices: false,\\n    serializeDate: function serializeDate(date) {\\n        return toISO.call(date);\\n    },\\n    skipNulls: false,\\n    strictNullHandling: false\\n};\\n\\nvar isNonNullishPrimitive = function isNonNullishPrimitive(v) {\\n    return typeof v === 'string'\\n        || typeof v === 'number'\\n        || typeof v === 'boolean'\\n        || typeof v === 'symbol'\\n        || typeof v === 'bigint';\\n};\\n\\nvar sentinel = {};\\n\\nvar stringify = function stringify(\\n    object,\\n    prefix,\\n    generateArrayPrefix,\\n    commaRoundTrip,\\n    strictNullHandling,\\n    skipNulls,\\n    encoder,\\n    filter,\\n    sort,\\n    allowDots,\\n    serializeDate,\\n    format,\\n    formatter,\\n    encodeValuesOnly,\\n    charset,\\n    sideChannel\\n) {\\n    var obj = object;\\n\\n    var tmpSc = sideChannel;\\n    var step = 0;\\n    var findFlag = false;\\n    while ((tmpSc = tmpSc.get(sentinel)) !== void undefined && !findFlag) {\\n        // Where object last appeared in the ref tree\\n        var pos = tmpSc.get(object);\\n        step += 1;\\n        if (typeof pos !== 'undefined') {\\n            if (pos === step) {\\n                throw new RangeError('Cyclic object value');\\n            } else {\\n                findFlag = true; // Break while\\n            }\\n        }\\n        if (typeof tmpSc.get(sentinel) === 'undefined') {\\n            step = 0;\\n        }\\n    }\\n\\n    if (typeof filter === 'function') {\\n        obj = filter(prefix, obj);\\n    } else if (obj instanceof Date) {\\n        obj = serializeDate(obj);\\n    } else if (generateArrayPrefix === 'comma' && isArray(obj)) {\\n        obj = utils.maybeMap(obj, function (value) {\\n            if (value instanceof Date) {\\n                return serializeDate(value);\\n            }\\n            return value;\\n        });\\n    }\\n\\n    if (obj === null) {\\n        if (strictNullHandling) {\\n            return encoder && !encodeValuesOnly ? encoder(prefix, defaults.encoder, charset, 'key', format) : prefix;\\n        }\\n\\n        obj = '';\\n    }\\n\\n    if (isNonNullishPrimitive(obj) || utils.isBuffer(obj)) {\\n        if (encoder) {\\n            var keyValue = encodeValuesOnly ? prefix : encoder(prefix, defaults.encoder, charset, 'key', format);\\n            if (generateArrayPrefix === 'comma' && encodeValuesOnly) {\\n                var valuesArray = split.call(String(obj), ',');\\n                var valuesJoined = '';\\n                for (var i = 0; i < valuesArray.length; ++i) {\\n                    valuesJoined += (i === 0 ? '' : ',') + formatter(encoder(valuesArray[i], defaults.encoder, charset, 'value', format));\\n                }\\n                return [formatter(keyValue) + (commaRoundTrip && isArray(obj) && valuesArray.length === 1 ? '[]' : '') + '=' + valuesJoined];\\n            }\\n            return [formatter(keyValue) + '=' + formatter(encoder(obj, defaults.encoder, charset, 'value', format))];\\n        }\\n        return [formatter(prefix) + '=' + formatter(String(obj))];\\n    }\\n\\n    var values = [];\\n\\n    if (typeof obj === 'undefined') {\\n        return values;\\n    }\\n\\n    var objKeys;\\n    if (generateArrayPrefix === 'comma' && isArray(obj)) {\\n        // we need to join elements in\\n        objKeys = [{ value: obj.length > 0 ? obj.join(',') || null : void undefined }];\\n    } else if (isArray(filter)) {\\n        objKeys = filter;\\n    } else {\\n        var keys = Object.keys(obj);\\n        objKeys = sort ? keys.sort(sort) : keys;\\n    }\\n\\n    var adjustedPrefix = commaRoundTrip && isArray(obj) && obj.length === 1 ? prefix + '[]' : prefix;\\n\\n    for (var j = 0; j < objKeys.length; ++j) {\\n        var key = objKeys[j];\\n        var value = typeof key === 'object' && typeof key.value !== 'undefined' ? key.value : obj[key];\\n\\n        if (skipNulls && value === null) {\\n            continue;\\n        }\\n\\n        var keyPrefix = isArray(obj)\\n            ? typeof generateArrayPrefix === 'function' ? generateArrayPrefix(adjustedPrefix, key) : adjustedPrefix\\n            : adjustedPrefix + (allowDots ? '.' + key : '[' + key + ']');\\n\\n        sideChannel.set(object, step);\\n        var valueSideChannel = getSideChannel();\\n        valueSideChannel.set(sentinel, sideChannel);\\n        pushToArray(values, stringify(\\n            value,\\n            keyPrefix,\\n            generateArrayPrefix,\\n            commaRoundTrip,\\n            strictNullHandling,\\n            skipNulls,\\n            encoder,\\n            filter,\\n            sort,\\n            allowDots,\\n            serializeDate,\\n            format,\\n            formatter,\\n            encodeValuesOnly,\\n            charset,\\n            valueSideChannel\\n        ));\\n    }\\n\\n    return values;\\n};\\n\\nvar normalizeStringifyOptions = function normalizeStringifyOptions(opts) {\\n    if (!opts) {\\n        return defaults;\\n    }\\n\\n    if (opts.encoder !== null && typeof opts.encoder !== 'undefined' && typeof opts.encoder !== 'function') {\\n        throw new TypeError('Encoder has to be a function.');\\n    }\\n\\n    var charset = opts.charset || defaults.charset;\\n    if (typeof opts.charset !== 'undefined' && opts.charset !== 'utf-8' && opts.charset !== 'iso-8859-1') {\\n        throw new TypeError('The charset option must be either utf-8, iso-8859-1, or undefined');\\n    }\\n\\n    var format = formats['default'];\\n    if (typeof opts.format !== 'undefined') {\\n        if (!has.call(formats.formatters, opts.format)) {\\n            throw new TypeError('Unknown format option provided.');\\n        }\\n        format = opts.format;\\n    }\\n    var formatter = formats.formatters[format];\\n\\n    var filter = defaults.filter;\\n    if (typeof opts.filter === 'function' || isArray(opts.filter)) {\\n        filter = opts.filter;\\n    }\\n\\n    return {\\n        addQueryPrefix: typeof opts.addQueryPrefix === 'boolean' ? opts.addQueryPrefix : defaults.addQueryPrefix,\\n        allowDots: typeof opts.allowDots === 'undefined' ? defaults.allowDots : !!opts.allowDots,\\n        charset: charset,\\n        charsetSentinel: typeof opts.charsetSentinel === 'boolean' ? opts.charsetSentinel : defaults.charsetSentinel,\\n        delimiter: typeof opts.delimiter === 'undefined' ? defaults.delimiter : opts.delimiter,\\n        encode: typeof opts.encode === 'boolean' ? opts.encode : defaults.encode,\\n        encoder: typeof opts.encoder === 'function' ? opts.encoder : defaults.encoder,\\n        encodeValuesOnly: typeof opts.encodeValuesOnly === 'boolean' ? opts.encodeValuesOnly : defaults.encodeValuesOnly,\\n        filter: filter,\\n        format: format,\\n        formatter: formatter,\\n        serializeDate: typeof opts.serializeDate === 'function' ? opts.serializeDate : defaults.serializeDate,\\n        skipNulls: typeof opts.skipNulls === 'boolean' ? opts.skipNulls : defaults.skipNulls,\\n        sort: typeof opts.sort === 'function' ? opts.sort : null,\\n        strictNullHandling: typeof opts.strictNullHandling === 'boolean' ? opts.strictNullHandling : defaults.strictNullHandling\\n    };\\n};\\n\\nmodule.exports = function (object, opts) {\\n    var obj = object;\\n    var options = normalizeStringifyOptions(opts);\\n\\n    var objKeys;\\n    var filter;\\n\\n    if (typeof options.filter === 'function') {\\n        filter = options.filter;\\n        obj = filter('', obj);\\n    } else if (isArray(options.filter)) {\\n        filter = options.filter;\\n        objKeys = filter;\\n    }\\n\\n    var keys = [];\\n\\n    if (typeof obj !== 'object' || obj === null) {\\n        return '';\\n    }\\n\\n    var arrayFormat;\\n    if (opts && opts.arrayFormat in arrayPrefixGenerators) {\\n        arrayFormat = opts.arrayFormat;\\n    } else if (opts && 'indices' in opts) {\\n        arrayFormat = opts.indices ? 'indices' : 'repeat';\\n    } else {\\n        arrayFormat = 'indices';\\n    }\\n\\n    var generateArrayPrefix = arrayPrefixGenerators[arrayFormat];\\n    if (opts && 'commaRoundTrip' in opts && typeof opts.commaRoundTrip !== 'boolean') {\\n        throw new TypeError('`commaRoundTrip` must be a boolean, or absent');\\n    }\\n    var commaRoundTrip = generateArrayPrefix === 'comma' && opts && opts.commaRoundTrip;\\n\\n    if (!objKeys) {\\n        objKeys = Object.keys(obj);\\n    }\\n\\n    if (options.sort) {\\n        objKeys.sort(options.sort);\\n    }\\n\\n    var sideChannel = getSideChannel();\\n    for (var i = 0; i < objKeys.length; ++i) {\\n        var key = objKeys[i];\\n\\n        if (options.skipNulls && obj[key] === null) {\\n            continue;\\n        }\\n        pushToArray(keys, stringify(\\n            obj[key],\\n            key,\\n            generateArrayPrefix,\\n            commaRoundTrip,\\n            options.strictNullHandling,\\n            options.skipNulls,\\n            options.encode ? options.encoder : null,\\n            options.filter,\\n            options.sort,\\n            options.allowDots,\\n            options.serializeDate,\\n            options.format,\\n            options.formatter,\\n            options.encodeValuesOnly,\\n            options.charset,\\n            sideChannel\\n        ));\\n    }\\n\\n    var joined = keys.join(options.delimiter);\\n    var prefix = options.addQueryPrefix === true ? '?' : '';\\n\\n    if (options.charsetSentinel) {\\n        if (options.charset === 'iso-8859-1') {\\n            // encodeURIComponent('&#10003;'), the \\\"numeric entity\\\" representation of a checkmark\\n            prefix += 'utf8=%26%2310003%3B&';\\n        } else {\\n            // encodeURIComponent('')\\n            prefix += 'utf8=%E2%9C%93&';\\n        }\\n    }\\n\\n    return joined.length > 0 ? prefix + joined : '';\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/qs/lib/stringify.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/qs/lib/utils.js\":\n/*!***************************************!*\\\n  !*** ../node_modules/qs/lib/utils.js ***!\n  \\***************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar formats = __webpack_require__(/*! ./formats */ \\\"../node_modules/qs/lib/formats.js\\\");\\n\\nvar has = Object.prototype.hasOwnProperty;\\nvar isArray = Array.isArray;\\n\\nvar hexTable = (function () {\\n    var array = [];\\n    for (var i = 0; i < 256; ++i) {\\n        array.push('%' + ((i < 16 ? '0' : '') + i.toString(16)).toUpperCase());\\n    }\\n\\n    return array;\\n}());\\n\\nvar compactQueue = function compactQueue(queue) {\\n    while (queue.length > 1) {\\n        var item = queue.pop();\\n        var obj = item.obj[item.prop];\\n\\n        if (isArray(obj)) {\\n            var compacted = [];\\n\\n            for (var j = 0; j < obj.length; ++j) {\\n                if (typeof obj[j] !== 'undefined') {\\n                    compacted.push(obj[j]);\\n                }\\n            }\\n\\n            item.obj[item.prop] = compacted;\\n        }\\n    }\\n};\\n\\nvar arrayToObject = function arrayToObject(source, options) {\\n    var obj = options && options.plainObjects ? Object.create(null) : {};\\n    for (var i = 0; i < source.length; ++i) {\\n        if (typeof source[i] !== 'undefined') {\\n            obj[i] = source[i];\\n        }\\n    }\\n\\n    return obj;\\n};\\n\\nvar merge = function merge(target, source, options) {\\n    /* eslint no-param-reassign: 0 */\\n    if (!source) {\\n        return target;\\n    }\\n\\n    if (typeof source !== 'object') {\\n        if (isArray(target)) {\\n            target.push(source);\\n        } else if (target && typeof target === 'object') {\\n            if ((options && (options.plainObjects || options.allowPrototypes)) || !has.call(Object.prototype, source)) {\\n                target[source] = true;\\n            }\\n        } else {\\n            return [target, source];\\n        }\\n\\n        return target;\\n    }\\n\\n    if (!target || typeof target !== 'object') {\\n        return [target].concat(source);\\n    }\\n\\n    var mergeTarget = target;\\n    if (isArray(target) && !isArray(source)) {\\n        mergeTarget = arrayToObject(target, options);\\n    }\\n\\n    if (isArray(target) && isArray(source)) {\\n        source.forEach(function (item, i) {\\n            if (has.call(target, i)) {\\n                var targetItem = target[i];\\n                if (targetItem && typeof targetItem === 'object' && item && typeof item === 'object') {\\n                    target[i] = merge(targetItem, item, options);\\n                } else {\\n                    target.push(item);\\n                }\\n            } else {\\n                target[i] = item;\\n            }\\n        });\\n        return target;\\n    }\\n\\n    return Object.keys(source).reduce(function (acc, key) {\\n        var value = source[key];\\n\\n        if (has.call(acc, key)) {\\n            acc[key] = merge(acc[key], value, options);\\n        } else {\\n            acc[key] = value;\\n        }\\n        return acc;\\n    }, mergeTarget);\\n};\\n\\nvar assign = function assignSingleSource(target, source) {\\n    return Object.keys(source).reduce(function (acc, key) {\\n        acc[key] = source[key];\\n        return acc;\\n    }, target);\\n};\\n\\nvar decode = function (str, decoder, charset) {\\n    var strWithoutPlus = str.replace(/\\\\+/g, ' ');\\n    if (charset === 'iso-8859-1') {\\n        // unescape never throws, no try...catch needed:\\n        return strWithoutPlus.replace(/%[0-9a-f]{2}/gi, unescape);\\n    }\\n    // utf-8\\n    try {\\n        return decodeURIComponent(strWithoutPlus);\\n    } catch (e) {\\n        return strWithoutPlus;\\n    }\\n};\\n\\nvar encode = function encode(str, defaultEncoder, charset, kind, format) {\\n    // This code was originally written by Brian White (mscdex) for the io.js core querystring library.\\n    // It has been adapted here for stricter adherence to RFC 3986\\n    if (str.length === 0) {\\n        return str;\\n    }\\n\\n    var string = str;\\n    if (typeof str === 'symbol') {\\n        string = Symbol.prototype.toString.call(str);\\n    } else if (typeof str !== 'string') {\\n        string = String(str);\\n    }\\n\\n    if (charset === 'iso-8859-1') {\\n        return escape(string).replace(/%u[0-9a-f]{4}/gi, function ($0) {\\n            return '%26%23' + parseInt($0.slice(2), 16) + '%3B';\\n        });\\n    }\\n\\n    var out = '';\\n    for (var i = 0; i < string.length; ++i) {\\n        var c = string.charCodeAt(i);\\n\\n        if (\\n            c === 0x2D // -\\n            || c === 0x2E // .\\n            || c === 0x5F // _\\n            || c === 0x7E // ~\\n            || (c >= 0x30 && c <= 0x39) // 0-9\\n            || (c >= 0x41 && c <= 0x5A) // a-z\\n            || (c >= 0x61 && c <= 0x7A) // A-Z\\n            || (format === formats.RFC1738 && (c === 0x28 || c === 0x29)) // ( )\\n        ) {\\n            out += string.charAt(i);\\n            continue;\\n        }\\n\\n        if (c < 0x80) {\\n            out = out + hexTable[c];\\n            continue;\\n        }\\n\\n        if (c < 0x800) {\\n            out = out + (hexTable[0xC0 | (c >> 6)] + hexTable[0x80 | (c & 0x3F)]);\\n            continue;\\n        }\\n\\n        if (c < 0xD800 || c >= 0xE000) {\\n            out = out + (hexTable[0xE0 | (c >> 12)] + hexTable[0x80 | ((c >> 6) & 0x3F)] + hexTable[0x80 | (c & 0x3F)]);\\n            continue;\\n        }\\n\\n        i += 1;\\n        c = 0x10000 + (((c & 0x3FF) << 10) | (string.charCodeAt(i) & 0x3FF));\\n        /* eslint operator-linebreak: [2, \\\"before\\\"] */\\n        out += hexTable[0xF0 | (c >> 18)]\\n            + hexTable[0x80 | ((c >> 12) & 0x3F)]\\n            + hexTable[0x80 | ((c >> 6) & 0x3F)]\\n            + hexTable[0x80 | (c & 0x3F)];\\n    }\\n\\n    return out;\\n};\\n\\nvar compact = function compact(value) {\\n    var queue = [{ obj: { o: value }, prop: 'o' }];\\n    var refs = [];\\n\\n    for (var i = 0; i < queue.length; ++i) {\\n        var item = queue[i];\\n        var obj = item.obj[item.prop];\\n\\n        var keys = Object.keys(obj);\\n        for (var j = 0; j < keys.length; ++j) {\\n            var key = keys[j];\\n            var val = obj[key];\\n            if (typeof val === 'object' && val !== null && refs.indexOf(val) === -1) {\\n                queue.push({ obj: obj, prop: key });\\n                refs.push(val);\\n            }\\n        }\\n    }\\n\\n    compactQueue(queue);\\n\\n    return value;\\n};\\n\\nvar isRegExp = function isRegExp(obj) {\\n    return Object.prototype.toString.call(obj) === '[object RegExp]';\\n};\\n\\nvar isBuffer = function isBuffer(obj) {\\n    if (!obj || typeof obj !== 'object') {\\n        return false;\\n    }\\n\\n    return !!(obj.constructor && obj.constructor.isBuffer && obj.constructor.isBuffer(obj));\\n};\\n\\nvar combine = function combine(a, b) {\\n    return [].concat(a, b);\\n};\\n\\nvar maybeMap = function maybeMap(val, fn) {\\n    if (isArray(val)) {\\n        var mapped = [];\\n        for (var i = 0; i < val.length; i += 1) {\\n            mapped.push(fn(val[i]));\\n        }\\n        return mapped;\\n    }\\n    return fn(val);\\n};\\n\\nmodule.exports = {\\n    arrayToObject: arrayToObject,\\n    assign: assign,\\n    combine: combine,\\n    compact: compact,\\n    decode: decode,\\n    encode: encode,\\n    isBuffer: isBuffer,\\n    isRegExp: isRegExp,\\n    maybeMap: maybeMap,\\n    merge: merge\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/qs/lib/utils.js?\");\n\n/***/ }),\n\n/***/ \"../node_modules/side-channel/index.js\":\n/*!*********************************************!*\\\n  !*** ../node_modules/side-channel/index.js ***!\n  \\*********************************************/\n/***/ ((module, __unused_webpack_exports, __webpack_require__) => {\n\n\"use strict\";\neval(\"\\n\\nvar GetIntrinsic = __webpack_require__(/*! get-intrinsic */ \\\"../node_modules/get-intrinsic/index.js\\\");\\nvar callBound = __webpack_require__(/*! call-bind/callBound */ \\\"../node_modules/call-bind/callBound.js\\\");\\nvar inspect = __webpack_require__(/*! object-inspect */ \\\"../node_modules/object-inspect/index.js\\\");\\n\\nvar $TypeError = GetIntrinsic('%TypeError%');\\nvar $WeakMap = GetIntrinsic('%WeakMap%', true);\\nvar $Map = GetIntrinsic('%Map%', true);\\n\\nvar $weakMapGet = callBound('WeakMap.prototype.get', true);\\nvar $weakMapSet = callBound('WeakMap.prototype.set', true);\\nvar $weakMapHas = callBound('WeakMap.prototype.has', true);\\nvar $mapGet = callBound('Map.prototype.get', true);\\nvar $mapSet = callBound('Map.prototype.set', true);\\nvar $mapHas = callBound('Map.prototype.has', true);\\n\\n/*\\n * This function traverses the list returning the node corresponding to the\\n * given key.\\n *\\n * That node is also moved to the head of the list, so that if it's accessed\\n * again we don't need to traverse the whole list. By doing so, all the recently\\n * used nodes can be accessed relatively quickly.\\n */\\nvar listGetNode = function (list, key) { // eslint-disable-line consistent-return\\n\\tfor (var prev = list, curr; (curr = prev.next) !== null; prev = curr) {\\n\\t\\tif (curr.key === key) {\\n\\t\\t\\tprev.next = curr.next;\\n\\t\\t\\tcurr.next = list.next;\\n\\t\\t\\tlist.next = curr; // eslint-disable-line no-param-reassign\\n\\t\\t\\treturn curr;\\n\\t\\t}\\n\\t}\\n};\\n\\nvar listGet = function (objects, key) {\\n\\tvar node = listGetNode(objects, key);\\n\\treturn node && node.value;\\n};\\nvar listSet = function (objects, key, value) {\\n\\tvar node = listGetNode(objects, key);\\n\\tif (node) {\\n\\t\\tnode.value = value;\\n\\t} else {\\n\\t\\t// Prepend the new node to the beginning of the list\\n\\t\\tobjects.next = { // eslint-disable-line no-param-reassign\\n\\t\\t\\tkey: key,\\n\\t\\t\\tnext: objects.next,\\n\\t\\t\\tvalue: value\\n\\t\\t};\\n\\t}\\n};\\nvar listHas = function (objects, key) {\\n\\treturn !!listGetNode(objects, key);\\n};\\n\\nmodule.exports = function getSideChannel() {\\n\\tvar $wm;\\n\\tvar $m;\\n\\tvar $o;\\n\\tvar channel = {\\n\\t\\tassert: function (key) {\\n\\t\\t\\tif (!channel.has(key)) {\\n\\t\\t\\t\\tthrow new $TypeError('Side channel does not contain ' + inspect(key));\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\tget: function (key) { // eslint-disable-line consistent-return\\n\\t\\t\\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\\n\\t\\t\\t\\tif ($wm) {\\n\\t\\t\\t\\t\\treturn $weakMapGet($wm, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if ($Map) {\\n\\t\\t\\t\\tif ($m) {\\n\\t\\t\\t\\t\\treturn $mapGet($m, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ($o) { // eslint-disable-line no-lonely-if\\n\\t\\t\\t\\t\\treturn listGet($o, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t},\\n\\t\\thas: function (key) {\\n\\t\\t\\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\\n\\t\\t\\t\\tif ($wm) {\\n\\t\\t\\t\\t\\treturn $weakMapHas($wm, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else if ($Map) {\\n\\t\\t\\t\\tif ($m) {\\n\\t\\t\\t\\t\\treturn $mapHas($m, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif ($o) { // eslint-disable-line no-lonely-if\\n\\t\\t\\t\\t\\treturn listHas($o, key);\\n\\t\\t\\t\\t}\\n\\t\\t\\t}\\n\\t\\t\\treturn false;\\n\\t\\t},\\n\\t\\tset: function (key, value) {\\n\\t\\t\\tif ($WeakMap && key && (typeof key === 'object' || typeof key === 'function')) {\\n\\t\\t\\t\\tif (!$wm) {\\n\\t\\t\\t\\t\\t$wm = new $WeakMap();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$weakMapSet($wm, key, value);\\n\\t\\t\\t} else if ($Map) {\\n\\t\\t\\t\\tif (!$m) {\\n\\t\\t\\t\\t\\t$m = new $Map();\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\t$mapSet($m, key, value);\\n\\t\\t\\t} else {\\n\\t\\t\\t\\tif (!$o) {\\n\\t\\t\\t\\t\\t/*\\n\\t\\t\\t\\t\\t * Initialize the linked list as an empty node, so that we don't have\\n\\t\\t\\t\\t\\t * to special-case handling of the first node: we can always refer to\\n\\t\\t\\t\\t\\t * it as (previous node).next, instead of something like (list).head\\n\\t\\t\\t\\t\\t */\\n\\t\\t\\t\\t\\t$o = { key: {}, next: null };\\n\\t\\t\\t\\t}\\n\\t\\t\\t\\tlistSet($o, key, value);\\n\\t\\t\\t}\\n\\t\\t}\\n\\t};\\n\\treturn channel;\\n};\\n\\n\\n//# sourceURL=webpack://contentful/../node_modules/side-channel/index.js?\");\n\n/***/ }),\n\n/***/ \"./contentful.ts\":\n/*!***********************!*\\\n  !*** ./contentful.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createClient\\\": () => (/* binding */ createClient)\\n/* harmony export */ });\\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! axios */ \\\"../node_modules/axios/index.js\\\");\\n/* harmony import */ var axios__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(axios__WEBPACK_IMPORTED_MODULE_0__);\\n/* harmony import */ var contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! contentful-sdk-core */ \\\"../node_modules/contentful-sdk-core/dist/index.es-modules.js\\\");\\n/* harmony import */ var _create_global_options__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./create-global-options */ \\\"./create-global-options.ts\\\");\\n/* harmony import */ var _make_client__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./make-client */ \\\"./make-client.ts\\\");\\n/* harmony import */ var _utils_validate_params__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/validate-params */ \\\"./utils/validate-params.ts\\\");\\n/**\\n * Contentful Delivery API SDK. Allows you to create instances of a client\\n * with access to the Contentful Content Delivery API.\\n */\\n\\n\\n\\n\\n\\n/**\\n * Create a client instance\\n * @param params - Client initialization parameters\\n * @category Client\\n * @example\\n * ```typescript\\n * const contentful = require('contentful')\\n * const client = contentful.createClient({\\n *   accessToken: 'myAccessToken',\\n *   space: 'mySpaceId'\\n * })\\n * ```\\n */\\nfunction createClient(params) {\\n    if (!params.accessToken) {\\n        throw new TypeError('Expected parameter accessToken');\\n    }\\n    if (!params.space) {\\n        throw new TypeError('Expected parameter space');\\n    }\\n    (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_4__.validateResolveLinksParam)(params);\\n    (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_4__.validateRemoveUnresolvedParam)(params);\\n    const defaultConfig = {\\n        resolveLinks: true,\\n        removeUnresolved: false,\\n        defaultHostname: 'cdn.contentful.com',\\n        environment: 'master',\\n    };\\n    const config = {\\n        ...defaultConfig,\\n        ...params,\\n    };\\n    const userAgentHeader = (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.getUserAgentHeader)(`contentful.js/${\\\"10.1.0\\\"}`, config.application, config.integration);\\n    config.headers = {\\n        ...config.headers,\\n        'Content-Type': 'application/vnd.contentful.delivery.v1+json',\\n        'X-Contentful-User-Agent': userAgentHeader,\\n    };\\n    const http = (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.createHttpClient)((axios__WEBPACK_IMPORTED_MODULE_0___default()), config);\\n    if (!http.defaults.baseURL) {\\n        throw new Error('Please define a baseURL');\\n    }\\n    const getGlobalOptions = (0,_create_global_options__WEBPACK_IMPORTED_MODULE_2__.createGlobalOptions)({\\n        space: config.space,\\n        environment: config.environment,\\n        spaceBaseUrl: http.defaults.baseURL,\\n        environmentBaseUrl: `${http.defaults.baseURL}environments/${config.environment}`,\\n    });\\n    // Append environment to baseURL\\n    http.defaults.baseURL = getGlobalOptions({}).environmentBaseUrl;\\n    return (0,_make_client__WEBPACK_IMPORTED_MODULE_3__.makeClient)({\\n        http,\\n        getGlobalOptions,\\n    });\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./contentful.ts?\");\n\n/***/ }),\n\n/***/ \"./create-contentful-api.ts\":\n/*!**********************************!*\\\n  !*** ./create-contentful-api.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ createContentfulApi)\\n/* harmony export */ });\\n/* harmony import */ var contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentful-sdk-core */ \\\"../node_modules/contentful-sdk-core/dist/index.es-modules.js\\\");\\n/* harmony import */ var _paged_sync__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./paged-sync */ \\\"./paged-sync.ts\\\");\\n/* harmony import */ var _utils_normalize_search_parameters__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./utils/normalize-search-parameters */ \\\"./utils/normalize-search-parameters.ts\\\");\\n/* harmony import */ var _utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/normalize-select */ \\\"./utils/normalize-select.ts\\\");\\n/* harmony import */ var _utils_resolve_circular__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/resolve-circular */ \\\"./utils/resolve-circular.ts\\\");\\n/* harmony import */ var _utils_validate_timestamp__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./utils/validate-timestamp */ \\\"./utils/validate-timestamp.ts\\\");\\n/* harmony import */ var _utils_validate_params__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./utils/validate-params */ \\\"./utils/validate-params.ts\\\");\\n/* harmony import */ var _utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./utils/validate-search-parameters */ \\\"./utils/validate-search-parameters.ts\\\");\\n/**\\n * Contentful Delivery API Client. Contains methods which allow access to the\\n * different kinds of entities present in Contentful (Entries, Assets, etc).\\n */\\n\\n\\n\\n\\n\\n\\n\\n\\nconst ASSET_KEY_MAX_LIFETIME = 48 * 60 * 60;\\nclass NotFoundError extends Error {\\n    sys;\\n    details;\\n    constructor(id, environment, space) {\\n        super('The resource could not be found.');\\n        this.sys = {\\n            type: 'Error',\\n            id: 'NotFound',\\n        };\\n        this.details = {\\n            type: 'Entry',\\n            id,\\n            environment,\\n            space,\\n        };\\n    }\\n}\\nfunction createContentfulApi({ http, getGlobalOptions }, options) {\\n    const notFoundError = (id = 'unknown') => {\\n        return new NotFoundError(id, getGlobalOptions().environment, getGlobalOptions().space);\\n    };\\n    const getBaseUrl = (context) => {\\n        let baseUrl = context === 'space' ? getGlobalOptions().spaceBaseUrl : getGlobalOptions().environmentBaseUrl;\\n        if (!baseUrl) {\\n            throw new Error('Please define baseUrl for ' + context);\\n        }\\n        if (!baseUrl.endsWith('/')) {\\n            baseUrl += '/';\\n        }\\n        return baseUrl;\\n    };\\n    async function get({ context, path, config }) {\\n        const baseUrl = getBaseUrl(context);\\n        try {\\n            const response = await http.get(baseUrl + path, config);\\n            return response.data;\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function post({ context, path, data, config }) {\\n        const baseUrl = getBaseUrl(context);\\n        try {\\n            const response = await http.post(baseUrl + path, data, config);\\n            return response.data;\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function getSpace() {\\n        return get({ context: 'space', path: '' });\\n    }\\n    async function getContentType(id) {\\n        return get({\\n            context: 'environment',\\n            path: `content_types/${id}`,\\n        });\\n    }\\n    async function getContentTypes(query = {}) {\\n        return get({\\n            context: 'environment',\\n            path: 'content_types',\\n            config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query }),\\n        });\\n    }\\n    async function getEntry(id, query = {}) {\\n        return makeGetEntry(id, query, options);\\n    }\\n    async function getEntries(query = {}) {\\n        return makeGetEntries(query, options);\\n    }\\n    async function makeGetEntry(id, query, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        const { withAllLocales } = options;\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateLocaleParam)(query, withAllLocales);\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateResolveLinksParam)(query);\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateRemoveUnresolvedParam)(query);\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        return internalGetEntry(id, withAllLocales ? { ...query, locale: '*' } : query, options);\\n    }\\n    async function internalGetEntry(id, query, options) {\\n        if (!id) {\\n            throw notFoundError(id);\\n        }\\n        try {\\n            const response = await internalGetEntries({ 'sys.id': id, ...query }, options);\\n            if (response.items.length > 0) {\\n                return response.items[0];\\n            }\\n            else {\\n                throw notFoundError(id);\\n            }\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function makeGetEntries(query, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        const { withAllLocales } = options;\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateLocaleParam)(query, withAllLocales);\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateResolveLinksParam)(query);\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateRemoveUnresolvedParam)(query);\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        return internalGetEntries(withAllLocales\\n            ? {\\n                ...query,\\n                locale: '*',\\n            }\\n            : query, options);\\n    }\\n    async function internalGetEntries(query, options) {\\n        const { withoutLinkResolution, withoutUnresolvableLinks } = options;\\n        try {\\n            const entries = await get({\\n                context: 'environment',\\n                path: 'entries',\\n                config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query: (0,_utils_normalize_search_parameters__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"])((0,_utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"])(query)) }),\\n            });\\n            return (0,_utils_resolve_circular__WEBPACK_IMPORTED_MODULE_4__[\\\"default\\\"])(entries, {\\n                resolveLinks: !withoutLinkResolution ?? true,\\n                removeUnresolved: withoutUnresolvableLinks ?? false,\\n            });\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function getAsset(id, query = {}) {\\n        return makeGetAsset(id, query, options);\\n    }\\n    async function getAssets(query = {}) {\\n        return makeGetAssets(query, options);\\n    }\\n    async function makeGetAssets(query, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        const { withAllLocales } = options;\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateLocaleParam)(query, withAllLocales);\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        const localeSpecificQuery = withAllLocales ? { ...query, locale: '*' } : query;\\n        return internalGetAssets(localeSpecificQuery);\\n    }\\n    async function internalGetAsset(id, query) {\\n        try {\\n            return get({\\n                context: 'environment',\\n                path: `assets/${id}`,\\n                config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query: (0,_utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"])(query) }),\\n            });\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function makeGetAsset(id, query, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        const { withAllLocales } = options;\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateLocaleParam)(query, withAllLocales);\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        const localeSpecificQuery = withAllLocales ? { ...query, locale: '*' } : query;\\n        return internalGetAsset(id, localeSpecificQuery);\\n    }\\n    async function internalGetAssets(query) {\\n        try {\\n            return get({\\n                context: 'environment',\\n                path: 'assets',\\n                config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query: (0,_utils_normalize_search_parameters__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"])((0,_utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"])(query)) }),\\n            });\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n    }\\n    async function getTag(id) {\\n        return get({\\n            context: 'environment',\\n            path: `tags/${id}`,\\n        });\\n    }\\n    async function getTags(query = {}) {\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        return get({\\n            context: 'environment',\\n            path: 'tags',\\n            config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query: (0,_utils_normalize_search_parameters__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"])((0,_utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"])(query)) }),\\n        });\\n    }\\n    async function createAssetKey(expiresAt) {\\n        try {\\n            const now = Math.floor(Date.now() / 1000);\\n            const currentMaxLifetime = now + ASSET_KEY_MAX_LIFETIME;\\n            (0,_utils_validate_timestamp__WEBPACK_IMPORTED_MODULE_5__[\\\"default\\\"])('expiresAt', expiresAt, { maximum: currentMaxLifetime, now });\\n        }\\n        catch (error) {\\n            (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.errorHandler)(error);\\n        }\\n        return post({\\n            context: 'environment',\\n            path: 'asset_keys',\\n            data: { expiresAt },\\n        });\\n    }\\n    async function getLocales(query = {}) {\\n        (0,_utils_validate_search_parameters__WEBPACK_IMPORTED_MODULE_7__[\\\"default\\\"])(query);\\n        return get({\\n            context: 'environment',\\n            path: 'locales',\\n            config: (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_0__.createRequestConfig)({ query: (0,_utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__[\\\"default\\\"])(query) }),\\n        });\\n    }\\n    async function sync(query, syncOptions = { paginate: true }) {\\n        return makePagedSync(query, syncOptions, options);\\n    }\\n    async function makePagedSync(query, syncOptions, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateResolveLinksParam)(query);\\n        (0,_utils_validate_params__WEBPACK_IMPORTED_MODULE_6__.validateRemoveUnresolvedParam)(query);\\n        const combinedOptions = {\\n            ...syncOptions,\\n            ...options,\\n        };\\n        switchToEnvironment(http);\\n        return (0,_paged_sync__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"])(http, query, combinedOptions);\\n    }\\n    function parseEntries(data) {\\n        return makeParseEntries(data, options);\\n    }\\n    function makeParseEntries(data, options = {\\n        withAllLocales: false,\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n    }) {\\n        return internalParseEntries(data, options);\\n    }\\n    function internalParseEntries(data, options) {\\n        const { withoutLinkResolution, withoutUnresolvableLinks } = options;\\n        return (0,_utils_resolve_circular__WEBPACK_IMPORTED_MODULE_4__[\\\"default\\\"])(data, {\\n            resolveLinks: !withoutLinkResolution ?? true,\\n            removeUnresolved: withoutUnresolvableLinks ?? false,\\n        });\\n    }\\n    /*\\n     * Switches BaseURL to use /environments path\\n     * */\\n    function switchToEnvironment(http) {\\n        http.defaults.baseURL = getGlobalOptions().environmentBaseUrl;\\n    }\\n    return {\\n        version: \\\"10.1.0\\\",\\n        getSpace,\\n        getContentType,\\n        getContentTypes,\\n        getAsset,\\n        getAssets,\\n        getTag,\\n        getTags,\\n        getLocales,\\n        parseEntries,\\n        sync,\\n        getEntry,\\n        getEntries,\\n        createAssetKey,\\n    };\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./create-contentful-api.ts?\");\n\n/***/ }),\n\n/***/ \"./create-global-options.ts\":\n/*!**********************************!*\\\n  !*** ./create-global-options.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createGlobalOptions\\\": () => (/* binding */ createGlobalOptions)\\n/* harmony export */ });\\n/**\\n * @param globalSettings - Global library settings\\n * @returns getGlobalSettings - Method returning client settings\\n * @category Client\\n */\\nfunction createGlobalOptions(globalSettings) {\\n    /**\\n     * Method merging pre-configured global options and provided local parameters\\n     * @param query - regular query object used for collection endpoints\\n     * @param query.environment - optional name of the environment\\n     * @param query.space - optional space ID\\n     * @param query.spaceBaseUrl - optional base URL for the space\\n     * @param query.environmentBaseUrl - optional base URL for the environment\\n     * @returns global options\\n     */\\n    return function getGlobalOptions(query) {\\n        return Object.assign({}, globalSettings, query);\\n    };\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./create-global-options.ts?\");\n\n/***/ }),\n\n/***/ \"./index.ts\":\n/*!******************!*\\\n  !*** ./index.ts ***!\n  \\******************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"createClient\\\": () => (/* reexport safe */ _contentful__WEBPACK_IMPORTED_MODULE_0__.createClient),\\n/* harmony export */   \\\"createGlobalOptions\\\": () => (/* reexport safe */ _create_global_options__WEBPACK_IMPORTED_MODULE_1__.createGlobalOptions)\\n/* harmony export */ });\\n/* harmony import */ var _contentful__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./contentful */ \\\"./contentful.ts\\\");\\n/* harmony import */ var _create_global_options__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./create-global-options */ \\\"./create-global-options.ts\\\");\\n/* harmony import */ var _mixins_stringify_safe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/stringify-safe */ \\\"./mixins/stringify-safe.ts\\\");\\n/* harmony import */ var _utils_normalize_select__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./utils/normalize-select */ \\\"./utils/normalize-select.ts\\\");\\n/* harmony import */ var _utils_resolve_circular__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./utils/resolve-circular */ \\\"./utils/resolve-circular.ts\\\");\\n/* harmony import */ var _types__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./types */ \\\"./types/index.ts\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceURL=webpack://contentful/./index.ts?\");\n\n/***/ }),\n\n/***/ \"./make-client.ts\":\n/*!************************!*\\\n  !*** ./make-client.ts ***!\n  \\************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"makeClient\\\": () => (/* binding */ makeClient)\\n/* harmony export */ });\\n/* harmony import */ var _create_contentful_api__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./create-contentful-api */ \\\"./create-contentful-api.ts\\\");\\n\\nfunction create({ http, getGlobalOptions }, options, makeInnerClient) {\\n    const client = (0,_create_contentful_api__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])({\\n        http,\\n        getGlobalOptions,\\n    }, options);\\n    const response = client;\\n    Object.defineProperty(response, 'withAllLocales', {\\n        get: () => makeInnerClient({ ...options, withAllLocales: true }),\\n    });\\n    Object.defineProperty(response, 'withoutLinkResolution', {\\n        get: () => makeInnerClient({ ...options, withoutLinkResolution: true }),\\n    });\\n    Object.defineProperty(response, 'withoutUnresolvableLinks', {\\n        get: () => makeInnerClient({ ...options, withoutUnresolvableLinks: true }),\\n    });\\n    return Object.create(response);\\n}\\nconst makeClient = ({ http, getGlobalOptions, }) => {\\n    function makeInnerClient(options) {\\n        return create({ http, getGlobalOptions }, options, makeInnerClient);\\n    }\\n    const client = (0,_create_contentful_api__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])({ http, getGlobalOptions }, {\\n        withoutLinkResolution: false,\\n        withAllLocales: false,\\n        withoutUnresolvableLinks: false,\\n    });\\n    return {\\n        ...client,\\n        get withAllLocales() {\\n            return makeInnerClient({\\n                withAllLocales: true,\\n                withoutLinkResolution: false,\\n                withoutUnresolvableLinks: false,\\n            });\\n        },\\n        get withoutLinkResolution() {\\n            return makeInnerClient({\\n                withAllLocales: false,\\n                withoutLinkResolution: true,\\n                withoutUnresolvableLinks: false,\\n            });\\n        },\\n        get withoutUnresolvableLinks() {\\n            return makeInnerClient({\\n                withAllLocales: false,\\n                withoutLinkResolution: false,\\n                withoutUnresolvableLinks: true,\\n            });\\n        },\\n    };\\n};\\n\\n\\n//# sourceURL=webpack://contentful/./make-client.ts?\");\n\n/***/ }),\n\n/***/ \"./mixins/stringify-safe.ts\":\n/*!**********************************!*\\\n  !*** ./mixins/stringify-safe.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ mixinStringifySafe)\\n/* harmony export */ });\\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! json-stringify-safe */ \\\"../node_modules/json-stringify-safe/stringify.js\\\");\\n/* harmony import */ var json_stringify_safe__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(json_stringify_safe__WEBPACK_IMPORTED_MODULE_0__);\\n\\nfunction mixinStringifySafe(data) {\\n    return Object.defineProperty(data, 'stringifySafe', {\\n        enumerable: false,\\n        configurable: false,\\n        writable: false,\\n        value: function (serializer = null, indent = '') {\\n            return json_stringify_safe__WEBPACK_IMPORTED_MODULE_0___default()(this, serializer, indent, (key, value) => {\\n                return {\\n                    sys: {\\n                        type: 'Link',\\n                        linkType: 'Entry',\\n                        id: value.sys.id,\\n                        circular: true,\\n                    },\\n                };\\n            });\\n        },\\n    });\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./mixins/stringify-safe.ts?\");\n\n/***/ }),\n\n/***/ \"./paged-sync.ts\":\n/*!***********************!*\\\n  !*** ./paged-sync.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ pagedSync)\\n/* harmony export */ });\\n/* harmony import */ var contentful_resolve_response__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentful-resolve-response */ \\\"../node_modules/contentful-resolve-response/dist/esm/index.js\\\");\\n/* harmony import */ var contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! contentful-sdk-core */ \\\"../node_modules/contentful-sdk-core/dist/index.es-modules.js\\\");\\n/* harmony import */ var _mixins_stringify_safe__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./mixins/stringify-safe */ \\\"./mixins/stringify-safe.ts\\\");\\n\\n\\n\\n/**\\n * Retrieves all the available pages for a sync operation\\n */\\nasync function pagedSync(http, query, options) {\\n    if (!query || (!query.initial && !query.nextSyncToken && !query.nextPageToken)) {\\n        throw new Error('Please provide one of `initial`, `nextSyncToken` or `nextPageToken` parameters for syncing');\\n    }\\n    if (query['content_type'] && !query.type) {\\n        query.type = 'Entry';\\n    }\\n    else if (query['content_type'] && query.type && query.type !== 'Entry') {\\n        throw new Error('When using the `content_type` filter your `type` parameter cannot be different from `Entry`.');\\n    }\\n    const defaultOptions = {\\n        withoutLinkResolution: false,\\n        withoutUnresolvableLinks: false,\\n        paginate: true,\\n    };\\n    const { withoutLinkResolution, withoutUnresolvableLinks, paginate } = {\\n        ...defaultOptions,\\n        ...options,\\n    };\\n    const response = await getSyncPage(http, [], query, { paginate });\\n    // clones response.items used in includes because we don't want these to be mutated\\n    if (!withoutLinkResolution) {\\n        response.items = (0,contentful_resolve_response__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])(response, {\\n            removeUnresolved: withoutUnresolvableLinks,\\n            itemEntryPoints: ['fields'],\\n        });\\n    }\\n    // maps response items again after getters are attached\\n    const mappedResponseItems = mapResponseItems(response.items);\\n    if (response.nextSyncToken) {\\n        mappedResponseItems.nextSyncToken = response.nextSyncToken;\\n    }\\n    if (response.nextPageToken) {\\n        mappedResponseItems.nextPageToken = response.nextPageToken;\\n    }\\n    return (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.freezeSys)((0,_mixins_stringify_safe__WEBPACK_IMPORTED_MODULE_2__[\\\"default\\\"])((0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.toPlainObject)(mappedResponseItems)));\\n}\\n/**\\n * @private\\n * @param items\\n * @returns Entities mapped to an object for each entity type\\n */\\nfunction mapResponseItems(items) {\\n    const reducer = (type) => {\\n        return (accumulated, item) => {\\n            if (item.sys.type === type) {\\n                accumulated.push((0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.toPlainObject)(item));\\n            }\\n            return accumulated;\\n        };\\n    };\\n    return {\\n        entries: items.reduce(reducer('Entry'), []),\\n        assets: items.reduce(reducer('Asset'), []),\\n        deletedEntries: items.reduce(reducer('DeletedEntry'), []),\\n        deletedAssets: items.reduce(reducer('DeletedAsset'), []),\\n    };\\n}\\nfunction createRequestQuery(originalQuery) {\\n    if (originalQuery.nextPageToken) {\\n        return { sync_token: originalQuery.nextPageToken };\\n    }\\n    if (originalQuery.nextSyncToken) {\\n        return { sync_token: originalQuery.nextSyncToken };\\n    }\\n    if (originalQuery.sync_token) {\\n        return { sync_token: originalQuery.sync_token };\\n    }\\n    return originalQuery;\\n}\\n/**\\n * If the response contains a nextPageUrl, extracts the sync token to get the\\n * next page and calls itself again with that token.\\n * Otherwise, if the response contains a nextSyncUrl, extracts the sync token\\n * and returns it.\\n * On each call of this function, any retrieved items are collected in the\\n * supplied items array, which gets returned in the end.\\n */\\nasync function getSyncPage(http, items, query, { paginate }) {\\n    const requestQuery = createRequestQuery(query);\\n    const response = await http.get('sync', (0,contentful_sdk_core__WEBPACK_IMPORTED_MODULE_1__.createRequestConfig)({ query: requestQuery }));\\n    const data = response.data || {};\\n    items = items.concat(data.items || []);\\n    if (data.nextPageUrl) {\\n        if (paginate) {\\n            delete requestQuery.initial;\\n            requestQuery.sync_token = getToken(data.nextPageUrl);\\n            return getSyncPage(http, items, requestQuery, { paginate });\\n        }\\n        return {\\n            items,\\n            nextPageToken: getToken(data.nextPageUrl),\\n        };\\n    }\\n    else if (data.nextSyncUrl) {\\n        return {\\n            items,\\n            nextSyncToken: getToken(data.nextSyncUrl),\\n        };\\n    }\\n    else {\\n        return { items: [] };\\n    }\\n}\\n/**\\n * Extracts token out of an url\\n * @private\\n */\\nfunction getToken(url) {\\n    const urlParts = url.split('?');\\n    return urlParts.length > 0 ? urlParts[1].replace('sync_token=', '') : '';\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./paged-sync.ts?\");\n\n/***/ }),\n\n/***/ \"./types/asset-key.ts\":\n/*!****************************!*\\\n  !*** ./types/asset-key.ts ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/asset-key.ts?\");\n\n/***/ }),\n\n/***/ \"./types/asset.ts\":\n/*!************************!*\\\n  !*** ./types/asset.ts ***!\n  \\************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/asset.ts?\");\n\n/***/ }),\n\n/***/ \"./types/collection.ts\":\n/*!*****************************!*\\\n  !*** ./types/collection.ts ***!\n  \\*****************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/collection.ts?\");\n\n/***/ }),\n\n/***/ \"./types/content-type.ts\":\n/*!*******************************!*\\\n  !*** ./types/content-type.ts ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/content-type.ts?\");\n\n/***/ }),\n\n/***/ \"./types/entry.ts\":\n/*!************************!*\\\n  !*** ./types/entry.ts ***!\n  \\************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/entry.ts?\");\n\n/***/ }),\n\n/***/ \"./types/index.ts\":\n/*!************************!*\\\n  !*** ./types/index.ts ***!\n  \\************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _asset__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./asset */ \\\"./types/asset.ts\\\");\\n/* harmony import */ var _asset_key__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./asset-key */ \\\"./types/asset-key.ts\\\");\\n/* harmony import */ var _collection__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./collection */ \\\"./types/collection.ts\\\");\\n/* harmony import */ var _content_type__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./content-type */ \\\"./types/content-type.ts\\\");\\n/* harmony import */ var _entry__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./entry */ \\\"./types/entry.ts\\\");\\n/* harmony import */ var _link__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./link */ \\\"./types/link.ts\\\");\\n/* harmony import */ var _locale__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./locale */ \\\"./types/locale.ts\\\");\\n/* harmony import */ var _metadata__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./metadata */ \\\"./types/metadata.ts\\\");\\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./query */ \\\"./types/query/index.ts\\\");\\n/* harmony import */ var _resource_link__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./resource-link */ \\\"./types/resource-link.ts\\\");\\n/* harmony import */ var _space__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./space */ \\\"./types/space.ts\\\");\\n/* harmony import */ var _sync__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./sync */ \\\"./types/sync.ts\\\");\\n/* harmony import */ var _sys__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./sys */ \\\"./types/sys.ts\\\");\\n/* harmony import */ var _tag__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ./tag */ \\\"./types/tag.ts\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/index.ts?\");\n\n/***/ }),\n\n/***/ \"./types/link.ts\":\n/*!***********************!*\\\n  !*** ./types/link.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/link.ts?\");\n\n/***/ }),\n\n/***/ \"./types/locale.ts\":\n/*!*************************!*\\\n  !*** ./types/locale.ts ***!\n  \\*************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/locale.ts?\");\n\n/***/ }),\n\n/***/ \"./types/metadata.ts\":\n/*!***************************!*\\\n  !*** ./types/metadata.ts ***!\n  \\***************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/metadata.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/equality.ts\":\n/*!*********************************!*\\\n  !*** ./types/query/equality.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/equality.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/existence.ts\":\n/*!**********************************!*\\\n  !*** ./types/query/existence.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/existence.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/index.ts\":\n/*!******************************!*\\\n  !*** ./types/query/index.ts ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony import */ var _equality__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./equality */ \\\"./types/query/equality.ts\\\");\\n/* harmony import */ var _existence__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./existence */ \\\"./types/query/existence.ts\\\");\\n/* harmony import */ var _location__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./location */ \\\"./types/query/location.ts\\\");\\n/* harmony import */ var _order__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./order */ \\\"./types/query/order.ts\\\");\\n/* harmony import */ var _query__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./query */ \\\"./types/query/query.ts\\\");\\n/* harmony import */ var _range__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./range */ \\\"./types/query/range.ts\\\");\\n/* harmony import */ var _reference__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./reference */ \\\"./types/query/reference.ts\\\");\\n/* harmony import */ var _search__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./search */ \\\"./types/query/search.ts\\\");\\n/* harmony import */ var _select__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./select */ \\\"./types/query/select.ts\\\");\\n/* harmony import */ var _set__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./set */ \\\"./types/query/set.ts\\\");\\n/* harmony import */ var _subset__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./subset */ \\\"./types/query/subset.ts\\\");\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/index.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/location.ts\":\n/*!*********************************!*\\\n  !*** ./types/query/location.ts ***!\n  \\*********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/location.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/order.ts\":\n/*!******************************!*\\\n  !*** ./types/query/order.ts ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/order.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/query.ts\":\n/*!******************************!*\\\n  !*** ./types/query/query.ts ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/query.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/range.ts\":\n/*!******************************!*\\\n  !*** ./types/query/range.ts ***!\n  \\******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/range.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/reference.ts\":\n/*!**********************************!*\\\n  !*** ./types/query/reference.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/reference.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/search.ts\":\n/*!*******************************!*\\\n  !*** ./types/query/search.ts ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/search.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/select.ts\":\n/*!*******************************!*\\\n  !*** ./types/query/select.ts ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/select.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/set.ts\":\n/*!****************************!*\\\n  !*** ./types/query/set.ts ***!\n  \\****************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/set.ts?\");\n\n/***/ }),\n\n/***/ \"./types/query/subset.ts\":\n/*!*******************************!*\\\n  !*** ./types/query/subset.ts ***!\n  \\*******************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/query/subset.ts?\");\n\n/***/ }),\n\n/***/ \"./types/resource-link.ts\":\n/*!********************************!*\\\n  !*** ./types/resource-link.ts ***!\n  \\********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/resource-link.ts?\");\n\n/***/ }),\n\n/***/ \"./types/space.ts\":\n/*!************************!*\\\n  !*** ./types/space.ts ***!\n  \\************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/space.ts?\");\n\n/***/ }),\n\n/***/ \"./types/sync.ts\":\n/*!***********************!*\\\n  !*** ./types/sync.ts ***!\n  \\***********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/sync.ts?\");\n\n/***/ }),\n\n/***/ \"./types/sys.ts\":\n/*!**********************!*\\\n  !*** ./types/sys.ts ***!\n  \\**********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/sys.ts?\");\n\n/***/ }),\n\n/***/ \"./types/tag.ts\":\n/*!**********************!*\\\n  !*** ./types/tag.ts ***!\n  \\**********************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n\\n\\n\\n//# sourceURL=webpack://contentful/./types/tag.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/normalize-search-parameters.ts\":\n/*!**********************************************!*\\\n  !*** ./utils/normalize-search-parameters.ts ***!\n  \\**********************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ normalizeSearchParameters)\\n/* harmony export */ });\\nfunction normalizeSearchParameters(query) {\\n    const convertedQuery = {};\\n    let hasConverted = false;\\n    for (const key in query) {\\n        // We allow multiple values to be passed as arrays\\n        // which have to be converted to comma-separated strings before being sent to the API\\n        if (Array.isArray(query[key])) {\\n            convertedQuery[key] = query[key].join(',');\\n            hasConverted = true;\\n        }\\n    }\\n    if (hasConverted) {\\n        return { ...query, ...convertedQuery };\\n    }\\n    return query;\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/normalize-search-parameters.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/normalize-select.ts\":\n/*!***********************************!*\\\n  !*** ./utils/normalize-select.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ normalizeSelect)\\n/* harmony export */ });\\n/*\\n * sdk relies heavily on sys metadata\\n * so we cannot omit the sys property on sdk level entirely\\n * and we have to ensure that at least `id` and `type` are present\\n * */\\nfunction normalizeSelect(query) {\\n    if (!query.select) {\\n        return query;\\n    }\\n    // The selection of fields for the query is limited\\n    // Get the different parts that are listed for selection\\n    const allSelects = Array.isArray(query.select)\\n        ? query.select\\n        : query.select.split(',').map((q) => q.trim());\\n    // Move the parts into a set for easy access and deduplication\\n    const selectedSet = new Set(allSelects);\\n    // If we already select all of `sys` we can just return\\n    // since we're anyway fetching everything that is needed\\n    if (selectedSet.has('sys')) {\\n        return query;\\n    }\\n    // We don't select `sys` so we need to ensure the minimum set\\n    selectedSet.add('sys.id');\\n    selectedSet.add('sys.type');\\n    // Reassign the normalized sys properties\\n    return {\\n        ...query,\\n        select: [...selectedSet].join(','),\\n    };\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/normalize-select.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/resolve-circular.ts\":\n/*!***********************************!*\\\n  !*** ./utils/resolve-circular.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ resolveCircular)\\n/* harmony export */ });\\n/* harmony import */ var _mixins_stringify_safe__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../mixins/stringify-safe */ \\\"./mixins/stringify-safe.ts\\\");\\n/* harmony import */ var contentful_resolve_response__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! contentful-resolve-response */ \\\"../node_modules/contentful-resolve-response/dist/esm/index.js\\\");\\n\\n\\nfunction resolveCircular(data, { resolveLinks, removeUnresolved }) {\\n    const wrappedData = (0,_mixins_stringify_safe__WEBPACK_IMPORTED_MODULE_0__[\\\"default\\\"])(data);\\n    if (resolveLinks) {\\n        wrappedData.items = (0,contentful_resolve_response__WEBPACK_IMPORTED_MODULE_1__[\\\"default\\\"])(wrappedData, {\\n            removeUnresolved,\\n            itemEntryPoints: ['fields'],\\n        });\\n    }\\n    return wrappedData;\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/resolve-circular.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/validate-params.ts\":\n/*!**********************************!*\\\n  !*** ./utils/validate-params.ts ***!\n  \\**********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"validateLocaleParam\\\": () => (/* binding */ validateLocaleParam),\\n/* harmony export */   \\\"validateRemoveUnresolvedParam\\\": () => (/* binding */ validateRemoveUnresolvedParam),\\n/* harmony export */   \\\"validateResolveLinksParam\\\": () => (/* binding */ validateResolveLinksParam)\\n/* harmony export */ });\\n/* harmony import */ var _validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validation-error */ \\\"./utils/validation-error.ts\\\");\\n\\nfunction checkLocaleParamIsAll(query) {\\n    if (query.locale === '*') {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError('locale', `The use of locale='*' is no longer supported.To fetch an entry in all existing locales, \\n      use client.withAllLocales instead of the locale='*' parameter.`);\\n    }\\n}\\nfunction checkLocaleParamExists(query) {\\n    if (query.locale) {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError('locale', 'The `locale` parameter is not allowed');\\n    }\\n}\\nfunction validateLocaleParam(query, isWithAllLocalesClient) {\\n    if (isWithAllLocalesClient) {\\n        checkLocaleParamExists(query);\\n    }\\n    else {\\n        checkLocaleParamIsAll(query);\\n    }\\n    return;\\n}\\nfunction validateResolveLinksParam(query) {\\n    if ('resolveLinks' in query) {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError('resolveLinks', `The use of the 'resolveLinks' parameter is no longer supported. By default, links are resolved. \\n      If you do not want to resolve links, use client.withoutLinkResolution.`);\\n    }\\n    return;\\n}\\nfunction validateRemoveUnresolvedParam(query) {\\n    if ('removeUnresolved' in query) {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError('removeUnresolved', `The use of the 'removeUnresolved' parameter is no longer supported. By default, unresolved links are kept as link objects.\\n      If you do not want to include unresolved links, use client.withoutUnresolvableLinks.`);\\n    }\\n    return;\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/validate-params.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/validate-search-parameters.ts\":\n/*!*********************************************!*\\\n  !*** ./utils/validate-search-parameters.ts ***!\n  \\*********************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ validateSearchParameters)\\n/* harmony export */ });\\nfunction validateSearchParameters(query) {\\n    for (const key in query) {\\n        const value = query[key];\\n        // We dont allow any objects as values for query parameters\\n        if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\\n            throw new Error(`Objects are not supported as value for the \\\"${key}\\\" query parameter.`);\\n        }\\n    }\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/validate-search-parameters.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/validate-timestamp.ts\":\n/*!*************************************!*\\\n  !*** ./utils/validate-timestamp.ts ***!\n  \\*************************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"default\\\": () => (/* binding */ validateTimestamp)\\n/* harmony export */ });\\n/* harmony import */ var _validation_error__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./validation-error */ \\\"./utils/validation-error.ts\\\");\\n\\nfunction validateTimestamp(name, timestamp, options) {\\n    options = options || {};\\n    if (typeof timestamp !== 'number') {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError(name, `only numeric values are allowed for timestamps, provided type was \\\"${typeof timestamp}\\\"`);\\n    }\\n    if (options.maximum && timestamp > options.maximum) {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError(name, `value (${timestamp}) cannot be further in the future than expected maximum (${options.maximum})`);\\n    }\\n    if (options.now && timestamp < options.now) {\\n        throw new _validation_error__WEBPACK_IMPORTED_MODULE_0__.ValidationError(name, `value (${timestamp}) cannot be in the past, current time was ${options.now}`);\\n    }\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/validate-timestamp.ts?\");\n\n/***/ }),\n\n/***/ \"./utils/validation-error.ts\":\n/*!***********************************!*\\\n  !*** ./utils/validation-error.ts ***!\n  \\***********************************/\n/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {\n\n\"use strict\";\neval(\"__webpack_require__.r(__webpack_exports__);\\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\\n/* harmony export */   \\\"ValidationError\\\": () => (/* binding */ ValidationError)\\n/* harmony export */ });\\nclass ValidationError extends Error {\\n    constructor(name, message) {\\n        super(`Invalid \\\"${name}\\\" provided, ` + message);\\n        this.name = 'ValidationError';\\n    }\\n}\\n\\n\\n//# sourceURL=webpack://contentful/./utils/validation-error.ts?\");\n\n/***/ }),\n\n/***/ \"?d91c\":\n/*!********************************!*\\\n  !*** ./util.inspect (ignored) ***!\n  \\********************************/\n/***/ (() => {\n\neval(\"/* (ignored) */\\n\\n//# sourceURL=webpack://contentful/./util.inspect_(ignored)?\");\n\n/***/ })\n\n/******/ \t});\n/************************************************************************/\n/******/ \t// The module cache\n/******/ \tvar __webpack_module_cache__ = {};\n/******/ \t\n/******/ \t// The require function\n/******/ \tfunction __nested_webpack_require_261831__(moduleId) {\n/******/ \t\t// Check if module is in cache\n/******/ \t\tvar cachedModule = __webpack_module_cache__[moduleId];\n/******/ \t\tif (cachedModule !== undefined) {\n/******/ \t\t\treturn cachedModule.exports;\n/******/ \t\t}\n/******/ \t\t// Create a new module (and put it into the cache)\n/******/ \t\tvar module = __webpack_module_cache__[moduleId] = {\n/******/ \t\t\t// no module.id needed\n/******/ \t\t\t// no module.loaded needed\n/******/ \t\t\texports: {}\n/******/ \t\t};\n/******/ \t\n/******/ \t\t// Execute the module function\n/******/ \t\t__webpack_modules__[moduleId].call(module.exports, module, module.exports, __nested_webpack_require_261831__);\n/******/ \t\n/******/ \t\t// Return the exports of the module\n/******/ \t\treturn module.exports;\n/******/ \t}\n/******/ \t\n/************************************************************************/\n/******/ \t/* webpack/runtime/compat get default export */\n/******/ \t(() => {\n/******/ \t\t// getDefaultExport function for compatibility with non-harmony modules\n/******/ \t\t__nested_webpack_require_261831__.n = (module) => {\n/******/ \t\t\tvar getter = module && module.__esModule ?\n/******/ \t\t\t\t() => (module['default']) :\n/******/ \t\t\t\t() => (module);\n/******/ \t\t\t__nested_webpack_require_261831__.d(getter, { a: getter });\n/******/ \t\t\treturn getter;\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/define property getters */\n/******/ \t(() => {\n/******/ \t\t// define getter functions for harmony exports\n/******/ \t\t__nested_webpack_require_261831__.d = (exports, definition) => {\n/******/ \t\t\tfor(var key in definition) {\n/******/ \t\t\t\tif(__nested_webpack_require_261831__.o(definition, key) && !__nested_webpack_require_261831__.o(exports, key)) {\n/******/ \t\t\t\t\tObject.defineProperty(exports, key, { enumerable: true, get: definition[key] });\n/******/ \t\t\t\t}\n/******/ \t\t\t}\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/global */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_261831__.g = (function() {\n/******/ \t\t\tif (typeof globalThis === 'object') return globalThis;\n/******/ \t\t\ttry {\n/******/ \t\t\t\treturn this || new Function('return this')();\n/******/ \t\t\t} catch (e) {\n/******/ \t\t\t\tif (typeof window === 'object') return window;\n/******/ \t\t\t}\n/******/ \t\t})();\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/hasOwnProperty shorthand */\n/******/ \t(() => {\n/******/ \t\t__nested_webpack_require_261831__.o = (obj, prop) => (Object.prototype.hasOwnProperty.call(obj, prop))\n/******/ \t})();\n/******/ \t\n/******/ \t/* webpack/runtime/make namespace object */\n/******/ \t(() => {\n/******/ \t\t// define __esModule on exports\n/******/ \t\t__nested_webpack_require_261831__.r = (exports) => {\n/******/ \t\t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n/******/ \t\t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n/******/ \t\t\t}\n/******/ \t\t\tObject.defineProperty(exports, '__esModule', { value: true });\n/******/ \t\t};\n/******/ \t})();\n/******/ \t\n/************************************************************************/\n/******/ \t\n/******/ \t// startup\n/******/ \t// Load entry module and return exports\n/******/ \t// This entry module can't be inlined because the eval devtool is used.\n/******/ \tvar __webpack_exports__ = __nested_webpack_require_261831__(\"./index.ts\");\n/******/ \t\n/******/ \treturn __webpack_exports__;\n/******/ })()\n;\n});//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvY29udGVudGZ1bC9kaXN0L2NvbnRlbnRmdWwuYnJvd3Nlci5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJLElBQXlEO0FBQzdEO0FBQ0EsTUFBTSxFQUsyQjtBQUNqQyxDQUFDO0FBQ0QseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsc0dBQXNHOztBQUV0RyxPQUFPOztBQUVQO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxvR0FBb0cseUdBQXlHLGtIQUFrSCxxSEFBcUgsNEhBQTRILGlJQUFpSSwwSUFBMEksc0hBQXNILHlJQUF5SSwyR0FBMkcsa0RBQWtELHFFQUFxRSxvQ0FBb0MsMENBQTBDLDZDQUE2QyxxQkFBcUIsdUJBQXVCLGlDQUFpQyxxREFBcUQsU0FBUyw4QkFBOEIsaUVBQWlFLFNBQVMsT0FBTyw0Q0FBNEMsK0NBQStDLGdDQUFnQywyQ0FBMkMsNERBQTRELGtEQUFrRCxzR0FBc0csa0ZBQWtGLE9BQU8saUVBQWlFLGtIQUFrSCwrRUFBK0UsOEJBQThCLHVCQUF1QixpQkFBaUIsU0FBUyx1SkFBdUosbUpBQW1KLHdCQUF3Qix1TUFBdU0sMkNBQTJDLHlCQUF5QixpQkFBaUIsU0FBUyx5QkFBeUIsc0JBQXNCLGlCQUFpQixTQUFTLFlBQVksb0RBQW9ELE9BQU8scUNBQXFDLDJFQUEyRSxRQUFRLE1BQU0sa0hBQWtILHFEQUFxRCxtQkFBbUIsV0FBVyxnWUFBZ1ksbUJBQW1CLFdBQVcsMktBQTJLLFVBQVUsT0FBTyxvSUFBb0ksdUJBQXVCLGlCQUFpQixTQUFTLGtGQUFrRixvREFBb0QsUUFBUSwwRkFBMEYsdUxBQXVMLG9EQUFvRCxRQUFRLDZFQUE2RSx1SEFBdUgsdUVBQXVFLHlDQUF5QywyREFBMkQsU0FBUyx3S0FBd0ssb0RBQW9ELFFBQVEsK01BQStNLHFNQUFxTSwwQkFBMEIsNERBQTRE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QTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0EsZ0JBQWdCLGlDQUFtQix3QkFBd0IsaUNBQW1CO0FBQzlFLG9EQUFvRCx3Q0FBd0M7QUFDNUY7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQTtBQUNBLFdBQVcsaUNBQW1CO0FBQzlCO0FBQ0E7QUFDQTtBQUNBLGNBQWM7QUFDZDtBQUNBO0FBQ0EsWUFBWTtBQUNaLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QixXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLGlDQUFtQjtBQUM5QjtBQUNBLGtFQUFrRSxpQkFBaUI7QUFDbkY7QUFDQSwyREFBMkQsYUFBYTtBQUN4RTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0MsaUNBQW1CO0FBQ3ZEO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9jb250ZW50ZnVsL2Rpc3QvY29udGVudGZ1bC5icm93c2VyLmpzPzQyYmEiXSwic291cmNlc0NvbnRlbnQiOlsiLypcbiAqIEFUVEVOVElPTjogVGhlIFwiZXZhbFwiIGRldnRvb2wgaGFzIGJlZW4gdXNlZCAobWF5YmUgYnkgZGVmYXVsdCBpbiBtb2RlOiBcImRldmVsb3BtZW50XCIpLlxuICogVGhpcyBkZXZ0b29sIGlzIG5laXRoZXIgbWFkZSBmb3IgcHJvZHVjdGlvbiBub3IgZm9yIHJlYWRhYmxlIG91dHB1dCBmaWxlcy5cbiAqIEl0IHVzZXMgXCJldmFsKClcIiBjYWxscyB0byBjcmVhdGUgYSBzZXBhcmF0ZSBzb3VyY2UgZmlsZSBpbiB0aGUgYnJvd3NlciBkZXZ0b29scy5cbiAqIElmIHlvdSBhcmUgdHJ5aW5nIHRvIHJlYWQgdGhlIG91dHB1dCBmaWxlLCBzZWxlY3QgYSBkaWZmZXJlbnQgZGV2dG9vbCAoaHR0cHM6Ly93ZWJwYWNrLmpzLm9yZy9jb25maWd1cmF0aW9uL2RldnRvb2wvKVxuICogb3IgZGlzYWJsZSB0aGUgZGVmYXVsdCBkZXZ0b29sIHdpdGggXCJkZXZ0b29sOiBmYWxzZVwiLlxuICogSWYgeW91IGFyZSBsb29raW5nIGZvciBwcm9kdWN0aW9uLXJlYWR5IG91dHB1dCBmaWxlcywgc2VlIG1vZGU6IFwicHJvZHVjdGlvblwiIChodHRwczovL3dlYnBhY2suanMub3JnL2NvbmZpZ3VyYXRpb24vbW9kZS8pLlxuICovXG4oZnVuY3Rpb24gd2VicGFja1VuaXZlcnNhbE1vZHVsZURlZmluaXRpb24ocm9vdCwgZmFjdG9yeSkge1xuXHRpZih0eXBlb2YgZXhwb3J0cyA9PT0gJ29iamVjdCcgJiYgdHlwZW9mIG1vZHVsZSA9PT0gJ29iamVjdCcpXG5cdFx0bW9kdWxlLmV4cG9ydHMgPSBmYWN0b3J5KCk7XG5cdGVsc2UgaWYodHlwZW9mIGRlZmluZSA9PT0gJ2Z1bmN0aW9uJyAmJiBkZWZpbmUuYW1kKVxuXHRcdGRlZmluZShbXSwgZmFjdG9yeSk7XG5cdGVsc2UgaWYodHlwZW9mIGV4cG9ydHMgPT09ICdvYmplY3QnKVxuXHRcdGV4cG9ydHNbXCJjb250ZW50ZnVsXCJdID0gZmFjdG9yeSgpO1xuXHRlbHNlXG5cdFx0cm9vdFtcImNvbnRlbnRmdWxcIl0gPSBmYWN0b3J5KCk7XG59KShnbG9iYWxUaGlzLCAoKSA9PiB7XG5yZXR1cm4gLyoqKioqKi8gKCgpID0+IHsgLy8gd2VicGFja0Jvb3RzdHJhcFxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX21vZHVsZXNfXyA9ICh7XG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpYi9heGlvcyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qc1xcXCIpO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vdXRpbHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcXFwiKTtcXG52YXIgc2V0dGxlID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9jb3JlL3NldHRsZSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qc1xcXCIpO1xcbnZhciBjb29raWVzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9oZWxwZXJzL2Nvb2tpZXMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzXFxcIik7XFxudmFyIGJ1aWxkVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9oZWxwZXJzL2J1aWxkVVJMICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanNcXFwiKTtcXG52YXIgYnVpbGRGdWxsUGF0aCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NvcmUvYnVpbGRGdWxsUGF0aCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanNcXFwiKTtcXG52YXIgcGFyc2VIZWFkZXJzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi9oZWxwZXJzL3BhcnNlSGVhZGVycyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3BhcnNlSGVhZGVycy5qc1xcXCIpO1xcbnZhciBpc1VSTFNhbWVPcmlnaW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzXFxcIik7XFxudmFyIGNyZWF0ZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY29yZS9jcmVhdGVFcnJvciAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzXFxcIik7XFxudmFyIHRyYW5zaXRpb25hbERlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVmYXVsdHMvdHJhbnNpdGlvbmFsICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qc1xcXCIpO1xcbnZhciBDYW5jZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jYW5jZWwvQ2FuY2VsICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHhockFkYXB0ZXIoY29uZmlnKSB7XFxuICByZXR1cm4gbmV3IFByb21pc2UoZnVuY3Rpb24gZGlzcGF0Y2hYaHJSZXF1ZXN0KHJlc29sdmUsIHJlamVjdCkge1xcbiAgICB2YXIgcmVxdWVzdERhdGEgPSBjb25maWcuZGF0YTtcXG4gICAgdmFyIHJlcXVlc3RIZWFkZXJzID0gY29uZmlnLmhlYWRlcnM7XFxuICAgIHZhciByZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xcbiAgICB2YXIgb25DYW5jZWxlZDtcXG4gICAgZnVuY3Rpb24gZG9uZSgpIHtcXG4gICAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuKSB7XFxuICAgICAgICBjb25maWcuY2FuY2VsVG9rZW4udW5zdWJzY3JpYmUob25DYW5jZWxlZCk7XFxuICAgICAgfVxcblxcbiAgICAgIGlmIChjb25maWcuc2lnbmFsKSB7XFxuICAgICAgICBjb25maWcuc2lnbmFsLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2Fib3J0Jywgb25DYW5jZWxlZCk7XFxuICAgICAgfVxcbiAgICB9XFxuXFxuICAgIGlmICh1dGlscy5pc0Zvcm1EYXRhKHJlcXVlc3REYXRhKSkge1xcbiAgICAgIGRlbGV0ZSByZXF1ZXN0SGVhZGVyc1snQ29udGVudC1UeXBlJ107IC8vIExldCB0aGUgYnJvd3NlciBzZXQgaXRcXG4gICAgfVxcblxcbiAgICB2YXIgcmVxdWVzdCA9IG5ldyBYTUxIdHRwUmVxdWVzdCgpO1xcblxcbiAgICAvLyBIVFRQIGJhc2ljIGF1dGhlbnRpY2F0aW9uXFxuICAgIGlmIChjb25maWcuYXV0aCkge1xcbiAgICAgIHZhciB1c2VybmFtZSA9IGNvbmZpZy5hdXRoLnVzZXJuYW1lIHx8ICcnO1xcbiAgICAgIHZhciBwYXNzd29yZCA9IGNvbmZpZy5hdXRoLnBhc3N3b3JkID8gdW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZy5hdXRoLnBhc3N3b3JkKSkgOiAnJztcXG4gICAgICByZXF1ZXN0SGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0Jhc2ljICcgKyBidG9hKHVzZXJuYW1lICsgJzonICsgcGFzc3dvcmQpO1xcbiAgICB9XFxuXFxuICAgIHZhciBmdWxsUGF0aCA9IGJ1aWxkRnVsbFBhdGgoY29uZmlnLmJhc2VVUkwsIGNvbmZpZy51cmwpO1xcbiAgICByZXF1ZXN0Lm9wZW4oY29uZmlnLm1ldGhvZC50b1VwcGVyQ2FzZSgpLCBidWlsZFVSTChmdWxsUGF0aCwgY29uZmlnLnBhcmFtcywgY29uZmlnLnBhcmFtc1NlcmlhbGl6ZXIpLCB0cnVlKTtcXG5cXG4gICAgLy8gU2V0IHRoZSByZXF1ZXN0IHRpbWVvdXQgaW4gTVNcXG4gICAgcmVxdWVzdC50aW1lb3V0ID0gY29uZmlnLnRpbWVvdXQ7XFxuXFxuICAgIGZ1bmN0aW9uIG9ubG9hZGVuZCgpIHtcXG4gICAgICBpZiAoIXJlcXVlc3QpIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgLy8gUHJlcGFyZSB0aGUgcmVzcG9uc2VcXG4gICAgICB2YXIgcmVzcG9uc2VIZWFkZXJzID0gJ2dldEFsbFJlc3BvbnNlSGVhZGVycycgaW4gcmVxdWVzdCA/IHBhcnNlSGVhZGVycyhyZXF1ZXN0LmdldEFsbFJlc3BvbnNlSGVhZGVycygpKSA6IG51bGw7XFxuICAgICAgdmFyIHJlc3BvbnNlRGF0YSA9ICFyZXNwb25zZVR5cGUgfHwgcmVzcG9uc2VUeXBlID09PSAndGV4dCcgfHwgIHJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nID9cXG4gICAgICAgIHJlcXVlc3QucmVzcG9uc2VUZXh0IDogcmVxdWVzdC5yZXNwb25zZTtcXG4gICAgICB2YXIgcmVzcG9uc2UgPSB7XFxuICAgICAgICBkYXRhOiByZXNwb25zZURhdGEsXFxuICAgICAgICBzdGF0dXM6IHJlcXVlc3Quc3RhdHVzLFxcbiAgICAgICAgc3RhdHVzVGV4dDogcmVxdWVzdC5zdGF0dXNUZXh0LFxcbiAgICAgICAgaGVhZGVyczogcmVzcG9uc2VIZWFkZXJzLFxcbiAgICAgICAgY29uZmlnOiBjb25maWcsXFxuICAgICAgICByZXF1ZXN0OiByZXF1ZXN0XFxuICAgICAgfTtcXG5cXG4gICAgICBzZXR0bGUoZnVuY3Rpb24gX3Jlc29sdmUodmFsdWUpIHtcXG4gICAgICAgIHJlc29sdmUodmFsdWUpO1xcbiAgICAgICAgZG9uZSgpO1xcbiAgICAgIH0sIGZ1bmN0aW9uIF9yZWplY3QoZXJyKSB7XFxuICAgICAgICByZWplY3QoZXJyKTtcXG4gICAgICAgIGRvbmUoKTtcXG4gICAgICB9LCByZXNwb25zZSk7XFxuXFxuICAgICAgLy8gQ2xlYW4gdXAgcmVxdWVzdFxcbiAgICAgIHJlcXVlc3QgPSBudWxsO1xcbiAgICB9XFxuXFxuICAgIGlmICgnb25sb2FkZW5kJyBpbiByZXF1ZXN0KSB7XFxuICAgICAgLy8gVXNlIG9ubG9hZGVuZCBpZiBhdmFpbGFibGVcXG4gICAgICByZXF1ZXN0Lm9ubG9hZGVuZCA9IG9ubG9hZGVuZDtcXG4gICAgfSBlbHNlIHtcXG4gICAgICAvLyBMaXN0ZW4gZm9yIHJlYWR5IHN0YXRlIHRvIGVtdWxhdGUgb25sb2FkZW5kXFxuICAgICAgcmVxdWVzdC5vbnJlYWR5c3RhdGVjaGFuZ2UgPSBmdW5jdGlvbiBoYW5kbGVMb2FkKCkge1xcbiAgICAgICAgaWYgKCFyZXF1ZXN0IHx8IHJlcXVlc3QucmVhZHlTdGF0ZSAhPT0gNCkge1xcbiAgICAgICAgICByZXR1cm47XFxuICAgICAgICB9XFxuXFxuICAgICAgICAvLyBUaGUgcmVxdWVzdCBlcnJvcmVkIG91dCBhbmQgd2UgZGlkbid0IGdldCBhIHJlc3BvbnNlLCB0aGlzIHdpbGwgYmVcXG4gICAgICAgIC8vIGhhbmRsZWQgYnkgb25lcnJvciBpbnN0ZWFkXFxuICAgICAgICAvLyBXaXRoIG9uZSBleGNlcHRpb246IHJlcXVlc3QgdGhhdCB1c2luZyBmaWxlOiBwcm90b2NvbCwgbW9zdCBicm93c2Vyc1xcbiAgICAgICAgLy8gd2lsbCByZXR1cm4gc3RhdHVzIGFzIDAgZXZlbiB0aG91Z2ggaXQncyBhIHN1Y2Nlc3NmdWwgcmVxdWVzdFxcbiAgICAgICAgaWYgKHJlcXVlc3Quc3RhdHVzID09PSAwICYmICEocmVxdWVzdC5yZXNwb25zZVVSTCAmJiByZXF1ZXN0LnJlc3BvbnNlVVJMLmluZGV4T2YoJ2ZpbGU6JykgPT09IDApKSB7XFxuICAgICAgICAgIHJldHVybjtcXG4gICAgICAgIH1cXG4gICAgICAgIC8vIHJlYWR5c3RhdGUgaGFuZGxlciBpcyBjYWxsaW5nIGJlZm9yZSBvbmVycm9yIG9yIG9udGltZW91dCBoYW5kbGVycyxcXG4gICAgICAgIC8vIHNvIHdlIHNob3VsZCBjYWxsIG9ubG9hZGVuZCBvbiB0aGUgbmV4dCAndGljaydcXG4gICAgICAgIHNldFRpbWVvdXQob25sb2FkZW5kKTtcXG4gICAgICB9O1xcbiAgICB9XFxuXFxuICAgIC8vIEhhbmRsZSBicm93c2VyIHJlcXVlc3QgY2FuY2VsbGF0aW9uIChhcyBvcHBvc2VkIHRvIGEgbWFudWFsIGNhbmNlbGxhdGlvbilcXG4gICAgcmVxdWVzdC5vbmFib3J0ID0gZnVuY3Rpb24gaGFuZGxlQWJvcnQoKSB7XFxuICAgICAgaWYgKCFyZXF1ZXN0KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgICAgfVxcblxcbiAgICAgIHJlamVjdChjcmVhdGVFcnJvcignUmVxdWVzdCBhYm9ydGVkJywgY29uZmlnLCAnRUNPTk5BQk9SVEVEJywgcmVxdWVzdCkpO1xcblxcbiAgICAgIC8vIENsZWFuIHVwIHJlcXVlc3RcXG4gICAgICByZXF1ZXN0ID0gbnVsbDtcXG4gICAgfTtcXG5cXG4gICAgLy8gSGFuZGxlIGxvdyBsZXZlbCBuZXR3b3JrIGVycm9yc1xcbiAgICByZXF1ZXN0Lm9uZXJyb3IgPSBmdW5jdGlvbiBoYW5kbGVFcnJvcigpIHtcXG4gICAgICAvLyBSZWFsIGVycm9ycyBhcmUgaGlkZGVuIGZyb20gdXMgYnkgdGhlIGJyb3dzZXJcXG4gICAgICAvLyBvbmVycm9yIHNob3VsZCBvbmx5IGZpcmUgaWYgaXQncyBhIG5ldHdvcmsgZXJyb3JcXG4gICAgICByZWplY3QoY3JlYXRlRXJyb3IoJ05ldHdvcmsgRXJyb3InLCBjb25maWcsIG51bGwsIHJlcXVlc3QpKTtcXG5cXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XFxuICAgICAgcmVxdWVzdCA9IG51bGw7XFxuICAgIH07XFxuXFxuICAgIC8vIEhhbmRsZSB0aW1lb3V0XFxuICAgIHJlcXVlc3Qub250aW1lb3V0ID0gZnVuY3Rpb24gaGFuZGxlVGltZW91dCgpIHtcXG4gICAgICB2YXIgdGltZW91dEVycm9yTWVzc2FnZSA9IGNvbmZpZy50aW1lb3V0ID8gJ3RpbWVvdXQgb2YgJyArIGNvbmZpZy50aW1lb3V0ICsgJ21zIGV4Y2VlZGVkJyA6ICd0aW1lb3V0IGV4Y2VlZGVkJztcXG4gICAgICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbCB8fCB0cmFuc2l0aW9uYWxEZWZhdWx0cztcXG4gICAgICBpZiAoY29uZmlnLnRpbWVvdXRFcnJvck1lc3NhZ2UpIHtcXG4gICAgICAgIHRpbWVvdXRFcnJvck1lc3NhZ2UgPSBjb25maWcudGltZW91dEVycm9yTWVzc2FnZTtcXG4gICAgICB9XFxuICAgICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxcbiAgICAgICAgdGltZW91dEVycm9yTWVzc2FnZSxcXG4gICAgICAgIGNvbmZpZyxcXG4gICAgICAgIHRyYW5zaXRpb25hbC5jbGFyaWZ5VGltZW91dEVycm9yID8gJ0VUSU1FRE9VVCcgOiAnRUNPTk5BQk9SVEVEJyxcXG4gICAgICAgIHJlcXVlc3QpKTtcXG5cXG4gICAgICAvLyBDbGVhbiB1cCByZXF1ZXN0XFxuICAgICAgcmVxdWVzdCA9IG51bGw7XFxuICAgIH07XFxuXFxuICAgIC8vIEFkZCB4c3JmIGhlYWRlclxcbiAgICAvLyBUaGlzIGlzIG9ubHkgZG9uZSBpZiBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudC5cXG4gICAgLy8gU3BlY2lmaWNhbGx5IG5vdCBpZiB3ZSdyZSBpbiBhIHdlYiB3b3JrZXIsIG9yIHJlYWN0LW5hdGl2ZS5cXG4gICAgaWYgKHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkpIHtcXG4gICAgICAvLyBBZGQgeHNyZiBoZWFkZXJcXG4gICAgICB2YXIgeHNyZlZhbHVlID0gKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMgfHwgaXNVUkxTYW1lT3JpZ2luKGZ1bGxQYXRoKSkgJiYgY29uZmlnLnhzcmZDb29raWVOYW1lID9cXG4gICAgICAgIGNvb2tpZXMucmVhZChjb25maWcueHNyZkNvb2tpZU5hbWUpIDpcXG4gICAgICAgIHVuZGVmaW5lZDtcXG5cXG4gICAgICBpZiAoeHNyZlZhbHVlKSB7XFxuICAgICAgICByZXF1ZXN0SGVhZGVyc1tjb25maWcueHNyZkhlYWRlck5hbWVdID0geHNyZlZhbHVlO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICAvLyBBZGQgaGVhZGVycyB0byB0aGUgcmVxdWVzdFxcbiAgICBpZiAoJ3NldFJlcXVlc3RIZWFkZXInIGluIHJlcXVlc3QpIHtcXG4gICAgICB1dGlscy5mb3JFYWNoKHJlcXVlc3RIZWFkZXJzLCBmdW5jdGlvbiBzZXRSZXF1ZXN0SGVhZGVyKHZhbCwga2V5KSB7XFxuICAgICAgICBpZiAodHlwZW9mIHJlcXVlc3REYXRhID09PSAndW5kZWZpbmVkJyAmJiBrZXkudG9Mb3dlckNhc2UoKSA9PT0gJ2NvbnRlbnQtdHlwZScpIHtcXG4gICAgICAgICAgLy8gUmVtb3ZlIENvbnRlbnQtVHlwZSBpZiBkYXRhIGlzIHVuZGVmaW5lZFxcbiAgICAgICAgICBkZWxldGUgcmVxdWVzdEhlYWRlcnNba2V5XTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgIC8vIE90aGVyd2lzZSBhZGQgaGVhZGVyIHRvIHRoZSByZXF1ZXN0XFxuICAgICAgICAgIHJlcXVlc3Quc2V0UmVxdWVzdEhlYWRlcihrZXksIHZhbCk7XFxuICAgICAgICB9XFxuICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgLy8gQWRkIHdpdGhDcmVkZW50aWFscyB0byByZXF1ZXN0IGlmIG5lZWRlZFxcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZy53aXRoQ3JlZGVudGlhbHMpKSB7XFxuICAgICAgcmVxdWVzdC53aXRoQ3JlZGVudGlhbHMgPSAhIWNvbmZpZy53aXRoQ3JlZGVudGlhbHM7XFxuICAgIH1cXG5cXG4gICAgLy8gQWRkIHJlc3BvbnNlVHlwZSB0byByZXF1ZXN0IGlmIG5lZWRlZFxcbiAgICBpZiAocmVzcG9uc2VUeXBlICYmIHJlc3BvbnNlVHlwZSAhPT0gJ2pzb24nKSB7XFxuICAgICAgcmVxdWVzdC5yZXNwb25zZVR5cGUgPSBjb25maWcucmVzcG9uc2VUeXBlO1xcbiAgICB9XFxuXFxuICAgIC8vIEhhbmRsZSBwcm9ncmVzcyBpZiBuZWVkZWRcXG4gICAgaWYgKHR5cGVvZiBjb25maWcub25Eb3dubG9hZFByb2dyZXNzID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgcmVxdWVzdC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vbkRvd25sb2FkUHJvZ3Jlc3MpO1xcbiAgICB9XFxuXFxuICAgIC8vIE5vdCBhbGwgYnJvd3NlcnMgc3VwcG9ydCB1cGxvYWQgZXZlbnRzXFxuICAgIGlmICh0eXBlb2YgY29uZmlnLm9uVXBsb2FkUHJvZ3Jlc3MgPT09ICdmdW5jdGlvbicgJiYgcmVxdWVzdC51cGxvYWQpIHtcXG4gICAgICByZXF1ZXN0LnVwbG9hZC5hZGRFdmVudExpc3RlbmVyKCdwcm9ncmVzcycsIGNvbmZpZy5vblVwbG9hZFByb2dyZXNzKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY29uZmlnLmNhbmNlbFRva2VuIHx8IGNvbmZpZy5zaWduYWwpIHtcXG4gICAgICAvLyBIYW5kbGUgY2FuY2VsbGF0aW9uXFxuICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gICAgICBvbkNhbmNlbGVkID0gZnVuY3Rpb24oY2FuY2VsKSB7XFxuICAgICAgICBpZiAoIXJlcXVlc3QpIHtcXG4gICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmVqZWN0KCFjYW5jZWwgfHwgKGNhbmNlbCAmJiBjYW5jZWwudHlwZSkgPyBuZXcgQ2FuY2VsKCdjYW5jZWxlZCcpIDogY2FuY2VsKTtcXG4gICAgICAgIHJlcXVlc3QuYWJvcnQoKTtcXG4gICAgICAgIHJlcXVlc3QgPSBudWxsO1xcbiAgICAgIH07XFxuXFxuICAgICAgY29uZmlnLmNhbmNlbFRva2VuICYmIGNvbmZpZy5jYW5jZWxUb2tlbi5zdWJzY3JpYmUob25DYW5jZWxlZCk7XFxuICAgICAgaWYgKGNvbmZpZy5zaWduYWwpIHtcXG4gICAgICAgIGNvbmZpZy5zaWduYWwuYWJvcnRlZCA/IG9uQ2FuY2VsZWQoKSA6IGNvbmZpZy5zaWduYWwuYWRkRXZlbnRMaXN0ZW5lcignYWJvcnQnLCBvbkNhbmNlbGVkKTtcXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKCFyZXF1ZXN0RGF0YSkge1xcbiAgICAgIHJlcXVlc3REYXRhID0gbnVsbDtcXG4gICAgfVxcblxcbiAgICAvLyBTZW5kIHRoZSByZXF1ZXN0XFxuICAgIHJlcXVlc3Quc2VuZChyZXF1ZXN0RGF0YSk7XFxuICB9KTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9heGlvcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvYmluZCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanNcXFwiKTtcXG52YXIgQXhpb3MgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvcmUvQXhpb3MgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qc1xcXCIpO1xcbnZhciBtZXJnZUNvbmZpZyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29yZS9tZXJnZUNvbmZpZyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzXFxcIik7XFxudmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kZWZhdWx0cyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBhbiBpbnN0YW5jZSBvZiBBeGlvc1xcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IGRlZmF1bHRDb25maWcgVGhlIGRlZmF1bHQgY29uZmlnIGZvciB0aGUgaW5zdGFuY2VcXG4gKiBAcmV0dXJuIHtBeGlvc30gQSBuZXcgaW5zdGFuY2Ugb2YgQXhpb3NcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVJbnN0YW5jZShkZWZhdWx0Q29uZmlnKSB7XFxuICB2YXIgY29udGV4dCA9IG5ldyBBeGlvcyhkZWZhdWx0Q29uZmlnKTtcXG4gIHZhciBpbnN0YW5jZSA9IGJpbmQoQXhpb3MucHJvdG90eXBlLnJlcXVlc3QsIGNvbnRleHQpO1xcblxcbiAgLy8gQ29weSBheGlvcy5wcm90b3R5cGUgdG8gaW5zdGFuY2VcXG4gIHV0aWxzLmV4dGVuZChpbnN0YW5jZSwgQXhpb3MucHJvdG90eXBlLCBjb250ZXh0KTtcXG5cXG4gIC8vIENvcHkgY29udGV4dCB0byBpbnN0YW5jZVxcbiAgdXRpbHMuZXh0ZW5kKGluc3RhbmNlLCBjb250ZXh0KTtcXG5cXG4gIC8vIEZhY3RvcnkgZm9yIGNyZWF0aW5nIG5ldyBpbnN0YW5jZXNcXG4gIGluc3RhbmNlLmNyZWF0ZSA9IGZ1bmN0aW9uIGNyZWF0ZShpbnN0YW5jZUNvbmZpZykge1xcbiAgICByZXR1cm4gY3JlYXRlSW5zdGFuY2UobWVyZ2VDb25maWcoZGVmYXVsdENvbmZpZywgaW5zdGFuY2VDb25maWcpKTtcXG4gIH07XFxuXFxuICByZXR1cm4gaW5zdGFuY2U7XFxufVxcblxcbi8vIENyZWF0ZSB0aGUgZGVmYXVsdCBpbnN0YW5jZSB0byBiZSBleHBvcnRlZFxcbnZhciBheGlvcyA9IGNyZWF0ZUluc3RhbmNlKGRlZmF1bHRzKTtcXG5cXG4vLyBFeHBvc2UgQXhpb3MgY2xhc3MgdG8gYWxsb3cgY2xhc3MgaW5oZXJpdGFuY2VcXG5heGlvcy5BeGlvcyA9IEF4aW9zO1xcblxcbi8vIEV4cG9zZSBDYW5jZWwgJiBDYW5jZWxUb2tlblxcbmF4aW9zLkNhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2FuY2VsL0NhbmNlbCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXFxcIik7XFxuYXhpb3MuQ2FuY2VsVG9rZW4gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NhbmNlbC9DYW5jZWxUb2tlbiAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanNcXFwiKTtcXG5heGlvcy5pc0NhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY2FuY2VsL2lzQ2FuY2VsICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1xcXCIpO1xcbmF4aW9zLlZFUlNJT04gPSAoX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lbnYvZGF0YSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qc1xcXCIpLnZlcnNpb24pO1xcblxcbi8vIEV4cG9zZSBhbGwvc3ByZWFkXFxuYXhpb3MuYWxsID0gZnVuY3Rpb24gYWxsKHByb21pc2VzKSB7XFxuICByZXR1cm4gUHJvbWlzZS5hbGwocHJvbWlzZXMpO1xcbn07XFxuYXhpb3Muc3ByZWFkID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9oZWxwZXJzL3NwcmVhZCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qc1xcXCIpO1xcblxcbi8vIEV4cG9zZSBpc0F4aW9zRXJyb3JcXG5heGlvcy5pc0F4aW9zRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvaXNBeGlvc0Vycm9yICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBeGlvc0Vycm9yLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBheGlvcztcXG5cXG4vLyBBbGxvdyB1c2Ugb2YgZGVmYXVsdCBpbXBvcnQgc3ludGF4IGluIFR5cGVTY3JpcHRcXG5tb2R1bGUuZXhwb3J0c1tcXFwiZGVmYXVsdFxcXCJdID0gYXhpb3M7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2F4aW9zLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9DYW5jZWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuLyoqXFxuICogQSBgQ2FuY2VsYCBpcyBhbiBvYmplY3QgdGhhdCBpcyB0aHJvd24gd2hlbiBhbiBvcGVyYXRpb24gaXMgY2FuY2VsZWQuXFxuICpcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge3N0cmluZz19IG1lc3NhZ2UgVGhlIG1lc3NhZ2UuXFxuICovXFxuZnVuY3Rpb24gQ2FuY2VsKG1lc3NhZ2UpIHtcXG4gIHRoaXMubWVzc2FnZSA9IG1lc3NhZ2U7XFxufVxcblxcbkNhbmNlbC5wcm90b3R5cGUudG9TdHJpbmcgPSBmdW5jdGlvbiB0b1N0cmluZygpIHtcXG4gIHJldHVybiAnQ2FuY2VsJyArICh0aGlzLm1lc3NhZ2UgPyAnOiAnICsgdGhpcy5tZXNzYWdlIDogJycpO1xcbn07XFxuXFxuQ2FuY2VsLnByb3RvdHlwZS5fX0NBTkNFTF9fID0gdHJ1ZTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbDtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbFRva2VuLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9DYW5jZWwgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIEEgYENhbmNlbFRva2VuYCBpcyBhbiBvYmplY3QgdGhhdCBjYW4gYmUgdXNlZCB0byByZXF1ZXN0IGNhbmNlbGxhdGlvbiBvZiBhbiBvcGVyYXRpb24uXFxuICpcXG4gKiBAY2xhc3NcXG4gKiBAcGFyYW0ge0Z1bmN0aW9ufSBleGVjdXRvciBUaGUgZXhlY3V0b3IgZnVuY3Rpb24uXFxuICovXFxuZnVuY3Rpb24gQ2FuY2VsVG9rZW4oZXhlY3V0b3IpIHtcXG4gIGlmICh0eXBlb2YgZXhlY3V0b3IgIT09ICdmdW5jdGlvbicpIHtcXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcignZXhlY3V0b3IgbXVzdCBiZSBhIGZ1bmN0aW9uLicpO1xcbiAgfVxcblxcbiAgdmFyIHJlc29sdmVQcm9taXNlO1xcblxcbiAgdGhpcy5wcm9taXNlID0gbmV3IFByb21pc2UoZnVuY3Rpb24gcHJvbWlzZUV4ZWN1dG9yKHJlc29sdmUpIHtcXG4gICAgcmVzb2x2ZVByb21pc2UgPSByZXNvbHZlO1xcbiAgfSk7XFxuXFxuICB2YXIgdG9rZW4gPSB0aGlzO1xcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gIHRoaXMucHJvbWlzZS50aGVuKGZ1bmN0aW9uKGNhbmNlbCkge1xcbiAgICBpZiAoIXRva2VuLl9saXN0ZW5lcnMpIHJldHVybjtcXG5cXG4gICAgdmFyIGk7XFxuICAgIHZhciBsID0gdG9rZW4uX2xpc3RlbmVycy5sZW5ndGg7XFxuXFxuICAgIGZvciAoaSA9IDA7IGkgPCBsOyBpKyspIHtcXG4gICAgICB0b2tlbi5fbGlzdGVuZXJzW2ldKGNhbmNlbCk7XFxuICAgIH1cXG4gICAgdG9rZW4uX2xpc3RlbmVycyA9IG51bGw7XFxuICB9KTtcXG5cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBmdW5jLW5hbWVzXFxuICB0aGlzLnByb21pc2UudGhlbiA9IGZ1bmN0aW9uKG9uZnVsZmlsbGVkKSB7XFxuICAgIHZhciBfcmVzb2x2ZTtcXG4gICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gICAgdmFyIHByb21pc2UgPSBuZXcgUHJvbWlzZShmdW5jdGlvbihyZXNvbHZlKSB7XFxuICAgICAgdG9rZW4uc3Vic2NyaWJlKHJlc29sdmUpO1xcbiAgICAgIF9yZXNvbHZlID0gcmVzb2x2ZTtcXG4gICAgfSkudGhlbihvbmZ1bGZpbGxlZCk7XFxuXFxuICAgIHByb21pc2UuY2FuY2VsID0gZnVuY3Rpb24gcmVqZWN0KCkge1xcbiAgICAgIHRva2VuLnVuc3Vic2NyaWJlKF9yZXNvbHZlKTtcXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIHByb21pc2U7XFxuICB9O1xcblxcbiAgZXhlY3V0b3IoZnVuY3Rpb24gY2FuY2VsKG1lc3NhZ2UpIHtcXG4gICAgaWYgKHRva2VuLnJlYXNvbikge1xcbiAgICAgIC8vIENhbmNlbGxhdGlvbiBoYXMgYWxyZWFkeSBiZWVuIHJlcXVlc3RlZFxcbiAgICAgIHJldHVybjtcXG4gICAgfVxcblxcbiAgICB0b2tlbi5yZWFzb24gPSBuZXcgQ2FuY2VsKG1lc3NhZ2UpO1xcbiAgICByZXNvbHZlUHJvbWlzZSh0b2tlbi5yZWFzb24pO1xcbiAgfSk7XFxufVxcblxcbi8qKlxcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXFxuICovXFxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnRocm93SWZSZXF1ZXN0ZWQgPSBmdW5jdGlvbiB0aHJvd0lmUmVxdWVzdGVkKCkge1xcbiAgaWYgKHRoaXMucmVhc29uKSB7XFxuICAgIHRocm93IHRoaXMucmVhc29uO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogU3Vic2NyaWJlIHRvIHRoZSBjYW5jZWwgc2lnbmFsXFxuICovXFxuXFxuQ2FuY2VsVG9rZW4ucHJvdG90eXBlLnN1YnNjcmliZSA9IGZ1bmN0aW9uIHN1YnNjcmliZShsaXN0ZW5lcikge1xcbiAgaWYgKHRoaXMucmVhc29uKSB7XFxuICAgIGxpc3RlbmVyKHRoaXMucmVhc29uKTtcXG4gICAgcmV0dXJuO1xcbiAgfVxcblxcbiAgaWYgKHRoaXMuX2xpc3RlbmVycykge1xcbiAgICB0aGlzLl9saXN0ZW5lcnMucHVzaChsaXN0ZW5lcik7XFxuICB9IGVsc2Uge1xcbiAgICB0aGlzLl9saXN0ZW5lcnMgPSBbbGlzdGVuZXJdO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogVW5zdWJzY3JpYmUgZnJvbSB0aGUgY2FuY2VsIHNpZ25hbFxcbiAqL1xcblxcbkNhbmNlbFRva2VuLnByb3RvdHlwZS51bnN1YnNjcmliZSA9IGZ1bmN0aW9uIHVuc3Vic2NyaWJlKGxpc3RlbmVyKSB7XFxuICBpZiAoIXRoaXMuX2xpc3RlbmVycykge1xcbiAgICByZXR1cm47XFxuICB9XFxuICB2YXIgaW5kZXggPSB0aGlzLl9saXN0ZW5lcnMuaW5kZXhPZihsaXN0ZW5lcik7XFxuICBpZiAoaW5kZXggIT09IC0xKSB7XFxuICAgIHRoaXMuX2xpc3RlbmVycy5zcGxpY2UoaW5kZXgsIDEpO1xcbiAgfVxcbn07XFxuXFxuLyoqXFxuICogUmV0dXJucyBhbiBvYmplY3QgdGhhdCBjb250YWlucyBhIG5ldyBgQ2FuY2VsVG9rZW5gIGFuZCBhIGZ1bmN0aW9uIHRoYXQsIHdoZW4gY2FsbGVkLFxcbiAqIGNhbmNlbHMgdGhlIGBDYW5jZWxUb2tlbmAuXFxuICovXFxuQ2FuY2VsVG9rZW4uc291cmNlID0gZnVuY3Rpb24gc291cmNlKCkge1xcbiAgdmFyIGNhbmNlbDtcXG4gIHZhciB0b2tlbiA9IG5ldyBDYW5jZWxUb2tlbihmdW5jdGlvbiBleGVjdXRvcihjKSB7XFxuICAgIGNhbmNlbCA9IGM7XFxuICB9KTtcXG4gIHJldHVybiB7XFxuICAgIHRva2VuOiB0b2tlbixcXG4gICAgY2FuY2VsOiBjYW5jZWxcXG4gIH07XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IENhbmNlbFRva2VuO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvQ2FuY2VsVG9rZW4uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNDYW5jZWwodmFsdWUpIHtcXG4gIHJldHVybiAhISh2YWx1ZSAmJiB2YWx1ZS5fX0NBTkNFTF9fKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jYW5jZWwvaXNDYW5jZWwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvQXhpb3MuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9BeGlvcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vdXRpbHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcXFwiKTtcXG52YXIgYnVpbGRVUkwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9oZWxwZXJzL2J1aWxkVVJMICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanNcXFwiKTtcXG52YXIgSW50ZXJjZXB0b3JNYW5hZ2VyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9JbnRlcmNlcHRvck1hbmFnZXIgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanNcXFwiKTtcXG52YXIgZGlzcGF0Y2hSZXF1ZXN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9kaXNwYXRjaFJlcXVlc3QgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9kaXNwYXRjaFJlcXVlc3QuanNcXFwiKTtcXG52YXIgbWVyZ2VDb25maWcgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21lcmdlQ29uZmlnICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanNcXFwiKTtcXG52YXIgdmFsaWRhdG9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy92YWxpZGF0b3IgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy92YWxpZGF0b3IuanNcXFwiKTtcXG5cXG52YXIgdmFsaWRhdG9ycyA9IHZhbGlkYXRvci52YWxpZGF0b3JzO1xcbi8qKlxcbiAqIENyZWF0ZSBhIG5ldyBpbnN0YW5jZSBvZiBBeGlvc1xcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IGluc3RhbmNlQ29uZmlnIFRoZSBkZWZhdWx0IGNvbmZpZyBmb3IgdGhlIGluc3RhbmNlXFxuICovXFxuZnVuY3Rpb24gQXhpb3MoaW5zdGFuY2VDb25maWcpIHtcXG4gIHRoaXMuZGVmYXVsdHMgPSBpbnN0YW5jZUNvbmZpZztcXG4gIHRoaXMuaW50ZXJjZXB0b3JzID0ge1xcbiAgICByZXF1ZXN0OiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKCksXFxuICAgIHJlc3BvbnNlOiBuZXcgSW50ZXJjZXB0b3JNYW5hZ2VyKClcXG4gIH07XFxufVxcblxcbi8qKlxcbiAqIERpc3BhdGNoIGEgcmVxdWVzdFxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHNwZWNpZmljIGZvciB0aGlzIHJlcXVlc3QgKG1lcmdlZCB3aXRoIHRoaXMuZGVmYXVsdHMpXFxuICovXFxuQXhpb3MucHJvdG90eXBlLnJlcXVlc3QgPSBmdW5jdGlvbiByZXF1ZXN0KGNvbmZpZ09yVXJsLCBjb25maWcpIHtcXG4gIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xcbiAgLy8gQWxsb3cgZm9yIGF4aW9zKCdleGFtcGxlL3VybCdbLCBjb25maWddKSBhIGxhIGZldGNoIEFQSVxcbiAgaWYgKHR5cGVvZiBjb25maWdPclVybCA9PT0gJ3N0cmluZycpIHtcXG4gICAgY29uZmlnID0gY29uZmlnIHx8IHt9O1xcbiAgICBjb25maWcudXJsID0gY29uZmlnT3JVcmw7XFxuICB9IGVsc2Uge1xcbiAgICBjb25maWcgPSBjb25maWdPclVybCB8fCB7fTtcXG4gIH1cXG5cXG4gIGNvbmZpZyA9IG1lcmdlQ29uZmlnKHRoaXMuZGVmYXVsdHMsIGNvbmZpZyk7XFxuXFxuICAvLyBTZXQgY29uZmlnLm1ldGhvZFxcbiAgaWYgKGNvbmZpZy5tZXRob2QpIHtcXG4gICAgY29uZmlnLm1ldGhvZCA9IGNvbmZpZy5tZXRob2QudG9Mb3dlckNhc2UoKTtcXG4gIH0gZWxzZSBpZiAodGhpcy5kZWZhdWx0cy5tZXRob2QpIHtcXG4gICAgY29uZmlnLm1ldGhvZCA9IHRoaXMuZGVmYXVsdHMubWV0aG9kLnRvTG93ZXJDYXNlKCk7XFxuICB9IGVsc2Uge1xcbiAgICBjb25maWcubWV0aG9kID0gJ2dldCc7XFxuICB9XFxuXFxuICB2YXIgdHJhbnNpdGlvbmFsID0gY29uZmlnLnRyYW5zaXRpb25hbDtcXG5cXG4gIGlmICh0cmFuc2l0aW9uYWwgIT09IHVuZGVmaW5lZCkge1xcbiAgICB2YWxpZGF0b3IuYXNzZXJ0T3B0aW9ucyh0cmFuc2l0aW9uYWwsIHtcXG4gICAgICBzaWxlbnRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcXG4gICAgICBmb3JjZWRKU09OUGFyc2luZzogdmFsaWRhdG9ycy50cmFuc2l0aW9uYWwodmFsaWRhdG9ycy5ib29sZWFuKSxcXG4gICAgICBjbGFyaWZ5VGltZW91dEVycm9yOiB2YWxpZGF0b3JzLnRyYW5zaXRpb25hbCh2YWxpZGF0b3JzLmJvb2xlYW4pXFxuICAgIH0sIGZhbHNlKTtcXG4gIH1cXG5cXG4gIC8vIGZpbHRlciBvdXQgc2tpcHBlZCBpbnRlcmNlcHRvcnNcXG4gIHZhciByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbiA9IFtdO1xcbiAgdmFyIHN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycyA9IHRydWU7XFxuICB0aGlzLmludGVyY2VwdG9ycy5yZXF1ZXN0LmZvckVhY2goZnVuY3Rpb24gdW5zaGlmdFJlcXVlc3RJbnRlcmNlcHRvcnMoaW50ZXJjZXB0b3IpIHtcXG4gICAgaWYgKHR5cGVvZiBpbnRlcmNlcHRvci5ydW5XaGVuID09PSAnZnVuY3Rpb24nICYmIGludGVyY2VwdG9yLnJ1bldoZW4oY29uZmlnKSA9PT0gZmFsc2UpIHtcXG4gICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzID0gc3luY2hyb25vdXNSZXF1ZXN0SW50ZXJjZXB0b3JzICYmIGludGVyY2VwdG9yLnN5bmNocm9ub3VzO1xcblxcbiAgICByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi51bnNoaWZ0KGludGVyY2VwdG9yLmZ1bGZpbGxlZCwgaW50ZXJjZXB0b3IucmVqZWN0ZWQpO1xcbiAgfSk7XFxuXFxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvckNoYWluID0gW107XFxuICB0aGlzLmludGVyY2VwdG9ycy5yZXNwb25zZS5mb3JFYWNoKGZ1bmN0aW9uIHB1c2hSZXNwb25zZUludGVyY2VwdG9ycyhpbnRlcmNlcHRvcikge1xcbiAgICByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4ucHVzaChpbnRlcmNlcHRvci5mdWxmaWxsZWQsIGludGVyY2VwdG9yLnJlamVjdGVkKTtcXG4gIH0pO1xcblxcbiAgdmFyIHByb21pc2U7XFxuXFxuICBpZiAoIXN5bmNocm9ub3VzUmVxdWVzdEludGVyY2VwdG9ycykge1xcbiAgICB2YXIgY2hhaW4gPSBbZGlzcGF0Y2hSZXF1ZXN0LCB1bmRlZmluZWRdO1xcblxcbiAgICBBcnJheS5wcm90b3R5cGUudW5zaGlmdC5hcHBseShjaGFpbiwgcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4pO1xcbiAgICBjaGFpbiA9IGNoYWluLmNvbmNhdChyZXNwb25zZUludGVyY2VwdG9yQ2hhaW4pO1xcblxcbiAgICBwcm9taXNlID0gUHJvbWlzZS5yZXNvbHZlKGNvbmZpZyk7XFxuICAgIHdoaWxlIChjaGFpbi5sZW5ndGgpIHtcXG4gICAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKGNoYWluLnNoaWZ0KCksIGNoYWluLnNoaWZ0KCkpO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBwcm9taXNlO1xcbiAgfVxcblxcblxcbiAgdmFyIG5ld0NvbmZpZyA9IGNvbmZpZztcXG4gIHdoaWxlIChyZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5sZW5ndGgpIHtcXG4gICAgdmFyIG9uRnVsZmlsbGVkID0gcmVxdWVzdEludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKTtcXG4gICAgdmFyIG9uUmVqZWN0ZWQgPSByZXF1ZXN0SW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpO1xcbiAgICB0cnkge1xcbiAgICAgIG5ld0NvbmZpZyA9IG9uRnVsZmlsbGVkKG5ld0NvbmZpZyk7XFxuICAgIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgb25SZWplY3RlZChlcnJvcik7XFxuICAgICAgYnJlYWs7XFxuICAgIH1cXG4gIH1cXG5cXG4gIHRyeSB7XFxuICAgIHByb21pc2UgPSBkaXNwYXRjaFJlcXVlc3QobmV3Q29uZmlnKTtcXG4gIH0gY2F0Y2ggKGVycm9yKSB7XFxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XFxuICB9XFxuXFxuICB3aGlsZSAocmVzcG9uc2VJbnRlcmNlcHRvckNoYWluLmxlbmd0aCkge1xcbiAgICBwcm9taXNlID0gcHJvbWlzZS50aGVuKHJlc3BvbnNlSW50ZXJjZXB0b3JDaGFpbi5zaGlmdCgpLCByZXNwb25zZUludGVyY2VwdG9yQ2hhaW4uc2hpZnQoKSk7XFxuICB9XFxuXFxuICByZXR1cm4gcHJvbWlzZTtcXG59O1xcblxcbkF4aW9zLnByb3RvdHlwZS5nZXRVcmkgPSBmdW5jdGlvbiBnZXRVcmkoY29uZmlnKSB7XFxuICBjb25maWcgPSBtZXJnZUNvbmZpZyh0aGlzLmRlZmF1bHRzLCBjb25maWcpO1xcbiAgcmV0dXJuIGJ1aWxkVVJMKGNvbmZpZy51cmwsIGNvbmZpZy5wYXJhbXMsIGNvbmZpZy5wYXJhbXNTZXJpYWxpemVyKS5yZXBsYWNlKC9eXFxcXD8vLCAnJyk7XFxufTtcXG5cXG4vLyBQcm92aWRlIGFsaWFzZXMgZm9yIHN1cHBvcnRlZCByZXF1ZXN0IG1ldGhvZHNcXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJywgJ29wdGlvbnMnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZE5vRGF0YShtZXRob2QpIHtcXG4gIC8qZXNsaW50IGZ1bmMtbmFtZXM6MCovXFxuICBBeGlvcy5wcm90b3R5cGVbbWV0aG9kXSA9IGZ1bmN0aW9uKHVybCwgY29uZmlnKSB7XFxuICAgIHJldHVybiB0aGlzLnJlcXVlc3QobWVyZ2VDb25maWcoY29uZmlnIHx8IHt9LCB7XFxuICAgICAgbWV0aG9kOiBtZXRob2QsXFxuICAgICAgdXJsOiB1cmwsXFxuICAgICAgZGF0YTogKGNvbmZpZyB8fCB7fSkuZGF0YVxcbiAgICB9KSk7XFxuICB9O1xcbn0pO1xcblxcbnV0aWxzLmZvckVhY2goWydwb3N0JywgJ3B1dCcsICdwYXRjaCddLCBmdW5jdGlvbiBmb3JFYWNoTWV0aG9kV2l0aERhdGEobWV0aG9kKSB7XFxuICAvKmVzbGludCBmdW5jLW5hbWVzOjAqL1xcbiAgQXhpb3MucHJvdG90eXBlW21ldGhvZF0gPSBmdW5jdGlvbih1cmwsIGRhdGEsIGNvbmZpZykge1xcbiAgICByZXR1cm4gdGhpcy5yZXF1ZXN0KG1lcmdlQ29uZmlnKGNvbmZpZyB8fCB7fSwge1xcbiAgICAgIG1ldGhvZDogbWV0aG9kLFxcbiAgICAgIHVybDogdXJsLFxcbiAgICAgIGRhdGE6IGRhdGFcXG4gICAgfSkpO1xcbiAgfTtcXG59KTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEF4aW9zO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0F4aW9zLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL0ludGVyY2VwdG9yTWFuYWdlci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9JbnRlcmNlcHRvck1hbmFnZXIuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi91dGlscyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qc1xcXCIpO1xcblxcbmZ1bmN0aW9uIEludGVyY2VwdG9yTWFuYWdlcigpIHtcXG4gIHRoaXMuaGFuZGxlcnMgPSBbXTtcXG59XFxuXFxuLyoqXFxuICogQWRkIGEgbmV3IGludGVyY2VwdG9yIHRvIHRoZSBzdGFja1xcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gZnVsZmlsbGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHRoZW5gIGZvciBhIGBQcm9taXNlYFxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdGVkIFRoZSBmdW5jdGlvbiB0byBoYW5kbGUgYHJlamVjdGAgZm9yIGEgYFByb21pc2VgXFxuICpcXG4gKiBAcmV0dXJuIHtOdW1iZXJ9IEFuIElEIHVzZWQgdG8gcmVtb3ZlIGludGVyY2VwdG9yIGxhdGVyXFxuICovXFxuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS51c2UgPSBmdW5jdGlvbiB1c2UoZnVsZmlsbGVkLCByZWplY3RlZCwgb3B0aW9ucykge1xcbiAgdGhpcy5oYW5kbGVycy5wdXNoKHtcXG4gICAgZnVsZmlsbGVkOiBmdWxmaWxsZWQsXFxuICAgIHJlamVjdGVkOiByZWplY3RlZCxcXG4gICAgc3luY2hyb25vdXM6IG9wdGlvbnMgPyBvcHRpb25zLnN5bmNocm9ub3VzIDogZmFsc2UsXFxuICAgIHJ1bldoZW46IG9wdGlvbnMgPyBvcHRpb25zLnJ1bldoZW4gOiBudWxsXFxuICB9KTtcXG4gIHJldHVybiB0aGlzLmhhbmRsZXJzLmxlbmd0aCAtIDE7XFxufTtcXG5cXG4vKipcXG4gKiBSZW1vdmUgYW4gaW50ZXJjZXB0b3IgZnJvbSB0aGUgc3RhY2tcXG4gKlxcbiAqIEBwYXJhbSB7TnVtYmVyfSBpZCBUaGUgSUQgdGhhdCB3YXMgcmV0dXJuZWQgYnkgYHVzZWBcXG4gKi9cXG5JbnRlcmNlcHRvck1hbmFnZXIucHJvdG90eXBlLmVqZWN0ID0gZnVuY3Rpb24gZWplY3QoaWQpIHtcXG4gIGlmICh0aGlzLmhhbmRsZXJzW2lkXSkge1xcbiAgICB0aGlzLmhhbmRsZXJzW2lkXSA9IG51bGw7XFxuICB9XFxufTtcXG5cXG4vKipcXG4gKiBJdGVyYXRlIG92ZXIgYWxsIHRoZSByZWdpc3RlcmVkIGludGVyY2VwdG9yc1xcbiAqXFxuICogVGhpcyBtZXRob2QgaXMgcGFydGljdWxhcmx5IHVzZWZ1bCBmb3Igc2tpcHBpbmcgb3ZlciBhbnlcXG4gKiBpbnRlcmNlcHRvcnMgdGhhdCBtYXkgaGF2ZSBiZWNvbWUgYG51bGxgIGNhbGxpbmcgYGVqZWN0YC5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBmdW5jdGlvbiB0byBjYWxsIGZvciBlYWNoIGludGVyY2VwdG9yXFxuICovXFxuSW50ZXJjZXB0b3JNYW5hZ2VyLnByb3RvdHlwZS5mb3JFYWNoID0gZnVuY3Rpb24gZm9yRWFjaChmbikge1xcbiAgdXRpbHMuZm9yRWFjaCh0aGlzLmhhbmRsZXJzLCBmdW5jdGlvbiBmb3JFYWNoSGFuZGxlcihoKSB7XFxuICAgIGlmIChoICE9PSBudWxsKSB7XFxuICAgICAgZm4oaCk7XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBJbnRlcmNlcHRvck1hbmFnZXI7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvSW50ZXJjZXB0b3JNYW5hZ2VyLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2J1aWxkRnVsbFBhdGguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciBpc0Fic29sdXRlVVJMID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9pc0Fic29sdXRlVVJMICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNBYnNvbHV0ZVVSTC5qc1xcXCIpO1xcbnZhciBjb21iaW5lVVJMcyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2hlbHBlcnMvY29tYmluZVVSTHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBuZXcgVVJMIGJ5IGNvbWJpbmluZyB0aGUgYmFzZVVSTCB3aXRoIHRoZSByZXF1ZXN0ZWRVUkwsXFxuICogb25seSB3aGVuIHRoZSByZXF1ZXN0ZWRVUkwgaXMgbm90IGFscmVhZHkgYW4gYWJzb2x1dGUgVVJMLlxcbiAqIElmIHRoZSByZXF1ZXN0VVJMIGlzIGFic29sdXRlLCB0aGlzIGZ1bmN0aW9uIHJldHVybnMgdGhlIHJlcXVlc3RlZFVSTCB1bnRvdWNoZWQuXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVxdWVzdGVkVVJMIEFic29sdXRlIG9yIHJlbGF0aXZlIFVSTCB0byBjb21iaW5lXFxuICogQHJldHVybnMge3N0cmluZ30gVGhlIGNvbWJpbmVkIGZ1bGwgcGF0aFxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYnVpbGRGdWxsUGF0aChiYXNlVVJMLCByZXF1ZXN0ZWRVUkwpIHtcXG4gIGlmIChiYXNlVVJMICYmICFpc0Fic29sdXRlVVJMKHJlcXVlc3RlZFVSTCkpIHtcXG4gICAgcmV0dXJuIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlcXVlc3RlZFVSTCk7XFxuICB9XFxuICByZXR1cm4gcmVxdWVzdGVkVVJMO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvYnVpbGRGdWxsUGF0aC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9jcmVhdGVFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGVuaGFuY2VFcnJvciA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vZW5oYW5jZUVycm9yICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzXFxcIik7XFxuXFxuLyoqXFxuICogQ3JlYXRlIGFuIEVycm9yIHdpdGggdGhlIHNwZWNpZmllZCBtZXNzYWdlLCBjb25maWcsIGVycm9yIGNvZGUsIHJlcXVlc3QgYW5kIHJlc3BvbnNlLlxcbiAqXFxuICogQHBhcmFtIHtzdHJpbmd9IG1lc3NhZ2UgVGhlIGVycm9yIG1lc3NhZ2UuXFxuICogQHBhcmFtIHtPYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnLlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBbY29kZV0gVGhlIGVycm9yIGNvZGUgKGZvciBleGFtcGxlLCAnRUNPTk5BQk9SVEVEJykuXFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXF1ZXN0XSBUaGUgcmVxdWVzdC5cXG4gKiBAcGFyYW0ge09iamVjdH0gW3Jlc3BvbnNlXSBUaGUgcmVzcG9uc2UuXFxuICogQHJldHVybnMge0Vycm9yfSBUaGUgY3JlYXRlZCBlcnJvci5cXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG1lc3NhZ2UsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpIHtcXG4gIHZhciBlcnJvciA9IG5ldyBFcnJvcihtZXNzYWdlKTtcXG4gIHJldHVybiBlbmhhbmNlRXJyb3IoZXJyb3IsIGNvbmZpZywgY29kZSwgcmVxdWVzdCwgcmVzcG9uc2UpO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvY3JlYXRlRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2Rpc3BhdGNoUmVxdWVzdC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxudmFyIHRyYW5zZm9ybURhdGEgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3RyYW5zZm9ybURhdGEgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzXFxcIik7XFxudmFyIGlzQ2FuY2VsID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vY2FuY2VsL2lzQ2FuY2VsICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NhbmNlbC9pc0NhbmNlbC5qc1xcXCIpO1xcbnZhciBkZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2RlZmF1bHRzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzXFxcIik7XFxudmFyIENhbmNlbCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL2NhbmNlbC9DYW5jZWwgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY2FuY2VsL0NhbmNlbC5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIFRocm93cyBhIGBDYW5jZWxgIGlmIGNhbmNlbGxhdGlvbiBoYXMgYmVlbiByZXF1ZXN0ZWQuXFxuICovXFxuZnVuY3Rpb24gdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpIHtcXG4gIGlmIChjb25maWcuY2FuY2VsVG9rZW4pIHtcXG4gICAgY29uZmlnLmNhbmNlbFRva2VuLnRocm93SWZSZXF1ZXN0ZWQoKTtcXG4gIH1cXG5cXG4gIGlmIChjb25maWcuc2lnbmFsICYmIGNvbmZpZy5zaWduYWwuYWJvcnRlZCkge1xcbiAgICB0aHJvdyBuZXcgQ2FuY2VsKCdjYW5jZWxlZCcpO1xcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBEaXNwYXRjaCBhIHJlcXVlc3QgdG8gdGhlIHNlcnZlciB1c2luZyB0aGUgY29uZmlndXJlZCBhZGFwdGVyLlxcbiAqXFxuICogQHBhcmFtIHtvYmplY3R9IGNvbmZpZyBUaGUgY29uZmlnIHRoYXQgaXMgdG8gYmUgdXNlZCBmb3IgdGhlIHJlcXVlc3RcXG4gKiBAcmV0dXJucyB7UHJvbWlzZX0gVGhlIFByb21pc2UgdG8gYmUgZnVsZmlsbGVkXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBkaXNwYXRjaFJlcXVlc3QoY29uZmlnKSB7XFxuICB0aHJvd0lmQ2FuY2VsbGF0aW9uUmVxdWVzdGVkKGNvbmZpZyk7XFxuXFxuICAvLyBFbnN1cmUgaGVhZGVycyBleGlzdFxcbiAgY29uZmlnLmhlYWRlcnMgPSBjb25maWcuaGVhZGVycyB8fCB7fTtcXG5cXG4gIC8vIFRyYW5zZm9ybSByZXF1ZXN0IGRhdGFcXG4gIGNvbmZpZy5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxcbiAgICBjb25maWcsXFxuICAgIGNvbmZpZy5kYXRhLFxcbiAgICBjb25maWcuaGVhZGVycyxcXG4gICAgY29uZmlnLnRyYW5zZm9ybVJlcXVlc3RcXG4gICk7XFxuXFxuICAvLyBGbGF0dGVuIGhlYWRlcnNcXG4gIGNvbmZpZy5oZWFkZXJzID0gdXRpbHMubWVyZ2UoXFxuICAgIGNvbmZpZy5oZWFkZXJzLmNvbW1vbiB8fCB7fSxcXG4gICAgY29uZmlnLmhlYWRlcnNbY29uZmlnLm1ldGhvZF0gfHwge30sXFxuICAgIGNvbmZpZy5oZWFkZXJzXFxuICApO1xcblxcbiAgdXRpbHMuZm9yRWFjaChcXG4gICAgWydkZWxldGUnLCAnZ2V0JywgJ2hlYWQnLCAncG9zdCcsICdwdXQnLCAncGF0Y2gnLCAnY29tbW9uJ10sXFxuICAgIGZ1bmN0aW9uIGNsZWFuSGVhZGVyQ29uZmlnKG1ldGhvZCkge1xcbiAgICAgIGRlbGV0ZSBjb25maWcuaGVhZGVyc1ttZXRob2RdO1xcbiAgICB9XFxuICApO1xcblxcbiAgdmFyIGFkYXB0ZXIgPSBjb25maWcuYWRhcHRlciB8fCBkZWZhdWx0cy5hZGFwdGVyO1xcblxcbiAgcmV0dXJuIGFkYXB0ZXIoY29uZmlnKS50aGVuKGZ1bmN0aW9uIG9uQWRhcHRlclJlc29sdXRpb24ocmVzcG9uc2UpIHtcXG4gICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xcblxcbiAgICAvLyBUcmFuc2Zvcm0gcmVzcG9uc2UgZGF0YVxcbiAgICByZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxcbiAgICAgIGNvbmZpZyxcXG4gICAgICByZXNwb25zZS5kYXRhLFxcbiAgICAgIHJlc3BvbnNlLmhlYWRlcnMsXFxuICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXFxuICAgICk7XFxuXFxuICAgIHJldHVybiByZXNwb25zZTtcXG4gIH0sIGZ1bmN0aW9uIG9uQWRhcHRlclJlamVjdGlvbihyZWFzb24pIHtcXG4gICAgaWYgKCFpc0NhbmNlbChyZWFzb24pKSB7XFxuICAgICAgdGhyb3dJZkNhbmNlbGxhdGlvblJlcXVlc3RlZChjb25maWcpO1xcblxcbiAgICAgIC8vIFRyYW5zZm9ybSByZXNwb25zZSBkYXRhXFxuICAgICAgaWYgKHJlYXNvbiAmJiByZWFzb24ucmVzcG9uc2UpIHtcXG4gICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhID0gdHJhbnNmb3JtRGF0YS5jYWxsKFxcbiAgICAgICAgICBjb25maWcsXFxuICAgICAgICAgIHJlYXNvbi5yZXNwb25zZS5kYXRhLFxcbiAgICAgICAgICByZWFzb24ucmVzcG9uc2UuaGVhZGVycyxcXG4gICAgICAgICAgY29uZmlnLnRyYW5zZm9ybVJlc3BvbnNlXFxuICAgICAgICApO1xcbiAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QocmVhc29uKTtcXG4gIH0pO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZGlzcGF0Y2hSZXF1ZXN0LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9lbmhhbmNlRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbi8qKlxcbiAqIFVwZGF0ZSBhbiBFcnJvciB3aXRoIHRoZSBzcGVjaWZpZWQgY29uZmlnLCBlcnJvciBjb2RlLCBhbmQgcmVzcG9uc2UuXFxuICpcXG4gKiBAcGFyYW0ge0Vycm9yfSBlcnJvciBUaGUgZXJyb3IgdG8gdXBkYXRlLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcgVGhlIGNvbmZpZy5cXG4gKiBAcGFyYW0ge3N0cmluZ30gW2NvZGVdIFRoZSBlcnJvciBjb2RlIChmb3IgZXhhbXBsZSwgJ0VDT05OQUJPUlRFRCcpLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBbcmVxdWVzdF0gVGhlIHJlcXVlc3QuXFxuICogQHBhcmFtIHtPYmplY3R9IFtyZXNwb25zZV0gVGhlIHJlc3BvbnNlLlxcbiAqIEByZXR1cm5zIHtFcnJvcn0gVGhlIGVycm9yLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gZW5oYW5jZUVycm9yKGVycm9yLCBjb25maWcsIGNvZGUsIHJlcXVlc3QsIHJlc3BvbnNlKSB7XFxuICBlcnJvci5jb25maWcgPSBjb25maWc7XFxuICBpZiAoY29kZSkge1xcbiAgICBlcnJvci5jb2RlID0gY29kZTtcXG4gIH1cXG5cXG4gIGVycm9yLnJlcXVlc3QgPSByZXF1ZXN0O1xcbiAgZXJyb3IucmVzcG9uc2UgPSByZXNwb25zZTtcXG4gIGVycm9yLmlzQXhpb3NFcnJvciA9IHRydWU7XFxuXFxuICBlcnJvci50b0pTT04gPSBmdW5jdGlvbiB0b0pTT04oKSB7XFxuICAgIHJldHVybiB7XFxuICAgICAgLy8gU3RhbmRhcmRcXG4gICAgICBtZXNzYWdlOiB0aGlzLm1lc3NhZ2UsXFxuICAgICAgbmFtZTogdGhpcy5uYW1lLFxcbiAgICAgIC8vIE1pY3Jvc29mdFxcbiAgICAgIGRlc2NyaXB0aW9uOiB0aGlzLmRlc2NyaXB0aW9uLFxcbiAgICAgIG51bWJlcjogdGhpcy5udW1iZXIsXFxuICAgICAgLy8gTW96aWxsYVxcbiAgICAgIGZpbGVOYW1lOiB0aGlzLmZpbGVOYW1lLFxcbiAgICAgIGxpbmVOdW1iZXI6IHRoaXMubGluZU51bWJlcixcXG4gICAgICBjb2x1bW5OdW1iZXI6IHRoaXMuY29sdW1uTnVtYmVyLFxcbiAgICAgIHN0YWNrOiB0aGlzLnN0YWNrLFxcbiAgICAgIC8vIEF4aW9zXFxuICAgICAgY29uZmlnOiB0aGlzLmNvbmZpZyxcXG4gICAgICBjb2RlOiB0aGlzLmNvZGUsXFxuICAgICAgc3RhdHVzOiB0aGlzLnJlc3BvbnNlICYmIHRoaXMucmVzcG9uc2Uuc3RhdHVzID8gdGhpcy5yZXNwb25zZS5zdGF0dXMgOiBudWxsXFxuICAgIH07XFxuICB9O1xcbiAgcmV0dXJuIGVycm9yO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvZW5oYW5jZUVycm9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2NvcmUvbWVyZ2VDb25maWcuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIENvbmZpZy1zcGVjaWZpYyBtZXJnZS1mdW5jdGlvbiB3aGljaCBjcmVhdGVzIGEgbmV3IGNvbmZpZy1vYmplY3RcXG4gKiBieSBtZXJnaW5nIHR3byBjb25maWd1cmF0aW9uIG9iamVjdHMgdG9nZXRoZXIuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gY29uZmlnMVxcbiAqIEBwYXJhbSB7T2JqZWN0fSBjb25maWcyXFxuICogQHJldHVybnMge09iamVjdH0gTmV3IG9iamVjdCByZXN1bHRpbmcgZnJvbSBtZXJnaW5nIGNvbmZpZzIgdG8gY29uZmlnMVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gbWVyZ2VDb25maWcoY29uZmlnMSwgY29uZmlnMikge1xcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIG5vLXBhcmFtLXJlYXNzaWduXFxuICBjb25maWcyID0gY29uZmlnMiB8fCB7fTtcXG4gIHZhciBjb25maWcgPSB7fTtcXG5cXG4gIGZ1bmN0aW9uIGdldE1lcmdlZFZhbHVlKHRhcmdldCwgc291cmNlKSB7XFxuICAgIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHRhcmdldCkgJiYgdXRpbHMuaXNQbGFpbk9iamVjdChzb3VyY2UpKSB7XFxuICAgICAgcmV0dXJuIHV0aWxzLm1lcmdlKHRhcmdldCwgc291cmNlKTtcXG4gICAgfSBlbHNlIGlmICh1dGlscy5pc1BsYWluT2JqZWN0KHNvdXJjZSkpIHtcXG4gICAgICByZXR1cm4gdXRpbHMubWVyZ2Uoe30sIHNvdXJjZSk7XFxuICAgIH0gZWxzZSBpZiAodXRpbHMuaXNBcnJheShzb3VyY2UpKSB7XFxuICAgICAgcmV0dXJuIHNvdXJjZS5zbGljZSgpO1xcbiAgICB9XFxuICAgIHJldHVybiBzb3VyY2U7XFxuICB9XFxuXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cXG4gIGZ1bmN0aW9uIG1lcmdlRGVlcFByb3BlcnRpZXMocHJvcCkge1xcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XFxuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xcbiAgICB9IGVsc2UgaWYgKCF1dGlscy5pc1VuZGVmaW5lZChjb25maWcxW3Byb3BdKSkge1xcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xcbiAgICB9XFxuICB9XFxuXFxuICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgY29uc2lzdGVudC1yZXR1cm5cXG4gIGZ1bmN0aW9uIHZhbHVlRnJvbUNvbmZpZzIocHJvcCkge1xcbiAgICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGNvbmZpZzJbcHJvcF0pKSB7XFxuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKHVuZGVmaW5lZCwgY29uZmlnMltwcm9wXSk7XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxcbiAgZnVuY3Rpb24gZGVmYXVsdFRvQ29uZmlnMihwcm9wKSB7XFxuICAgIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMltwcm9wXSkpIHtcXG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcyW3Byb3BdKTtcXG4gICAgfSBlbHNlIGlmICghdXRpbHMuaXNVbmRlZmluZWQoY29uZmlnMVtwcm9wXSkpIHtcXG4gICAgICByZXR1cm4gZ2V0TWVyZ2VkVmFsdWUodW5kZWZpbmVkLCBjb25maWcxW3Byb3BdKTtcXG4gICAgfVxcbiAgfVxcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXFxuICBmdW5jdGlvbiBtZXJnZURpcmVjdEtleXMocHJvcCkge1xcbiAgICBpZiAocHJvcCBpbiBjb25maWcyKSB7XFxuICAgICAgcmV0dXJuIGdldE1lcmdlZFZhbHVlKGNvbmZpZzFbcHJvcF0sIGNvbmZpZzJbcHJvcF0pO1xcbiAgICB9IGVsc2UgaWYgKHByb3AgaW4gY29uZmlnMSkge1xcbiAgICAgIHJldHVybiBnZXRNZXJnZWRWYWx1ZSh1bmRlZmluZWQsIGNvbmZpZzFbcHJvcF0pO1xcbiAgICB9XFxuICB9XFxuXFxuICB2YXIgbWVyZ2VNYXAgPSB7XFxuICAgICd1cmwnOiB2YWx1ZUZyb21Db25maWcyLFxcbiAgICAnbWV0aG9kJzogdmFsdWVGcm9tQ29uZmlnMixcXG4gICAgJ2RhdGEnOiB2YWx1ZUZyb21Db25maWcyLFxcbiAgICAnYmFzZVVSTCc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICd0cmFuc2Zvcm1SZXF1ZXN0JzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ3RyYW5zZm9ybVJlc3BvbnNlJzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ3BhcmFtc1NlcmlhbGl6ZXInOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAndGltZW91dCc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICd0aW1lb3V0TWVzc2FnZSc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICd3aXRoQ3JlZGVudGlhbHMnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAnYWRhcHRlcic6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICdyZXNwb25zZVR5cGUnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAneHNyZkNvb2tpZU5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAneHNyZkhlYWRlck5hbWUnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAnb25VcGxvYWRQcm9ncmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICdvbkRvd25sb2FkUHJvZ3Jlc3MnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAnZGVjb21wcmVzcyc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICdtYXhDb250ZW50TGVuZ3RoJzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ21heEJvZHlMZW5ndGgnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAndHJhbnNwb3J0JzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ2h0dHBBZ2VudCc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICdodHRwc0FnZW50JzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ2NhbmNlbFRva2VuJzogZGVmYXVsdFRvQ29uZmlnMixcXG4gICAgJ3NvY2tldFBhdGgnOiBkZWZhdWx0VG9Db25maWcyLFxcbiAgICAncmVzcG9uc2VFbmNvZGluZyc6IGRlZmF1bHRUb0NvbmZpZzIsXFxuICAgICd2YWxpZGF0ZVN0YXR1cyc6IG1lcmdlRGlyZWN0S2V5c1xcbiAgfTtcXG5cXG4gIHV0aWxzLmZvckVhY2goT2JqZWN0LmtleXMoY29uZmlnMSkuY29uY2F0KE9iamVjdC5rZXlzKGNvbmZpZzIpKSwgZnVuY3Rpb24gY29tcHV0ZUNvbmZpZ1ZhbHVlKHByb3ApIHtcXG4gICAgdmFyIG1lcmdlID0gbWVyZ2VNYXBbcHJvcF0gfHwgbWVyZ2VEZWVwUHJvcGVydGllcztcXG4gICAgdmFyIGNvbmZpZ1ZhbHVlID0gbWVyZ2UocHJvcCk7XFxuICAgICh1dGlscy5pc1VuZGVmaW5lZChjb25maWdWYWx1ZSkgJiYgbWVyZ2UgIT09IG1lcmdlRGlyZWN0S2V5cykgfHwgKGNvbmZpZ1twcm9wXSA9IGNvbmZpZ1ZhbHVlKTtcXG4gIH0pO1xcblxcbiAgcmV0dXJuIGNvbmZpZztcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL21lcmdlQ29uZmlnLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS9zZXR0bGUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGNyZWF0ZUVycm9yID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGVFcnJvciAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2NyZWF0ZUVycm9yLmpzXFxcIik7XFxuXFxuLyoqXFxuICogUmVzb2x2ZSBvciByZWplY3QgYSBQcm9taXNlIGJhc2VkIG9uIHJlc3BvbnNlIHN0YXR1cy5cXG4gKlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlc29sdmUgQSBmdW5jdGlvbiB0aGF0IHJlc29sdmVzIHRoZSBwcm9taXNlLlxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IHJlamVjdCBBIGZ1bmN0aW9uIHRoYXQgcmVqZWN0cyB0aGUgcHJvbWlzZS5cXG4gKiBAcGFyYW0ge29iamVjdH0gcmVzcG9uc2UgVGhlIHJlc3BvbnNlLlxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gc2V0dGxlKHJlc29sdmUsIHJlamVjdCwgcmVzcG9uc2UpIHtcXG4gIHZhciB2YWxpZGF0ZVN0YXR1cyA9IHJlc3BvbnNlLmNvbmZpZy52YWxpZGF0ZVN0YXR1cztcXG4gIGlmICghcmVzcG9uc2Uuc3RhdHVzIHx8ICF2YWxpZGF0ZVN0YXR1cyB8fCB2YWxpZGF0ZVN0YXR1cyhyZXNwb25zZS5zdGF0dXMpKSB7XFxuICAgIHJlc29sdmUocmVzcG9uc2UpO1xcbiAgfSBlbHNlIHtcXG4gICAgcmVqZWN0KGNyZWF0ZUVycm9yKFxcbiAgICAgICdSZXF1ZXN0IGZhaWxlZCB3aXRoIHN0YXR1cyBjb2RlICcgKyByZXNwb25zZS5zdGF0dXMsXFxuICAgICAgcmVzcG9uc2UuY29uZmlnLFxcbiAgICAgIG51bGwsXFxuICAgICAgcmVzcG9uc2UucmVxdWVzdCxcXG4gICAgICByZXNwb25zZVxcbiAgICApKTtcXG4gIH1cXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3NldHRsZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvY29yZS90cmFuc2Zvcm1EYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxudmFyIGRlZmF1bHRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vZGVmYXVsdHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZGVmYXVsdHMvaW5kZXguanNcXFwiKTtcXG5cXG4vKipcXG4gKiBUcmFuc2Zvcm0gdGhlIGRhdGEgZm9yIGEgcmVxdWVzdCBvciBhIHJlc3BvbnNlXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdHxTdHJpbmd9IGRhdGEgVGhlIGRhdGEgdG8gYmUgdHJhbnNmb3JtZWRcXG4gKiBAcGFyYW0ge0FycmF5fSBoZWFkZXJzIFRoZSBoZWFkZXJzIGZvciB0aGUgcmVxdWVzdCBvciByZXNwb25zZVxcbiAqIEBwYXJhbSB7QXJyYXl8RnVuY3Rpb259IGZucyBBIHNpbmdsZSBmdW5jdGlvbiBvciBBcnJheSBvZiBmdW5jdGlvbnNcXG4gKiBAcmV0dXJucyB7Kn0gVGhlIHJlc3VsdGluZyB0cmFuc2Zvcm1lZCBkYXRhXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiB0cmFuc2Zvcm1EYXRhKGRhdGEsIGhlYWRlcnMsIGZucykge1xcbiAgdmFyIGNvbnRleHQgPSB0aGlzIHx8IGRlZmF1bHRzO1xcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXFxuICB1dGlscy5mb3JFYWNoKGZucywgZnVuY3Rpb24gdHJhbnNmb3JtKGZuKSB7XFxuICAgIGRhdGEgPSBmbi5jYWxsKGNvbnRleHQsIGRhdGEsIGhlYWRlcnMpO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZGF0YTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL3RyYW5zZm9ybURhdGEuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi91dGlscyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qc1xcXCIpO1xcbnZhciBub3JtYWxpemVIZWFkZXJOYW1lID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vaGVscGVycy9ub3JtYWxpemVIZWFkZXJOYW1lICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qc1xcXCIpO1xcbnZhciBlbmhhbmNlRXJyb3IgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9jb3JlL2VuaGFuY2VFcnJvciAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9jb3JlL2VuaGFuY2VFcnJvci5qc1xcXCIpO1xcbnZhciB0cmFuc2l0aW9uYWxEZWZhdWx0cyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHJhbnNpdGlvbmFsICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qc1xcXCIpO1xcblxcbnZhciBERUZBVUxUX0NPTlRFTlRfVFlQRSA9IHtcXG4gICdDb250ZW50LVR5cGUnOiAnYXBwbGljYXRpb24veC13d3ctZm9ybS11cmxlbmNvZGVkJ1xcbn07XFxuXFxuZnVuY3Rpb24gc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsIHZhbHVlKSB7XFxuICBpZiAoIXV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnMpICYmIHV0aWxzLmlzVW5kZWZpbmVkKGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddKSkge1xcbiAgICBoZWFkZXJzWydDb250ZW50LVR5cGUnXSA9IHZhbHVlO1xcbiAgfVxcbn1cXG5cXG5mdW5jdGlvbiBnZXREZWZhdWx0QWRhcHRlcigpIHtcXG4gIHZhciBhZGFwdGVyO1xcbiAgaWYgKHR5cGVvZiBYTUxIdHRwUmVxdWVzdCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgLy8gRm9yIGJyb3dzZXJzIHVzZSBYSFIgYWRhcHRlclxcbiAgICBhZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vYWRhcHRlcnMveGhyICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2FkYXB0ZXJzL3hoci5qc1xcXCIpO1xcbiAgfSBlbHNlIGlmICh0eXBlb2YgcHJvY2VzcyAhPT0gJ3VuZGVmaW5lZCcgJiYgT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHByb2Nlc3MpID09PSAnW29iamVjdCBwcm9jZXNzXScpIHtcXG4gICAgLy8gRm9yIG5vZGUgdXNlIEhUVFAgYWRhcHRlclxcbiAgICBhZGFwdGVyID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vYWRhcHRlcnMvaHR0cCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9hZGFwdGVycy94aHIuanNcXFwiKTtcXG4gIH1cXG4gIHJldHVybiBhZGFwdGVyO1xcbn1cXG5cXG5mdW5jdGlvbiBzdHJpbmdpZnlTYWZlbHkocmF3VmFsdWUsIHBhcnNlciwgZW5jb2Rlcikge1xcbiAgaWYgKHV0aWxzLmlzU3RyaW5nKHJhd1ZhbHVlKSkge1xcbiAgICB0cnkge1xcbiAgICAgIChwYXJzZXIgfHwgSlNPTi5wYXJzZSkocmF3VmFsdWUpO1xcbiAgICAgIHJldHVybiB1dGlscy50cmltKHJhd1ZhbHVlKTtcXG4gICAgfSBjYXRjaCAoZSkge1xcbiAgICAgIGlmIChlLm5hbWUgIT09ICdTeW50YXhFcnJvcicpIHtcXG4gICAgICAgIHRocm93IGU7XFxuICAgICAgfVxcbiAgICB9XFxuICB9XFxuXFxuICByZXR1cm4gKGVuY29kZXIgfHwgSlNPTi5zdHJpbmdpZnkpKHJhd1ZhbHVlKTtcXG59XFxuXFxudmFyIGRlZmF1bHRzID0ge1xcblxcbiAgdHJhbnNpdGlvbmFsOiB0cmFuc2l0aW9uYWxEZWZhdWx0cyxcXG5cXG4gIGFkYXB0ZXI6IGdldERlZmF1bHRBZGFwdGVyKCksXFxuXFxuICB0cmFuc2Zvcm1SZXF1ZXN0OiBbZnVuY3Rpb24gdHJhbnNmb3JtUmVxdWVzdChkYXRhLCBoZWFkZXJzKSB7XFxuICAgIG5vcm1hbGl6ZUhlYWRlck5hbWUoaGVhZGVycywgJ0FjY2VwdCcpO1xcbiAgICBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsICdDb250ZW50LVR5cGUnKTtcXG5cXG4gICAgaWYgKHV0aWxzLmlzRm9ybURhdGEoZGF0YSkgfHxcXG4gICAgICB1dGlscy5pc0FycmF5QnVmZmVyKGRhdGEpIHx8XFxuICAgICAgdXRpbHMuaXNCdWZmZXIoZGF0YSkgfHxcXG4gICAgICB1dGlscy5pc1N0cmVhbShkYXRhKSB8fFxcbiAgICAgIHV0aWxzLmlzRmlsZShkYXRhKSB8fFxcbiAgICAgIHV0aWxzLmlzQmxvYihkYXRhKVxcbiAgICApIHtcXG4gICAgICByZXR1cm4gZGF0YTtcXG4gICAgfVxcbiAgICBpZiAodXRpbHMuaXNBcnJheUJ1ZmZlclZpZXcoZGF0YSkpIHtcXG4gICAgICByZXR1cm4gZGF0YS5idWZmZXI7XFxuICAgIH1cXG4gICAgaWYgKHV0aWxzLmlzVVJMU2VhcmNoUGFyYW1zKGRhdGEpKSB7XFxuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWQ7Y2hhcnNldD11dGYtOCcpO1xcbiAgICAgIHJldHVybiBkYXRhLnRvU3RyaW5nKCk7XFxuICAgIH1cXG4gICAgaWYgKHV0aWxzLmlzT2JqZWN0KGRhdGEpIHx8IChoZWFkZXJzICYmIGhlYWRlcnNbJ0NvbnRlbnQtVHlwZSddID09PSAnYXBwbGljYXRpb24vanNvbicpKSB7XFxuICAgICAgc2V0Q29udGVudFR5cGVJZlVuc2V0KGhlYWRlcnMsICdhcHBsaWNhdGlvbi9qc29uJyk7XFxuICAgICAgcmV0dXJuIHN0cmluZ2lmeVNhZmVseShkYXRhKTtcXG4gICAgfVxcbiAgICByZXR1cm4gZGF0YTtcXG4gIH1dLFxcblxcbiAgdHJhbnNmb3JtUmVzcG9uc2U6IFtmdW5jdGlvbiB0cmFuc2Zvcm1SZXNwb25zZShkYXRhKSB7XFxuICAgIHZhciB0cmFuc2l0aW9uYWwgPSB0aGlzLnRyYW5zaXRpb25hbCB8fCBkZWZhdWx0cy50cmFuc2l0aW9uYWw7XFxuICAgIHZhciBzaWxlbnRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuc2lsZW50SlNPTlBhcnNpbmc7XFxuICAgIHZhciBmb3JjZWRKU09OUGFyc2luZyA9IHRyYW5zaXRpb25hbCAmJiB0cmFuc2l0aW9uYWwuZm9yY2VkSlNPTlBhcnNpbmc7XFxuICAgIHZhciBzdHJpY3RKU09OUGFyc2luZyA9ICFzaWxlbnRKU09OUGFyc2luZyAmJiB0aGlzLnJlc3BvbnNlVHlwZSA9PT0gJ2pzb24nO1xcblxcbiAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcgfHwgKGZvcmNlZEpTT05QYXJzaW5nICYmIHV0aWxzLmlzU3RyaW5nKGRhdGEpICYmIGRhdGEubGVuZ3RoKSkge1xcbiAgICAgIHRyeSB7XFxuICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShkYXRhKTtcXG4gICAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICBpZiAoc3RyaWN0SlNPTlBhcnNpbmcpIHtcXG4gICAgICAgICAgaWYgKGUubmFtZSA9PT0gJ1N5bnRheEVycm9yJykge1xcbiAgICAgICAgICAgIHRocm93IGVuaGFuY2VFcnJvcihlLCB0aGlzLCAnRV9KU09OX1BBUlNFJyk7XFxuICAgICAgICAgIH1cXG4gICAgICAgICAgdGhyb3cgZTtcXG4gICAgICAgIH1cXG4gICAgICB9XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGRhdGE7XFxuICB9XSxcXG5cXG4gIC8qKlxcbiAgICogQSB0aW1lb3V0IGluIG1pbGxpc2Vjb25kcyB0byBhYm9ydCBhIHJlcXVlc3QuIElmIHNldCB0byAwIChkZWZhdWx0KSBhXFxuICAgKiB0aW1lb3V0IGlzIG5vdCBjcmVhdGVkLlxcbiAgICovXFxuICB0aW1lb3V0OiAwLFxcblxcbiAgeHNyZkNvb2tpZU5hbWU6ICdYU1JGLVRPS0VOJyxcXG4gIHhzcmZIZWFkZXJOYW1lOiAnWC1YU1JGLVRPS0VOJyxcXG5cXG4gIG1heENvbnRlbnRMZW5ndGg6IC0xLFxcbiAgbWF4Qm9keUxlbmd0aDogLTEsXFxuXFxuICB2YWxpZGF0ZVN0YXR1czogZnVuY3Rpb24gdmFsaWRhdGVTdGF0dXMoc3RhdHVzKSB7XFxuICAgIHJldHVybiBzdGF0dXMgPj0gMjAwICYmIHN0YXR1cyA8IDMwMDtcXG4gIH0sXFxuXFxuICBoZWFkZXJzOiB7XFxuICAgIGNvbW1vbjoge1xcbiAgICAgICdBY2NlcHQnOiAnYXBwbGljYXRpb24vanNvbiwgdGV4dC9wbGFpbiwgKi8qJ1xcbiAgICB9XFxuICB9XFxufTtcXG5cXG51dGlscy5mb3JFYWNoKFsnZGVsZXRlJywgJ2dldCcsICdoZWFkJ10sIGZ1bmN0aW9uIGZvckVhY2hNZXRob2ROb0RhdGEobWV0aG9kKSB7XFxuICBkZWZhdWx0cy5oZWFkZXJzW21ldGhvZF0gPSB7fTtcXG59KTtcXG5cXG51dGlscy5mb3JFYWNoKFsncG9zdCcsICdwdXQnLCAncGF0Y2gnXSwgZnVuY3Rpb24gZm9yRWFjaE1ldGhvZFdpdGhEYXRhKG1ldGhvZCkge1xcbiAgZGVmYXVsdHMuaGVhZGVyc1ttZXRob2RdID0gdXRpbHMubWVyZ2UoREVGQVVMVF9DT05URU5UX1RZUEUpO1xcbn0pO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZGVmYXVsdHM7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9kZWZhdWx0cy90cmFuc2l0aW9uYWwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHtcXG4gIHNpbGVudEpTT05QYXJzaW5nOiB0cnVlLFxcbiAgZm9yY2VkSlNPTlBhcnNpbmc6IHRydWUsXFxuICBjbGFyaWZ5VGltZW91dEVycm9yOiBmYWxzZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2RlZmF1bHRzL3RyYW5zaXRpb25hbC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2Vudi9kYXRhLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5ldmFsKFwibW9kdWxlLmV4cG9ydHMgPSB7XFxuICBcXFwidmVyc2lvblxcXCI6IFxcXCIwLjI2LjFcXFwiXFxufTtcXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvZW52L2RhdGEuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYmluZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gYmluZChmbiwgdGhpc0FyZykge1xcbiAgcmV0dXJuIGZ1bmN0aW9uIHdyYXAoKSB7XFxuICAgIHZhciBhcmdzID0gbmV3IEFycmF5KGFyZ3VtZW50cy5sZW5ndGgpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGFyZ3MubGVuZ3RoOyBpKyspIHtcXG4gICAgICBhcmdzW2ldID0gYXJndW1lbnRzW2ldO1xcbiAgICB9XFxuICAgIHJldHVybiBmbi5hcHBseSh0aGlzQXJnLCBhcmdzKTtcXG4gIH07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9iaW5kLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2J1aWxkVVJMLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxuXFxuZnVuY3Rpb24gZW5jb2RlKHZhbCkge1xcbiAgcmV0dXJuIGVuY29kZVVSSUNvbXBvbmVudCh2YWwpLlxcbiAgICByZXBsYWNlKC8lM0EvZ2ksICc6JykuXFxuICAgIHJlcGxhY2UoLyUyNC9nLCAnJCcpLlxcbiAgICByZXBsYWNlKC8lMkMvZ2ksICcsJykuXFxuICAgIHJlcGxhY2UoLyUyMC9nLCAnKycpLlxcbiAgICByZXBsYWNlKC8lNUIvZ2ksICdbJykuXFxuICAgIHJlcGxhY2UoLyU1RC9naSwgJ10nKTtcXG59XFxuXFxuLyoqXFxuICogQnVpbGQgYSBVUkwgYnkgYXBwZW5kaW5nIHBhcmFtcyB0byB0aGUgZW5kXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gdXJsIFRoZSBiYXNlIG9mIHRoZSB1cmwgKGUuZy4sIGh0dHA6Ly93d3cuZ29vZ2xlLmNvbSlcXG4gKiBAcGFyYW0ge29iamVjdH0gW3BhcmFtc10gVGhlIHBhcmFtcyB0byBiZSBhcHBlbmRlZFxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBmb3JtYXR0ZWQgdXJsXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBidWlsZFVSTCh1cmwsIHBhcmFtcywgcGFyYW1zU2VyaWFsaXplcikge1xcbiAgLyplc2xpbnQgbm8tcGFyYW0tcmVhc3NpZ246MCovXFxuICBpZiAoIXBhcmFtcykge1xcbiAgICByZXR1cm4gdXJsO1xcbiAgfVxcblxcbiAgdmFyIHNlcmlhbGl6ZWRQYXJhbXM7XFxuICBpZiAocGFyYW1zU2VyaWFsaXplcikge1xcbiAgICBzZXJpYWxpemVkUGFyYW1zID0gcGFyYW1zU2VyaWFsaXplcihwYXJhbXMpO1xcbiAgfSBlbHNlIGlmICh1dGlscy5pc1VSTFNlYXJjaFBhcmFtcyhwYXJhbXMpKSB7XFxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJhbXMudG9TdHJpbmcoKTtcXG4gIH0gZWxzZSB7XFxuICAgIHZhciBwYXJ0cyA9IFtdO1xcblxcbiAgICB1dGlscy5mb3JFYWNoKHBhcmFtcywgZnVuY3Rpb24gc2VyaWFsaXplKHZhbCwga2V5KSB7XFxuICAgICAgaWYgKHZhbCA9PT0gbnVsbCB8fCB0eXBlb2YgdmFsID09PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG5cXG4gICAgICBpZiAodXRpbHMuaXNBcnJheSh2YWwpKSB7XFxuICAgICAgICBrZXkgPSBrZXkgKyAnW10nO1xcbiAgICAgIH0gZWxzZSB7XFxuICAgICAgICB2YWwgPSBbdmFsXTtcXG4gICAgICB9XFxuXFxuICAgICAgdXRpbHMuZm9yRWFjaCh2YWwsIGZ1bmN0aW9uIHBhcnNlVmFsdWUodikge1xcbiAgICAgICAgaWYgKHV0aWxzLmlzRGF0ZSh2KSkge1xcbiAgICAgICAgICB2ID0gdi50b0lTT1N0cmluZygpO1xcbiAgICAgICAgfSBlbHNlIGlmICh1dGlscy5pc09iamVjdCh2KSkge1xcbiAgICAgICAgICB2ID0gSlNPTi5zdHJpbmdpZnkodik7XFxuICAgICAgICB9XFxuICAgICAgICBwYXJ0cy5wdXNoKGVuY29kZShrZXkpICsgJz0nICsgZW5jb2RlKHYpKTtcXG4gICAgICB9KTtcXG4gICAgfSk7XFxuXFxuICAgIHNlcmlhbGl6ZWRQYXJhbXMgPSBwYXJ0cy5qb2luKCcmJyk7XFxuICB9XFxuXFxuICBpZiAoc2VyaWFsaXplZFBhcmFtcykge1xcbiAgICB2YXIgaGFzaG1hcmtJbmRleCA9IHVybC5pbmRleE9mKCcjJyk7XFxuICAgIGlmIChoYXNobWFya0luZGV4ICE9PSAtMSkge1xcbiAgICAgIHVybCA9IHVybC5zbGljZSgwLCBoYXNobWFya0luZGV4KTtcXG4gICAgfVxcblxcbiAgICB1cmwgKz0gKHVybC5pbmRleE9mKCc/JykgPT09IC0xID8gJz8nIDogJyYnKSArIHNlcmlhbGl6ZWRQYXJhbXM7XFxuICB9XFxuXFxuICByZXR1cm4gdXJsO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvYnVpbGRVUkwuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvY29tYmluZVVSTHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb21iaW5lVVJMcy5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG4vKipcXG4gKiBDcmVhdGVzIGEgbmV3IFVSTCBieSBjb21iaW5pbmcgdGhlIHNwZWNpZmllZCBVUkxzXFxuICpcXG4gKiBAcGFyYW0ge3N0cmluZ30gYmFzZVVSTCBUaGUgYmFzZSBVUkxcXG4gKiBAcGFyYW0ge3N0cmluZ30gcmVsYXRpdmVVUkwgVGhlIHJlbGF0aXZlIFVSTFxcbiAqIEByZXR1cm5zIHtzdHJpbmd9IFRoZSBjb21iaW5lZCBVUkxcXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNvbWJpbmVVUkxzKGJhc2VVUkwsIHJlbGF0aXZlVVJMKSB7XFxuICByZXR1cm4gcmVsYXRpdmVVUkxcXG4gICAgPyBiYXNlVVJMLnJlcGxhY2UoL1xcXFwvKyQvLCAnJykgKyAnLycgKyByZWxhdGl2ZVVSTC5yZXBsYWNlKC9eXFxcXC8rLywgJycpXFxuICAgIDogYmFzZVVSTDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2NvbWJpbmVVUkxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2Nvb2tpZXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vdXRpbHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IChcXG4gIHV0aWxzLmlzU3RhbmRhcmRCcm93c2VyRW52KCkgP1xcblxcbiAgLy8gU3RhbmRhcmQgYnJvd3NlciBlbnZzIHN1cHBvcnQgZG9jdW1lbnQuY29va2llXFxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XFxuICAgICAgcmV0dXJuIHtcXG4gICAgICAgIHdyaXRlOiBmdW5jdGlvbiB3cml0ZShuYW1lLCB2YWx1ZSwgZXhwaXJlcywgcGF0aCwgZG9tYWluLCBzZWN1cmUpIHtcXG4gICAgICAgICAgdmFyIGNvb2tpZSA9IFtdO1xcbiAgICAgICAgICBjb29raWUucHVzaChuYW1lICsgJz0nICsgZW5jb2RlVVJJQ29tcG9uZW50KHZhbHVlKSk7XFxuXFxuICAgICAgICAgIGlmICh1dGlscy5pc051bWJlcihleHBpcmVzKSkge1xcbiAgICAgICAgICAgIGNvb2tpZS5wdXNoKCdleHBpcmVzPScgKyBuZXcgRGF0ZShleHBpcmVzKS50b0dNVFN0cmluZygpKTtcXG4gICAgICAgICAgfVxcblxcbiAgICAgICAgICBpZiAodXRpbHMuaXNTdHJpbmcocGF0aCkpIHtcXG4gICAgICAgICAgICBjb29raWUucHVzaCgncGF0aD0nICsgcGF0aCk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgaWYgKHV0aWxzLmlzU3RyaW5nKGRvbWFpbikpIHtcXG4gICAgICAgICAgICBjb29raWUucHVzaCgnZG9tYWluPScgKyBkb21haW4pO1xcbiAgICAgICAgICB9XFxuXFxuICAgICAgICAgIGlmIChzZWN1cmUgPT09IHRydWUpIHtcXG4gICAgICAgICAgICBjb29raWUucHVzaCgnc2VjdXJlJyk7XFxuICAgICAgICAgIH1cXG5cXG4gICAgICAgICAgZG9jdW1lbnQuY29va2llID0gY29va2llLmpvaW4oJzsgJyk7XFxuICAgICAgICB9LFxcblxcbiAgICAgICAgcmVhZDogZnVuY3Rpb24gcmVhZChuYW1lKSB7XFxuICAgICAgICAgIHZhciBtYXRjaCA9IGRvY3VtZW50LmNvb2tpZS5tYXRjaChuZXcgUmVnRXhwKCcoXnw7XFxcXFxcXFxzKikoJyArIG5hbWUgKyAnKT0oW147XSopJykpO1xcbiAgICAgICAgICByZXR1cm4gKG1hdGNoID8gZGVjb2RlVVJJQ29tcG9uZW50KG1hdGNoWzNdKSA6IG51bGwpO1xcbiAgICAgICAgfSxcXG5cXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKG5hbWUpIHtcXG4gICAgICAgICAgdGhpcy53cml0ZShuYW1lLCAnJywgRGF0ZS5ub3coKSAtIDg2NDAwMDAwKTtcXG4gICAgICAgIH1cXG4gICAgICB9O1xcbiAgICB9KSgpIDpcXG5cXG4gIC8vIE5vbiBzdGFuZGFyZCBicm93c2VyIGVudiAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcXG4gICAgICByZXR1cm4ge1xcbiAgICAgICAgd3JpdGU6IGZ1bmN0aW9uIHdyaXRlKCkge30sXFxuICAgICAgICByZWFkOiBmdW5jdGlvbiByZWFkKCkgeyByZXR1cm4gbnVsbDsgfSxcXG4gICAgICAgIHJlbW92ZTogZnVuY3Rpb24gcmVtb3ZlKCkge31cXG4gICAgICB9O1xcbiAgICB9KSgpXFxuKTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9jb29raWVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQWJzb2x1dGVVUkwuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSkgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG4vKipcXG4gKiBEZXRlcm1pbmVzIHdoZXRoZXIgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGVcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSB1cmwgVGhlIFVSTCB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdGhlIHNwZWNpZmllZCBVUkwgaXMgYWJzb2x1dGUsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaXNBYnNvbHV0ZVVSTCh1cmwpIHtcXG4gIC8vIEEgVVJMIGlzIGNvbnNpZGVyZWQgYWJzb2x1dGUgaWYgaXQgYmVnaW5zIHdpdGggXFxcIjxzY2hlbWU+Oi8vXFxcIiBvciBcXFwiLy9cXFwiIChwcm90b2NvbC1yZWxhdGl2ZSBVUkwpLlxcbiAgLy8gUkZDIDM5ODYgZGVmaW5lcyBzY2hlbWUgbmFtZSBhcyBhIHNlcXVlbmNlIG9mIGNoYXJhY3RlcnMgYmVnaW5uaW5nIHdpdGggYSBsZXR0ZXIgYW5kIGZvbGxvd2VkXFxuICAvLyBieSBhbnkgY29tYmluYXRpb24gb2YgbGV0dGVycywgZGlnaXRzLCBwbHVzLCBwZXJpb2QsIG9yIGh5cGhlbi5cXG4gIHJldHVybiAvXihbYS16XVthLXpcXFxcZCtcXFxcLS5dKjopP1xcXFwvXFxcXC8vaS50ZXN0KHVybCk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0Fic29sdXRlVVJMLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzQXhpb3NFcnJvci5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIHV0aWxzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8uLi91dGlscyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qc1xcXCIpO1xcblxcbi8qKlxcbiAqIERldGVybWluZXMgd2hldGhlciB0aGUgcGF5bG9hZCBpcyBhbiBlcnJvciB0aHJvd24gYnkgQXhpb3NcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gcGF5bG9hZCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSBwYXlsb2FkIGlzIGFuIGVycm9yIHRocm93biBieSBBeGlvcywgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBpc0F4aW9zRXJyb3IocGF5bG9hZCkge1xcbiAgcmV0dXJuIHV0aWxzLmlzT2JqZWN0KHBheWxvYWQpICYmIChwYXlsb2FkLmlzQXhpb3NFcnJvciA9PT0gdHJ1ZSk7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9pc0F4aW9zRXJyb3IuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2lzVVJMU2FtZU9yaWdpbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLy4uL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSAoXFxuICB1dGlscy5pc1N0YW5kYXJkQnJvd3NlckVudigpID9cXG5cXG4gIC8vIFN0YW5kYXJkIGJyb3dzZXIgZW52cyBoYXZlIGZ1bGwgc3VwcG9ydCBvZiB0aGUgQVBJcyBuZWVkZWQgdG8gdGVzdFxcbiAgLy8gd2hldGhlciB0aGUgcmVxdWVzdCBVUkwgaXMgb2YgdGhlIHNhbWUgb3JpZ2luIGFzIGN1cnJlbnQgbG9jYXRpb24uXFxuICAgIChmdW5jdGlvbiBzdGFuZGFyZEJyb3dzZXJFbnYoKSB7XFxuICAgICAgdmFyIG1zaWUgPSAvKG1zaWV8dHJpZGVudCkvaS50ZXN0KG5hdmlnYXRvci51c2VyQWdlbnQpO1xcbiAgICAgIHZhciB1cmxQYXJzaW5nTm9kZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoJ2EnKTtcXG4gICAgICB2YXIgb3JpZ2luVVJMO1xcblxcbiAgICAgIC8qKlxcbiAgICAqIFBhcnNlIGEgVVJMIHRvIGRpc2NvdmVyIGl0J3MgY29tcG9uZW50c1xcbiAgICAqXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHVybCBUaGUgVVJMIHRvIGJlIHBhcnNlZFxcbiAgICAqIEByZXR1cm5zIHtPYmplY3R9XFxuICAgICovXFxuICAgICAgZnVuY3Rpb24gcmVzb2x2ZVVSTCh1cmwpIHtcXG4gICAgICAgIHZhciBocmVmID0gdXJsO1xcblxcbiAgICAgICAgaWYgKG1zaWUpIHtcXG4gICAgICAgIC8vIElFIG5lZWRzIGF0dHJpYnV0ZSBzZXQgdHdpY2UgdG8gbm9ybWFsaXplIHByb3BlcnRpZXNcXG4gICAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XFxuICAgICAgICAgIGhyZWYgPSB1cmxQYXJzaW5nTm9kZS5ocmVmO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgdXJsUGFyc2luZ05vZGUuc2V0QXR0cmlidXRlKCdocmVmJywgaHJlZik7XFxuXFxuICAgICAgICAvLyB1cmxQYXJzaW5nTm9kZSBwcm92aWRlcyB0aGUgVXJsVXRpbHMgaW50ZXJmYWNlIC0gaHR0cDovL3VybC5zcGVjLndoYXR3Zy5vcmcvI3VybHV0aWxzXFxuICAgICAgICByZXR1cm4ge1xcbiAgICAgICAgICBocmVmOiB1cmxQYXJzaW5nTm9kZS5ocmVmLFxcbiAgICAgICAgICBwcm90b2NvbDogdXJsUGFyc2luZ05vZGUucHJvdG9jb2wgPyB1cmxQYXJzaW5nTm9kZS5wcm90b2NvbC5yZXBsYWNlKC86JC8sICcnKSA6ICcnLFxcbiAgICAgICAgICBob3N0OiB1cmxQYXJzaW5nTm9kZS5ob3N0LFxcbiAgICAgICAgICBzZWFyY2g6IHVybFBhcnNpbmdOb2RlLnNlYXJjaCA/IHVybFBhcnNpbmdOb2RlLnNlYXJjaC5yZXBsYWNlKC9eXFxcXD8vLCAnJykgOiAnJyxcXG4gICAgICAgICAgaGFzaDogdXJsUGFyc2luZ05vZGUuaGFzaCA/IHVybFBhcnNpbmdOb2RlLmhhc2gucmVwbGFjZSgvXiMvLCAnJykgOiAnJyxcXG4gICAgICAgICAgaG9zdG5hbWU6IHVybFBhcnNpbmdOb2RlLmhvc3RuYW1lLFxcbiAgICAgICAgICBwb3J0OiB1cmxQYXJzaW5nTm9kZS5wb3J0LFxcbiAgICAgICAgICBwYXRobmFtZTogKHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lLmNoYXJBdCgwKSA9PT0gJy8nKSA/XFxuICAgICAgICAgICAgdXJsUGFyc2luZ05vZGUucGF0aG5hbWUgOlxcbiAgICAgICAgICAgICcvJyArIHVybFBhcnNpbmdOb2RlLnBhdGhuYW1lXFxuICAgICAgICB9O1xcbiAgICAgIH1cXG5cXG4gICAgICBvcmlnaW5VUkwgPSByZXNvbHZlVVJMKHdpbmRvdy5sb2NhdGlvbi5ocmVmKTtcXG5cXG4gICAgICAvKipcXG4gICAgKiBEZXRlcm1pbmUgaWYgYSBVUkwgc2hhcmVzIHRoZSBzYW1lIG9yaWdpbiBhcyB0aGUgY3VycmVudCBsb2NhdGlvblxcbiAgICAqXFxuICAgICogQHBhcmFtIHtTdHJpbmd9IHJlcXVlc3RVUkwgVGhlIFVSTCB0byB0ZXN0XFxuICAgICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgVVJMIHNoYXJlcyB0aGUgc2FtZSBvcmlnaW4sIG90aGVyd2lzZSBmYWxzZVxcbiAgICAqL1xcbiAgICAgIHJldHVybiBmdW5jdGlvbiBpc1VSTFNhbWVPcmlnaW4ocmVxdWVzdFVSTCkge1xcbiAgICAgICAgdmFyIHBhcnNlZCA9ICh1dGlscy5pc1N0cmluZyhyZXF1ZXN0VVJMKSkgPyByZXNvbHZlVVJMKHJlcXVlc3RVUkwpIDogcmVxdWVzdFVSTDtcXG4gICAgICAgIHJldHVybiAocGFyc2VkLnByb3RvY29sID09PSBvcmlnaW5VUkwucHJvdG9jb2wgJiZcXG4gICAgICAgICAgICBwYXJzZWQuaG9zdCA9PT0gb3JpZ2luVVJMLmhvc3QpO1xcbiAgICAgIH07XFxuICAgIH0pKCkgOlxcblxcbiAgLy8gTm9uIHN0YW5kYXJkIGJyb3dzZXIgZW52cyAod2ViIHdvcmtlcnMsIHJlYWN0LW5hdGl2ZSkgbGFjayBuZWVkZWQgc3VwcG9ydC5cXG4gICAgKGZ1bmN0aW9uIG5vblN0YW5kYXJkQnJvd3NlckVudigpIHtcXG4gICAgICByZXR1cm4gZnVuY3Rpb24gaXNVUkxTYW1lT3JpZ2luKCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgfTtcXG4gICAgfSkoKVxcbik7XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvaXNVUkxTYW1lT3JpZ2luLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL25vcm1hbGl6ZUhlYWRlck5hbWUuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4uL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL3V0aWxzLmpzXFxcIik7XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBub3JtYWxpemVIZWFkZXJOYW1lKGhlYWRlcnMsIG5vcm1hbGl6ZWROYW1lKSB7XFxuICB1dGlscy5mb3JFYWNoKGhlYWRlcnMsIGZ1bmN0aW9uIHByb2Nlc3NIZWFkZXIodmFsdWUsIG5hbWUpIHtcXG4gICAgaWYgKG5hbWUgIT09IG5vcm1hbGl6ZWROYW1lICYmIG5hbWUudG9VcHBlckNhc2UoKSA9PT0gbm9ybWFsaXplZE5hbWUudG9VcHBlckNhc2UoKSkge1xcbiAgICAgIGhlYWRlcnNbbm9ybWFsaXplZE5hbWVdID0gdmFsdWU7XFxuICAgICAgZGVsZXRlIGhlYWRlcnNbbmFtZV07XFxuICAgIH1cXG4gIH0pO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvbm9ybWFsaXplSGVhZGVyTmFtZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvcGFyc2VIZWFkZXJzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciB1dGlscyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vLi4vdXRpbHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanNcXFwiKTtcXG5cXG4vLyBIZWFkZXJzIHdob3NlIGR1cGxpY2F0ZXMgYXJlIGlnbm9yZWQgYnkgbm9kZVxcbi8vIGMuZi4gaHR0cHM6Ly9ub2RlanMub3JnL2FwaS9odHRwLmh0bWwjaHR0cF9tZXNzYWdlX2hlYWRlcnNcXG52YXIgaWdub3JlRHVwbGljYXRlT2YgPSBbXFxuICAnYWdlJywgJ2F1dGhvcml6YXRpb24nLCAnY29udGVudC1sZW5ndGgnLCAnY29udGVudC10eXBlJywgJ2V0YWcnLFxcbiAgJ2V4cGlyZXMnLCAnZnJvbScsICdob3N0JywgJ2lmLW1vZGlmaWVkLXNpbmNlJywgJ2lmLXVubW9kaWZpZWQtc2luY2UnLFxcbiAgJ2xhc3QtbW9kaWZpZWQnLCAnbG9jYXRpb24nLCAnbWF4LWZvcndhcmRzJywgJ3Byb3h5LWF1dGhvcml6YXRpb24nLFxcbiAgJ3JlZmVyZXInLCAncmV0cnktYWZ0ZXInLCAndXNlci1hZ2VudCdcXG5dO1xcblxcbi8qKlxcbiAqIFBhcnNlIGhlYWRlcnMgaW50byBhbiBvYmplY3RcXG4gKlxcbiAqIGBgYFxcbiAqIERhdGU6IFdlZCwgMjcgQXVnIDIwMTQgMDg6NTg6NDkgR01UXFxuICogQ29udGVudC1UeXBlOiBhcHBsaWNhdGlvbi9qc29uXFxuICogQ29ubmVjdGlvbjoga2VlcC1hbGl2ZVxcbiAqIFRyYW5zZmVyLUVuY29kaW5nOiBjaHVua2VkXFxuICogYGBgXFxuICpcXG4gKiBAcGFyYW0ge1N0cmluZ30gaGVhZGVycyBIZWFkZXJzIG5lZWRpbmcgdG8gYmUgcGFyc2VkXFxuICogQHJldHVybnMge09iamVjdH0gSGVhZGVycyBwYXJzZWQgaW50byBhbiBvYmplY3RcXG4gKi9cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIHBhcnNlSGVhZGVycyhoZWFkZXJzKSB7XFxuICB2YXIgcGFyc2VkID0ge307XFxuICB2YXIga2V5O1xcbiAgdmFyIHZhbDtcXG4gIHZhciBpO1xcblxcbiAgaWYgKCFoZWFkZXJzKSB7IHJldHVybiBwYXJzZWQ7IH1cXG5cXG4gIHV0aWxzLmZvckVhY2goaGVhZGVycy5zcGxpdCgnXFxcXG4nKSwgZnVuY3Rpb24gcGFyc2VyKGxpbmUpIHtcXG4gICAgaSA9IGxpbmUuaW5kZXhPZignOicpO1xcbiAgICBrZXkgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKDAsIGkpKS50b0xvd2VyQ2FzZSgpO1xcbiAgICB2YWwgPSB1dGlscy50cmltKGxpbmUuc3Vic3RyKGkgKyAxKSk7XFxuXFxuICAgIGlmIChrZXkpIHtcXG4gICAgICBpZiAocGFyc2VkW2tleV0gJiYgaWdub3JlRHVwbGljYXRlT2YuaW5kZXhPZihrZXkpID49IDApIHtcXG4gICAgICAgIHJldHVybjtcXG4gICAgICB9XFxuICAgICAgaWYgKGtleSA9PT0gJ3NldC1jb29raWUnKSB7XFxuICAgICAgICBwYXJzZWRba2V5XSA9IChwYXJzZWRba2V5XSA/IHBhcnNlZFtrZXldIDogW10pLmNvbmNhdChbdmFsXSk7XFxuICAgICAgfSBlbHNlIHtcXG4gICAgICAgIHBhcnNlZFtrZXldID0gcGFyc2VkW2tleV0gPyBwYXJzZWRba2V5XSArICcsICcgKyB2YWwgOiB2YWw7XFxuICAgICAgfVxcbiAgICB9XFxuICB9KTtcXG5cXG4gIHJldHVybiBwYXJzZWQ7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9wYXJzZUhlYWRlcnMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvc3ByZWFkLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3NwcmVhZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuLyoqXFxuICogU3ludGFjdGljIHN1Z2FyIGZvciBpbnZva2luZyBhIGZ1bmN0aW9uIGFuZCBleHBhbmRpbmcgYW4gYXJyYXkgZm9yIGFyZ3VtZW50cy5cXG4gKlxcbiAqIENvbW1vbiB1c2UgY2FzZSB3b3VsZCBiZSB0byB1c2UgYEZ1bmN0aW9uLnByb3RvdHlwZS5hcHBseWAuXFxuICpcXG4gKiAgYGBganNcXG4gKiAgZnVuY3Rpb24gZih4LCB5LCB6KSB7fVxcbiAqICB2YXIgYXJncyA9IFsxLCAyLCAzXTtcXG4gKiAgZi5hcHBseShudWxsLCBhcmdzKTtcXG4gKiAgYGBgXFxuICpcXG4gKiBXaXRoIGBzcHJlYWRgIHRoaXMgZXhhbXBsZSBjYW4gYmUgcmUtd3JpdHRlbi5cXG4gKlxcbiAqICBgYGBqc1xcbiAqICBzcHJlYWQoZnVuY3Rpb24oeCwgeSwgeikge30pKFsxLCAyLCAzXSk7XFxuICogIGBgYFxcbiAqXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gY2FsbGJhY2tcXG4gKiBAcmV0dXJucyB7RnVuY3Rpb259XFxuICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBzcHJlYWQoY2FsbGJhY2spIHtcXG4gIHJldHVybiBmdW5jdGlvbiB3cmFwKGFycikge1xcbiAgICByZXR1cm4gY2FsbGJhY2suYXBwbHkobnVsbCwgYXJyKTtcXG4gIH07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvaGVscGVycy9zcHJlYWQuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL3ZhbGlkYXRvci5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgVkVSU0lPTiA9IChfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuLi9lbnYvZGF0YSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9lbnYvZGF0YS5qc1xcXCIpLnZlcnNpb24pO1xcblxcbnZhciB2YWxpZGF0b3JzID0ge307XFxuXFxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG5bJ29iamVjdCcsICdib29sZWFuJywgJ251bWJlcicsICdmdW5jdGlvbicsICdzdHJpbmcnLCAnc3ltYm9sJ10uZm9yRWFjaChmdW5jdGlvbih0eXBlLCBpKSB7XFxuICB2YWxpZGF0b3JzW3R5cGVdID0gZnVuY3Rpb24gdmFsaWRhdG9yKHRoaW5nKSB7XFxuICAgIHJldHVybiB0eXBlb2YgdGhpbmcgPT09IHR5cGUgfHwgJ2EnICsgKGkgPCAxID8gJ24gJyA6ICcgJykgKyB0eXBlO1xcbiAgfTtcXG59KTtcXG5cXG52YXIgZGVwcmVjYXRlZFdhcm5pbmdzID0ge307XFxuXFxuLyoqXFxuICogVHJhbnNpdGlvbmFsIG9wdGlvbiB2YWxpZGF0b3JcXG4gKiBAcGFyYW0ge2Z1bmN0aW9ufGJvb2xlYW4/fSB2YWxpZGF0b3IgLSBzZXQgdG8gZmFsc2UgaWYgdGhlIHRyYW5zaXRpb25hbCBvcHRpb24gaGFzIGJlZW4gcmVtb3ZlZFxcbiAqIEBwYXJhbSB7c3RyaW5nP30gdmVyc2lvbiAtIGRlcHJlY2F0ZWQgdmVyc2lvbiAvIHJlbW92ZWQgc2luY2UgdmVyc2lvblxcbiAqIEBwYXJhbSB7c3RyaW5nP30gbWVzc2FnZSAtIHNvbWUgbWVzc2FnZSB3aXRoIGFkZGl0aW9uYWwgaW5mb1xcbiAqIEByZXR1cm5zIHtmdW5jdGlvbn1cXG4gKi9cXG52YWxpZGF0b3JzLnRyYW5zaXRpb25hbCA9IGZ1bmN0aW9uIHRyYW5zaXRpb25hbCh2YWxpZGF0b3IsIHZlcnNpb24sIG1lc3NhZ2UpIHtcXG4gIGZ1bmN0aW9uIGZvcm1hdE1lc3NhZ2Uob3B0LCBkZXNjKSB7XFxuICAgIHJldHVybiAnW0F4aW9zIHYnICsgVkVSU0lPTiArICddIFRyYW5zaXRpb25hbCBvcHRpb24gXFxcXCcnICsgb3B0ICsgJ1xcXFwnJyArIGRlc2MgKyAobWVzc2FnZSA/ICcuICcgKyBtZXNzYWdlIDogJycpO1xcbiAgfVxcblxcbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcXG4gIHJldHVybiBmdW5jdGlvbih2YWx1ZSwgb3B0LCBvcHRzKSB7XFxuICAgIGlmICh2YWxpZGF0b3IgPT09IGZhbHNlKSB7XFxuICAgICAgdGhyb3cgbmV3IEVycm9yKGZvcm1hdE1lc3NhZ2Uob3B0LCAnIGhhcyBiZWVuIHJlbW92ZWQnICsgKHZlcnNpb24gPyAnIGluICcgKyB2ZXJzaW9uIDogJycpKSk7XFxuICAgIH1cXG5cXG4gICAgaWYgKHZlcnNpb24gJiYgIWRlcHJlY2F0ZWRXYXJuaW5nc1tvcHRdKSB7XFxuICAgICAgZGVwcmVjYXRlZFdhcm5pbmdzW29wdF0gPSB0cnVlO1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb25zb2xlXFxuICAgICAgY29uc29sZS53YXJuKFxcbiAgICAgICAgZm9ybWF0TWVzc2FnZShcXG4gICAgICAgICAgb3B0LFxcbiAgICAgICAgICAnIGhhcyBiZWVuIGRlcHJlY2F0ZWQgc2luY2UgdicgKyB2ZXJzaW9uICsgJyBhbmQgd2lsbCBiZSByZW1vdmVkIGluIHRoZSBuZWFyIGZ1dHVyZSdcXG4gICAgICAgIClcXG4gICAgICApO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB2YWxpZGF0b3IgPyB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0cykgOiB0cnVlO1xcbiAgfTtcXG59O1xcblxcbi8qKlxcbiAqIEFzc2VydCBvYmplY3QncyBwcm9wZXJ0aWVzIHR5cGVcXG4gKiBAcGFyYW0ge29iamVjdH0gb3B0aW9uc1xcbiAqIEBwYXJhbSB7b2JqZWN0fSBzY2hlbWFcXG4gKiBAcGFyYW0ge2Jvb2xlYW4/fSBhbGxvd1Vua25vd25cXG4gKi9cXG5cXG5mdW5jdGlvbiBhc3NlcnRPcHRpb25zKG9wdGlvbnMsIHNjaGVtYSwgYWxsb3dVbmtub3duKSB7XFxuICBpZiAodHlwZW9mIG9wdGlvbnMgIT09ICdvYmplY3QnKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbnMgbXVzdCBiZSBhbiBvYmplY3QnKTtcXG4gIH1cXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob3B0aW9ucyk7XFxuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xcbiAgd2hpbGUgKGktLSA+IDApIHtcXG4gICAgdmFyIG9wdCA9IGtleXNbaV07XFxuICAgIHZhciB2YWxpZGF0b3IgPSBzY2hlbWFbb3B0XTtcXG4gICAgaWYgKHZhbGlkYXRvcikge1xcbiAgICAgIHZhciB2YWx1ZSA9IG9wdGlvbnNbb3B0XTtcXG4gICAgICB2YXIgcmVzdWx0ID0gdmFsdWUgPT09IHVuZGVmaW5lZCB8fCB2YWxpZGF0b3IodmFsdWUsIG9wdCwgb3B0aW9ucyk7XFxuICAgICAgaWYgKHJlc3VsdCAhPT0gdHJ1ZSkge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uICcgKyBvcHQgKyAnIG11c3QgYmUgJyArIHJlc3VsdCk7XFxuICAgICAgfVxcbiAgICAgIGNvbnRpbnVlO1xcbiAgICB9XFxuICAgIGlmIChhbGxvd1Vua25vd24gIT09IHRydWUpIHtcXG4gICAgICB0aHJvdyBFcnJvcignVW5rbm93biBvcHRpb24gJyArIG9wdCk7XFxuICAgIH1cXG4gIH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICBhc3NlcnRPcHRpb25zOiBhc3NlcnRPcHRpb25zLFxcbiAgdmFsaWRhdG9yczogdmFsaWRhdG9yc1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvYXhpb3MvbGliL2hlbHBlcnMvdmFsaWRhdG9yLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi91dGlscy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2hlbHBlcnMvYmluZCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2xpYi9oZWxwZXJzL2JpbmQuanNcXFwiKTtcXG5cXG4vLyB1dGlscyBpcyBhIGxpYnJhcnkgb2YgZ2VuZXJpYyBoZWxwZXIgZnVuY3Rpb25zIG5vbi1zcGVjaWZpYyB0byBheGlvc1xcblxcbnZhciB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYW4gQXJyYXlcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBBcnJheSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNBcnJheSh2YWwpIHtcXG4gIHJldHVybiBBcnJheS5pc0FycmF5KHZhbCk7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIHVuZGVmaW5lZFxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHRoZSB2YWx1ZSBpcyB1bmRlZmluZWQsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzVW5kZWZpbmVkKHZhbCkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICd1bmRlZmluZWQnO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEJ1ZmZlclxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgQnVmZmVyLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0J1ZmZlcih2YWwpIHtcXG4gIHJldHVybiB2YWwgIT09IG51bGwgJiYgIWlzVW5kZWZpbmVkKHZhbCkgJiYgdmFsLmNvbnN0cnVjdG9yICE9PSBudWxsICYmICFpc1VuZGVmaW5lZCh2YWwuY29uc3RydWN0b3IpXFxuICAgICYmIHR5cGVvZiB2YWwuY29uc3RydWN0b3IuaXNCdWZmZXIgPT09ICdmdW5jdGlvbicgJiYgdmFsLmNvbnN0cnVjdG9yLmlzQnVmZmVyKHZhbCk7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGFuIEFycmF5QnVmZmVyXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXIodmFsKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBBcnJheUJ1ZmZlcl0nO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZvcm1EYXRhXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYW4gRm9ybURhdGEsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzRm9ybURhdGEodmFsKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBGb3JtRGF0YV0nO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXJcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIHZpZXcgb24gYW4gQXJyYXlCdWZmZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzQXJyYXlCdWZmZXJWaWV3KHZhbCkge1xcbiAgdmFyIHJlc3VsdDtcXG4gIGlmICgodHlwZW9mIEFycmF5QnVmZmVyICE9PSAndW5kZWZpbmVkJykgJiYgKEFycmF5QnVmZmVyLmlzVmlldykpIHtcXG4gICAgcmVzdWx0ID0gQXJyYXlCdWZmZXIuaXNWaWV3KHZhbCk7XFxuICB9IGVsc2Uge1xcbiAgICByZXN1bHQgPSAodmFsKSAmJiAodmFsLmJ1ZmZlcikgJiYgKGlzQXJyYXlCdWZmZXIodmFsLmJ1ZmZlcikpO1xcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmluZywgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNTdHJpbmcodmFsKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbCA9PT0gJ3N0cmluZyc7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgTnVtYmVyXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBOdW1iZXIsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzTnVtYmVyKHZhbCkge1xcbiAgcmV0dXJuIHR5cGVvZiB2YWwgPT09ICdudW1iZXInO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhbiBPYmplY3RcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhbiBPYmplY3QsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0KHZhbCkge1xcbiAgcmV0dXJuIHZhbCAhPT0gbnVsbCAmJiB0eXBlb2YgdmFsID09PSAnb2JqZWN0JztcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBwbGFpbiBPYmplY3RcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJuIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgcGxhaW4gT2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbCkge1xcbiAgaWYgKHRvU3RyaW5nLmNhbGwodmFsKSAhPT0gJ1tvYmplY3QgT2JqZWN0XScpIHtcXG4gICAgcmV0dXJuIGZhbHNlO1xcbiAgfVxcblxcbiAgdmFyIHByb3RvdHlwZSA9IE9iamVjdC5nZXRQcm90b3R5cGVPZih2YWwpO1xcbiAgcmV0dXJuIHByb3RvdHlwZSA9PT0gbnVsbCB8fCBwcm90b3R5cGUgPT09IE9iamVjdC5wcm90b3R5cGU7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRGF0ZVxcbiAqXFxuICogQHBhcmFtIHtPYmplY3R9IHZhbCBUaGUgdmFsdWUgdG8gdGVzdFxcbiAqIEByZXR1cm5zIHtib29sZWFufSBUcnVlIGlmIHZhbHVlIGlzIGEgRGF0ZSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNEYXRlKHZhbCkge1xcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xcbn1cXG5cXG4vKipcXG4gKiBEZXRlcm1pbmUgaWYgYSB2YWx1ZSBpcyBhIEZpbGVcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZpbGUsIG90aGVyd2lzZSBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzRmlsZSh2YWwpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IEZpbGVdJztcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBCbG9iXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBCbG9iLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0Jsb2IodmFsKSB7XFxuICByZXR1cm4gdG9TdHJpbmcuY2FsbCh2YWwpID09PSAnW29iamVjdCBCbG9iXSc7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiBhIHZhbHVlIGlzIGEgRnVuY3Rpb25cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIEZ1bmN0aW9uLCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc0Z1bmN0aW9uKHZhbCkge1xcbiAgcmV0dXJuIHRvU3RyaW5nLmNhbGwodmFsKSA9PT0gJ1tvYmplY3QgRnVuY3Rpb25dJztcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBTdHJlYW1cXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSB2YWwgVGhlIHZhbHVlIHRvIHRlc3RcXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gVHJ1ZSBpZiB2YWx1ZSBpcyBhIFN0cmVhbSwgb3RoZXJ3aXNlIGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNTdHJlYW0odmFsKSB7XFxuICByZXR1cm4gaXNPYmplY3QodmFsKSAmJiBpc0Z1bmN0aW9uKHZhbC5waXBlKTtcXG59XFxuXFxuLyoqXFxuICogRGV0ZXJtaW5lIGlmIGEgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0XFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gdmFsIFRoZSB2YWx1ZSB0byB0ZXN0XFxuICogQHJldHVybnMge2Jvb2xlYW59IFRydWUgaWYgdmFsdWUgaXMgYSBVUkxTZWFyY2hQYXJhbXMgb2JqZWN0LCBvdGhlcndpc2UgZmFsc2VcXG4gKi9cXG5mdW5jdGlvbiBpc1VSTFNlYXJjaFBhcmFtcyh2YWwpIHtcXG4gIHJldHVybiB0b1N0cmluZy5jYWxsKHZhbCkgPT09ICdbb2JqZWN0IFVSTFNlYXJjaFBhcmFtc10nO1xcbn1cXG5cXG4vKipcXG4gKiBUcmltIGV4Y2VzcyB3aGl0ZXNwYWNlIG9mZiB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgYSBzdHJpbmdcXG4gKlxcbiAqIEBwYXJhbSB7U3RyaW5nfSBzdHIgVGhlIFN0cmluZyB0byB0cmltXFxuICogQHJldHVybnMge1N0cmluZ30gVGhlIFN0cmluZyBmcmVlZCBvZiBleGNlc3Mgd2hpdGVzcGFjZVxcbiAqL1xcbmZ1bmN0aW9uIHRyaW0oc3RyKSB7XFxuICByZXR1cm4gc3RyLnRyaW0gPyBzdHIudHJpbSgpIDogc3RyLnJlcGxhY2UoL15cXFxccyt8XFxcXHMrJC9nLCAnJyk7XFxufVxcblxcbi8qKlxcbiAqIERldGVybWluZSBpZiB3ZSdyZSBydW5uaW5nIGluIGEgc3RhbmRhcmQgYnJvd3NlciBlbnZpcm9ubWVudFxcbiAqXFxuICogVGhpcyBhbGxvd3MgYXhpb3MgdG8gcnVuIGluIGEgd2ViIHdvcmtlciwgYW5kIHJlYWN0LW5hdGl2ZS5cXG4gKiBCb3RoIGVudmlyb25tZW50cyBzdXBwb3J0IFhNTEh0dHBSZXF1ZXN0LCBidXQgbm90IGZ1bGx5IHN0YW5kYXJkIGdsb2JhbHMuXFxuICpcXG4gKiB3ZWIgd29ya2VyczpcXG4gKiAgdHlwZW9mIHdpbmRvdyAtPiB1bmRlZmluZWRcXG4gKiAgdHlwZW9mIGRvY3VtZW50IC0+IHVuZGVmaW5lZFxcbiAqXFxuICogcmVhY3QtbmF0aXZlOlxcbiAqICBuYXZpZ2F0b3IucHJvZHVjdCAtPiAnUmVhY3ROYXRpdmUnXFxuICogbmF0aXZlc2NyaXB0XFxuICogIG5hdmlnYXRvci5wcm9kdWN0IC0+ICdOYXRpdmVTY3JpcHQnIG9yICdOUydcXG4gKi9cXG5mdW5jdGlvbiBpc1N0YW5kYXJkQnJvd3NlckVudigpIHtcXG4gIGlmICh0eXBlb2YgbmF2aWdhdG9yICE9PSAndW5kZWZpbmVkJyAmJiAobmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZScgfHxcXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbmF2aWdhdG9yLnByb2R1Y3QgPT09ICdOYXRpdmVTY3JpcHQnIHx8XFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5hdmlnYXRvci5wcm9kdWN0ID09PSAnTlMnKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICByZXR1cm4gKFxcbiAgICB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxcbiAgICB0eXBlb2YgZG9jdW1lbnQgIT09ICd1bmRlZmluZWQnXFxuICApO1xcbn1cXG5cXG4vKipcXG4gKiBJdGVyYXRlIG92ZXIgYW4gQXJyYXkgb3IgYW4gT2JqZWN0IGludm9raW5nIGEgZnVuY3Rpb24gZm9yIGVhY2ggaXRlbS5cXG4gKlxcbiAqIElmIGBvYmpgIGlzIGFuIEFycmF5IGNhbGxiYWNrIHdpbGwgYmUgY2FsbGVkIHBhc3NpbmdcXG4gKiB0aGUgdmFsdWUsIGluZGV4LCBhbmQgY29tcGxldGUgYXJyYXkgZm9yIGVhY2ggaXRlbS5cXG4gKlxcbiAqIElmICdvYmonIGlzIGFuIE9iamVjdCBjYWxsYmFjayB3aWxsIGJlIGNhbGxlZCBwYXNzaW5nXFxuICogdGhlIHZhbHVlLCBrZXksIGFuZCBjb21wbGV0ZSBvYmplY3QgZm9yIGVhY2ggcHJvcGVydHkuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdHxBcnJheX0gb2JqIFRoZSBvYmplY3QgdG8gaXRlcmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZuIFRoZSBjYWxsYmFjayB0byBpbnZva2UgZm9yIGVhY2ggaXRlbVxcbiAqL1xcbmZ1bmN0aW9uIGZvckVhY2gob2JqLCBmbikge1xcbiAgLy8gRG9uJ3QgYm90aGVyIGlmIG5vIHZhbHVlIHByb3ZpZGVkXFxuICBpZiAob2JqID09PSBudWxsIHx8IHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XFxuICAgIHJldHVybjtcXG4gIH1cXG5cXG4gIC8vIEZvcmNlIGFuIGFycmF5IGlmIG5vdCBhbHJlYWR5IHNvbWV0aGluZyBpdGVyYWJsZVxcbiAgaWYgKHR5cGVvZiBvYmogIT09ICdvYmplY3QnKSB7XFxuICAgIC8qZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOjAqL1xcbiAgICBvYmogPSBbb2JqXTtcXG4gIH1cXG5cXG4gIGlmIChpc0FycmF5KG9iaikpIHtcXG4gICAgLy8gSXRlcmF0ZSBvdmVyIGFycmF5IHZhbHVlc1xcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IG9iai5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgICBmbi5jYWxsKG51bGwsIG9ialtpXSwgaSwgb2JqKTtcXG4gICAgfVxcbiAgfSBlbHNlIHtcXG4gICAgLy8gSXRlcmF0ZSBvdmVyIG9iamVjdCBrZXlzXFxuICAgIGZvciAodmFyIGtleSBpbiBvYmopIHtcXG4gICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKG9iaiwga2V5KSkge1xcbiAgICAgICAgZm4uY2FsbChudWxsLCBvYmpba2V5XSwga2V5LCBvYmopO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbn1cXG5cXG4vKipcXG4gKiBBY2NlcHRzIHZhcmFyZ3MgZXhwZWN0aW5nIGVhY2ggYXJndW1lbnQgdG8gYmUgYW4gb2JqZWN0LCB0aGVuXFxuICogaW1tdXRhYmx5IG1lcmdlcyB0aGUgcHJvcGVydGllcyBvZiBlYWNoIG9iamVjdCBhbmQgcmV0dXJucyByZXN1bHQuXFxuICpcXG4gKiBXaGVuIG11bHRpcGxlIG9iamVjdHMgY29udGFpbiB0aGUgc2FtZSBrZXkgdGhlIGxhdGVyIG9iamVjdCBpblxcbiAqIHRoZSBhcmd1bWVudHMgbGlzdCB3aWxsIHRha2UgcHJlY2VkZW5jZS5cXG4gKlxcbiAqIEV4YW1wbGU6XFxuICpcXG4gKiBgYGBqc1xcbiAqIHZhciByZXN1bHQgPSBtZXJnZSh7Zm9vOiAxMjN9LCB7Zm9vOiA0NTZ9KTtcXG4gKiBjb25zb2xlLmxvZyhyZXN1bHQuZm9vKTsgLy8gb3V0cHV0cyA0NTZcXG4gKiBgYGBcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0fSBvYmoxIE9iamVjdCB0byBtZXJnZVxcbiAqIEByZXR1cm5zIHtPYmplY3R9IFJlc3VsdCBvZiBhbGwgbWVyZ2UgcHJvcGVydGllc1xcbiAqL1xcbmZ1bmN0aW9uIG1lcmdlKC8qIG9iajEsIG9iajIsIG9iajMsIC4uLiAqLykge1xcbiAgdmFyIHJlc3VsdCA9IHt9O1xcbiAgZnVuY3Rpb24gYXNzaWduVmFsdWUodmFsLCBrZXkpIHtcXG4gICAgaWYgKGlzUGxhaW5PYmplY3QocmVzdWx0W2tleV0pICYmIGlzUGxhaW5PYmplY3QodmFsKSkge1xcbiAgICAgIHJlc3VsdFtrZXldID0gbWVyZ2UocmVzdWx0W2tleV0sIHZhbCk7XFxuICAgIH0gZWxzZSBpZiAoaXNQbGFpbk9iamVjdCh2YWwpKSB7XFxuICAgICAgcmVzdWx0W2tleV0gPSBtZXJnZSh7fSwgdmFsKTtcXG4gICAgfSBlbHNlIGlmIChpc0FycmF5KHZhbCkpIHtcXG4gICAgICByZXN1bHRba2V5XSA9IHZhbC5zbGljZSgpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgIHJlc3VsdFtrZXldID0gdmFsO1xcbiAgICB9XFxuICB9XFxuXFxuICBmb3IgKHZhciBpID0gMCwgbCA9IGFyZ3VtZW50cy5sZW5ndGg7IGkgPCBsOyBpKyspIHtcXG4gICAgZm9yRWFjaChhcmd1bWVudHNbaV0sIGFzc2lnblZhbHVlKTtcXG4gIH1cXG4gIHJldHVybiByZXN1bHQ7XFxufVxcblxcbi8qKlxcbiAqIEV4dGVuZHMgb2JqZWN0IGEgYnkgbXV0YWJseSBhZGRpbmcgdG8gaXQgdGhlIHByb3BlcnRpZXMgb2Ygb2JqZWN0IGIuXFxuICpcXG4gKiBAcGFyYW0ge09iamVjdH0gYSBUaGUgb2JqZWN0IHRvIGJlIGV4dGVuZGVkXFxuICogQHBhcmFtIHtPYmplY3R9IGIgVGhlIG9iamVjdCB0byBjb3B5IHByb3BlcnRpZXMgZnJvbVxcbiAqIEBwYXJhbSB7T2JqZWN0fSB0aGlzQXJnIFRoZSBvYmplY3QgdG8gYmluZCBmdW5jdGlvbiB0b1xcbiAqIEByZXR1cm4ge09iamVjdH0gVGhlIHJlc3VsdGluZyB2YWx1ZSBvZiBvYmplY3QgYVxcbiAqL1xcbmZ1bmN0aW9uIGV4dGVuZChhLCBiLCB0aGlzQXJnKSB7XFxuICBmb3JFYWNoKGIsIGZ1bmN0aW9uIGFzc2lnblZhbHVlKHZhbCwga2V5KSB7XFxuICAgIGlmICh0aGlzQXJnICYmIHR5cGVvZiB2YWwgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICBhW2tleV0gPSBiaW5kKHZhbCwgdGhpc0FyZyk7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgYVtrZXldID0gdmFsO1xcbiAgICB9XFxuICB9KTtcXG4gIHJldHVybiBhO1xcbn1cXG5cXG4vKipcXG4gKiBSZW1vdmUgYnl0ZSBvcmRlciBtYXJrZXIuIFRoaXMgY2F0Y2hlcyBFRiBCQiBCRiAodGhlIFVURi04IEJPTSlcXG4gKlxcbiAqIEBwYXJhbSB7c3RyaW5nfSBjb250ZW50IHdpdGggQk9NXFxuICogQHJldHVybiB7c3RyaW5nfSBjb250ZW50IHZhbHVlIHdpdGhvdXQgQk9NXFxuICovXFxuZnVuY3Rpb24gc3RyaXBCT00oY29udGVudCkge1xcbiAgaWYgKGNvbnRlbnQuY2hhckNvZGVBdCgwKSA9PT0gMHhGRUZGKSB7XFxuICAgIGNvbnRlbnQgPSBjb250ZW50LnNsaWNlKDEpO1xcbiAgfVxcbiAgcmV0dXJuIGNvbnRlbnQ7XFxufVxcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgaXNBcnJheTogaXNBcnJheSxcXG4gIGlzQXJyYXlCdWZmZXI6IGlzQXJyYXlCdWZmZXIsXFxuICBpc0J1ZmZlcjogaXNCdWZmZXIsXFxuICBpc0Zvcm1EYXRhOiBpc0Zvcm1EYXRhLFxcbiAgaXNBcnJheUJ1ZmZlclZpZXc6IGlzQXJyYXlCdWZmZXJWaWV3LFxcbiAgaXNTdHJpbmc6IGlzU3RyaW5nLFxcbiAgaXNOdW1iZXI6IGlzTnVtYmVyLFxcbiAgaXNPYmplY3Q6IGlzT2JqZWN0LFxcbiAgaXNQbGFpbk9iamVjdDogaXNQbGFpbk9iamVjdCxcXG4gIGlzVW5kZWZpbmVkOiBpc1VuZGVmaW5lZCxcXG4gIGlzRGF0ZTogaXNEYXRlLFxcbiAgaXNGaWxlOiBpc0ZpbGUsXFxuICBpc0Jsb2I6IGlzQmxvYixcXG4gIGlzRnVuY3Rpb246IGlzRnVuY3Rpb24sXFxuICBpc1N0cmVhbTogaXNTdHJlYW0sXFxuICBpc1VSTFNlYXJjaFBhcmFtczogaXNVUkxTZWFyY2hQYXJhbXMsXFxuICBpc1N0YW5kYXJkQnJvd3NlckVudjogaXNTdGFuZGFyZEJyb3dzZXJFbnYsXFxuICBmb3JFYWNoOiBmb3JFYWNoLFxcbiAgbWVyZ2U6IG1lcmdlLFxcbiAgZXh0ZW5kOiBleHRlbmQsXFxuICB0cmltOiB0cmltLFxcbiAgc3RyaXBCT006IHN0cmlwQk9NXFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9heGlvcy9saWIvdXRpbHMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvY2FsbC1iaW5kL2NhbGxCb3VuZC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGdldC1pbnRyaW5zaWMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzXFxcIik7XFxuXFxudmFyIGNhbGxCaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi8gKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanNcXFwiKTtcXG5cXG52YXIgJGluZGV4T2YgPSBjYWxsQmluZChHZXRJbnRyaW5zaWMoJ1N0cmluZy5wcm90b3R5cGUuaW5kZXhPZicpKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGNhbGxCb3VuZEludHJpbnNpYyhuYW1lLCBhbGxvd01pc3NpbmcpIHtcXG5cXHR2YXIgaW50cmluc2ljID0gR2V0SW50cmluc2ljKG5hbWUsICEhYWxsb3dNaXNzaW5nKTtcXG5cXHRpZiAodHlwZW9mIGludHJpbnNpYyA9PT0gJ2Z1bmN0aW9uJyAmJiAkaW5kZXhPZihuYW1lLCAnLnByb3RvdHlwZS4nKSA+IC0xKSB7XFxuXFx0XFx0cmV0dXJuIGNhbGxCaW5kKGludHJpbnNpYyk7XFxuXFx0fVxcblxcdHJldHVybiBpbnRyaW5zaWM7XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2NhbGwtYmluZC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmdW5jdGlvbi1iaW5kICovIFxcXCIuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qc1xcXCIpO1xcbnZhciBHZXRJbnRyaW5zaWMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBnZXQtaW50cmluc2ljICovIFxcXCIuLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qc1xcXCIpO1xcblxcbnZhciAkYXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHklJyk7XFxudmFyICRjYWxsID0gR2V0SW50cmluc2ljKCclRnVuY3Rpb24ucHJvdG90eXBlLmNhbGwlJyk7XFxudmFyICRyZWZsZWN0QXBwbHkgPSBHZXRJbnRyaW5zaWMoJyVSZWZsZWN0LmFwcGx5JScsIHRydWUpIHx8IGJpbmQuY2FsbCgkY2FsbCwgJGFwcGx5KTtcXG5cXG52YXIgJGdPUEQgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yJScsIHRydWUpO1xcbnZhciAkZGVmaW5lUHJvcGVydHkgPSBHZXRJbnRyaW5zaWMoJyVPYmplY3QuZGVmaW5lUHJvcGVydHklJywgdHJ1ZSk7XFxudmFyICRtYXggPSBHZXRJbnRyaW5zaWMoJyVNYXRoLm1heCUnKTtcXG5cXG5pZiAoJGRlZmluZVByb3BlcnR5KSB7XFxuXFx0dHJ5IHtcXG5cXHRcXHQkZGVmaW5lUHJvcGVydHkoe30sICdhJywgeyB2YWx1ZTogMSB9KTtcXG5cXHR9IGNhdGNoIChlKSB7XFxuXFx0XFx0Ly8gSUUgOCBoYXMgYSBicm9rZW4gZGVmaW5lUHJvcGVydHlcXG5cXHRcXHQkZGVmaW5lUHJvcGVydHkgPSBudWxsO1xcblxcdH1cXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBjYWxsQmluZChvcmlnaW5hbEZ1bmN0aW9uKSB7XFxuXFx0dmFyIGZ1bmMgPSAkcmVmbGVjdEFwcGx5KGJpbmQsICRjYWxsLCBhcmd1bWVudHMpO1xcblxcdGlmICgkZ09QRCAmJiAkZGVmaW5lUHJvcGVydHkpIHtcXG5cXHRcXHR2YXIgZGVzYyA9ICRnT1BEKGZ1bmMsICdsZW5ndGgnKTtcXG5cXHRcXHRpZiAoZGVzYy5jb25maWd1cmFibGUpIHtcXG5cXHRcXHRcXHQvLyBvcmlnaW5hbCBsZW5ndGgsIHBsdXMgdGhlIHJlY2VpdmVyLCBtaW51cyBhbnkgYWRkaXRpb25hbCBhcmd1bWVudHMgKGFmdGVyIHRoZSByZWNlaXZlcilcXG5cXHRcXHRcXHQkZGVmaW5lUHJvcGVydHkoXFxuXFx0XFx0XFx0XFx0ZnVuYyxcXG5cXHRcXHRcXHRcXHQnbGVuZ3RoJyxcXG5cXHRcXHRcXHRcXHR7IHZhbHVlOiAxICsgJG1heCgwLCBvcmlnaW5hbEZ1bmN0aW9uLmxlbmd0aCAtIChhcmd1bWVudHMubGVuZ3RoIC0gMSkpIH1cXG5cXHRcXHRcXHQpO1xcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIGZ1bmM7XFxufTtcXG5cXG52YXIgYXBwbHlCaW5kID0gZnVuY3Rpb24gYXBwbHlCaW5kKCkge1xcblxcdHJldHVybiAkcmVmbGVjdEFwcGx5KGJpbmQsICRhcHBseSwgYXJndW1lbnRzKTtcXG59O1xcblxcbmlmICgkZGVmaW5lUHJvcGVydHkpIHtcXG5cXHQkZGVmaW5lUHJvcGVydHkobW9kdWxlLmV4cG9ydHMsICdhcHBseScsIHsgdmFsdWU6IGFwcGx5QmluZCB9KTtcXG59IGVsc2Uge1xcblxcdG1vZHVsZS5leHBvcnRzLmFwcGx5ID0gYXBwbHlCaW5kO1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvY29udGVudGZ1bC1yZXNvbHZlLXJlc3BvbnNlL2Rpc3QvZXNtL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZS9kaXN0L2VzbS9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKF9fV0VCUEFDS19ERUZBVUxUX0VYUE9SVF9fKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmYXN0X2NvcHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGZhc3QtY29weSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtY29weS9kaXN0L2Zhc3QtY29weS5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBmYXN0X2NvcHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihmYXN0X2NvcHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxudmFyIF90eXBlb2YgPSB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09IFxcXCJzeW1ib2xcXFwiID8gZnVuY3Rpb24gKG9iaikgeyByZXR1cm4gdHlwZW9mIG9iajsgfSA6IGZ1bmN0aW9uIChvYmopIHsgcmV0dXJuIG9iaiAmJiB0eXBlb2YgU3ltYm9sID09PSBcXFwiZnVuY3Rpb25cXFwiICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajsgfTtcXG5cXG52YXIgX3NsaWNlZFRvQXJyYXkgPSBmdW5jdGlvbiAoKSB7IGZ1bmN0aW9uIHNsaWNlSXRlcmF0b3IoYXJyLCBpKSB7IHZhciBfYXJyID0gW107IHZhciBfbiA9IHRydWU7IHZhciBfZCA9IGZhbHNlOyB2YXIgX2UgPSB1bmRlZmluZWQ7IHRyeSB7IGZvciAodmFyIF9pID0gYXJyW1N5bWJvbC5pdGVyYXRvcl0oKSwgX3M7ICEoX24gPSAoX3MgPSBfaS5uZXh0KCkpLmRvbmUpOyBfbiA9IHRydWUpIHsgX2Fyci5wdXNoKF9zLnZhbHVlKTsgaWYgKGkgJiYgX2Fyci5sZW5ndGggPT09IGkpIGJyZWFrOyB9IH0gY2F0Y2ggKGVycikgeyBfZCA9IHRydWU7IF9lID0gZXJyOyB9IGZpbmFsbHkgeyB0cnkgeyBpZiAoIV9uICYmIF9pW1xcXCJyZXR1cm5cXFwiXSkgX2lbXFxcInJldHVyblxcXCJdKCk7IH0gZmluYWxseSB7IGlmIChfZCkgdGhyb3cgX2U7IH0gfSByZXR1cm4gX2FycjsgfSByZXR1cm4gZnVuY3Rpb24gKGFyciwgaSkgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IHJldHVybiBhcnI7IH0gZWxzZSBpZiAoU3ltYm9sLml0ZXJhdG9yIGluIE9iamVjdChhcnIpKSB7IHJldHVybiBzbGljZUl0ZXJhdG9yKGFyciwgaSk7IH0gZWxzZSB7IHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2VcXFwiKTsgfSB9OyB9KCk7XFxuXFxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikgeyBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSB7IGZvciAodmFyIGkgPSAwLCBhcnIyID0gQXJyYXkoYXJyLmxlbmd0aCk7IGkgPCBhcnIubGVuZ3RoOyBpKyspIHsgYXJyMltpXSA9IGFycltpXTsgfSByZXR1cm4gYXJyMjsgfSBlbHNlIHsgcmV0dXJuIEFycmF5LmZyb20oYXJyKTsgfSB9XFxuXFxuXFxuXFxudmFyIFVOUkVTT0xWRURfTElOSyA9IHt9OyAvLyB1bmlxdWUgb2JqZWN0IHRvIGF2b2lkIHBvbHlmaWxsIGJsb2F0IHVzaW5nIFN5bWJvbCgpXFxuXFxuLyoqXFxuICogaXNMaW5rIEZ1bmN0aW9uXFxuICogQ2hlY2tzIGlmIHRoZSBvYmplY3QgaGFzIHN5cy50eXBlIFxcXCJMaW5rXFxcIlxcbiAqIEBwYXJhbSBvYmplY3RcXG4gKi9cXG52YXIgaXNMaW5rID0gZnVuY3Rpb24gaXNMaW5rKG9iamVjdCkge1xcbiAgcmV0dXJuIG9iamVjdCAmJiBvYmplY3Quc3lzICYmIG9iamVjdC5zeXMudHlwZSA9PT0gJ0xpbmsnO1xcbn07XFxuXFxuLyoqXFxuICogaXNSZXNvdXJjZUxpbmsgRnVuY3Rpb25cXG4gKiBDaGVja3MgaWYgdGhlIG9iamVjdCBoYXMgc3lzLnR5cGUgXFxcIlJlc291cmNlTGlua1xcXCJcXG4gKiBAcGFyYW0gb2JqZWN0XFxuICovXFxudmFyIGlzUmVzb3VyY2VMaW5rID0gZnVuY3Rpb24gaXNSZXNvdXJjZUxpbmsob2JqZWN0KSB7XFxuICByZXR1cm4gb2JqZWN0ICYmIG9iamVjdC5zeXMgJiYgb2JqZWN0LnN5cy50eXBlID09PSAnUmVzb3VyY2VMaW5rJztcXG59O1xcblxcbi8qKlxcbiAqIENyZWF0ZXMgYSBrZXkgd2l0aCBzcGFjZUlkIGFuZCBhIGtleSB3aXRob3V0IGZvciBlbnRpdHlNYXBcXG4gKlxcbiAqIEBwYXJhbSB7Kn0gc3lzXFxuICogQHBhcmFtIHtTdHJpbmd9IHN5cy50eXBlXFxuICogQHBhcmFtIHtTdHJpbmd9IHN5cy5pZFxcbiAqIEBwYXJhbSB7Kn0gc3lzLnNwYWNlXFxuICogQHBhcmFtIHsqfSBzeXMuc3BhY2Uuc3lzXFxuICogQHBhcmFtIHtTdHJpbmd9IHN5cy5zcGFjZS5pZFxcbiAqIEByZXR1cm4ge3N0cmluZ1tdfVxcbiAqL1xcbnZhciBtYWtlRW50aXR5TWFwS2V5cyA9IGZ1bmN0aW9uIG1ha2VFbnRpdHlNYXBLZXlzKHN5cykge1xcbiAgcmV0dXJuIHN5cy5zcGFjZSA/IFtzeXMudHlwZSArICchJyArIHN5cy5pZCwgc3lzLnNwYWNlLnN5cy5pZCArICchJyArIHN5cy50eXBlICsgJyEnICsgc3lzLmlkXSA6IFtzeXMudHlwZSArICchJyArIHN5cy5pZF07XFxufTtcXG5cXG4vKipcXG4gKiBMb29rcyB1cCBpbiBlbnRpdHlNYXBcXG4gKlxcbiAqIEBwYXJhbSBlbnRpdHlNYXBcXG4gKiBAcGFyYW0geyp9IGxpbmtEYXRhXFxuICogQHBhcmFtIHtTdHJpbmd9IGxpbmtEYXRhLnR5cGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlua0RhdGEubGlua1R5cGVcXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlua0RhdGEuaWRcXG4gKiBAcGFyYW0ge1N0cmluZ30gbGlua0RhdGEudXJuXFxuICogQHJldHVybiB7U3RyaW5nfVxcbiAqL1xcbnZhciBsb29rdXBJbkVudGl0eU1hcCA9IGZ1bmN0aW9uIGxvb2t1cEluRW50aXR5TWFwKGVudGl0eU1hcCwgbGlua0RhdGEpIHtcXG4gIHZhciBlbnRyeUlkID0gbGlua0RhdGEuZW50cnlJZCxcXG4gICAgICBsaW5rVHlwZSA9IGxpbmtEYXRhLmxpbmtUeXBlLFxcbiAgICAgIHNwYWNlSWQgPSBsaW5rRGF0YS5zcGFjZUlkO1xcblxcbiAgaWYgKHNwYWNlSWQpIHtcXG4gICAgcmV0dXJuIGVudGl0eU1hcC5nZXQoc3BhY2VJZCArICchJyArIGxpbmtUeXBlICsgJyEnICsgZW50cnlJZCk7XFxuICB9XFxuICByZXR1cm4gZW50aXR5TWFwLmdldChsaW5rVHlwZSArICchJyArIGVudHJ5SWQpO1xcbn07XFxuXFxuLyoqXFxuICogZ2V0UmVzb2x2ZWRMaW5rIEZ1bmN0aW9uXFxuICpcXG4gKiBAcGFyYW0gZW50aXR5TWFwXFxuICogQHBhcmFtIGxpbmtcXG4gKiBAcmV0dXJuIHt1bmRlZmluZWR9XFxuICovXFxudmFyIGdldFJlc29sdmVkTGluayA9IGZ1bmN0aW9uIGdldFJlc29sdmVkTGluayhlbnRpdHlNYXAsIGxpbmspIHtcXG4gIHZhciBfbGluayRzeXMgPSBsaW5rLnN5cyxcXG4gICAgICB0eXBlID0gX2xpbmskc3lzLnR5cGUsXFxuICAgICAgbGlua1R5cGUgPSBfbGluayRzeXMubGlua1R5cGU7XFxuXFxuICBpZiAodHlwZSA9PT0gJ1Jlc291cmNlTGluaycpIHtcXG4gICAgdmFyIHVybiA9IGxpbmsuc3lzLnVybjtcXG5cXG4gICAgdmFyIHJlZ0V4cCA9IC8uKjpzcGFjZXNcXFxcLyhbQS1aYS16MC05XSopXFxcXC9lbnRyaWVzXFxcXC8oW0EtWmEtejAtOV0qKS87XFxuICAgIGlmICghcmVnRXhwLnRlc3QodXJuKSkge1xcbiAgICAgIHJldHVybiBVTlJFU09MVkVEX0xJTks7XFxuICAgIH1cXG5cXG4gICAgdmFyIF91cm4kbWF0Y2ggPSB1cm4ubWF0Y2gocmVnRXhwKSxcXG4gICAgICAgIF91cm4kbWF0Y2gyID0gX3NsaWNlZFRvQXJyYXkoX3VybiRtYXRjaCwgMyksXFxuICAgICAgICBfID0gX3VybiRtYXRjaDJbMF0sXFxuICAgICAgICBzcGFjZUlkID0gX3VybiRtYXRjaDJbMV0sXFxuICAgICAgICBfZW50cnlJZCA9IF91cm4kbWF0Y2gyWzJdO1xcblxcbiAgICB2YXIgZXh0cmFjdGVkTGlua1R5cGUgPSBsaW5rVHlwZS5zcGxpdCgnOicpWzFdO1xcbiAgICByZXR1cm4gbG9va3VwSW5FbnRpdHlNYXAoZW50aXR5TWFwLCB7IGxpbmtUeXBlOiBleHRyYWN0ZWRMaW5rVHlwZSwgZW50cnlJZDogX2VudHJ5SWQsIHNwYWNlSWQ6IHNwYWNlSWQgfSkgfHwgVU5SRVNPTFZFRF9MSU5LO1xcbiAgfVxcbiAgdmFyIGVudHJ5SWQgPSBsaW5rLnN5cy5pZDtcXG5cXG4gIHJldHVybiBsb29rdXBJbkVudGl0eU1hcChlbnRpdHlNYXAsIHsgbGlua1R5cGU6IGxpbmtUeXBlLCBlbnRyeUlkOiBlbnRyeUlkIH0pIHx8IFVOUkVTT0xWRURfTElOSztcXG59O1xcblxcbi8qKlxcbiAqIGNsZWFuVXBMaW5rcyBGdW5jdGlvblxcbiAqIC0gUmVtb3ZlcyB1bnJlc29sdmFibGUgbGlua3MgZnJvbSBBcnJheXMgYW5kIE9iamVjdHNcXG4gKlxcbiAqIEBwYXJhbSB7T2JqZWN0W118T2JqZWN0fSBpbnB1dFxcbiAqL1xcbnZhciBjbGVhblVwTGlua3MgPSBmdW5jdGlvbiBjbGVhblVwTGlua3MoaW5wdXQpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkge1xcbiAgICByZXR1cm4gaW5wdXQuZmlsdGVyKGZ1bmN0aW9uICh2YWwpIHtcXG4gICAgICByZXR1cm4gdmFsICE9PSBVTlJFU09MVkVEX0xJTks7XFxuICAgIH0pO1xcbiAgfVxcbiAgZm9yICh2YXIga2V5IGluIGlucHV0KSB7XFxuICAgIGlmIChpbnB1dFtrZXldID09PSBVTlJFU09MVkVEX0xJTkspIHtcXG4gICAgICBkZWxldGUgaW5wdXRba2V5XTtcXG4gICAgfVxcbiAgfVxcbiAgcmV0dXJuIGlucHV0O1xcbn07XFxuXFxuLyoqXFxuICogd2Fsa011dGF0ZSBGdW5jdGlvblxcbiAqIEBwYXJhbSBpbnB1dFxcbiAqIEBwYXJhbSBwcmVkaWNhdGVcXG4gKiBAcGFyYW0gbXV0YXRvclxcbiAqIEBwYXJhbSByZW1vdmVVbnJlc29sdmVkXFxuICogQHJldHVybiB7Kn1cXG4gKi9cXG52YXIgd2Fsa011dGF0ZSA9IGZ1bmN0aW9uIHdhbGtNdXRhdGUoaW5wdXQsIHByZWRpY2F0ZSwgbXV0YXRvciwgcmVtb3ZlVW5yZXNvbHZlZCkge1xcbiAgaWYgKHByZWRpY2F0ZShpbnB1dCkpIHtcXG4gICAgcmV0dXJuIG11dGF0b3IoaW5wdXQpO1xcbiAgfVxcblxcbiAgaWYgKGlucHV0ICYmICh0eXBlb2YgaW5wdXQgPT09ICd1bmRlZmluZWQnID8gJ3VuZGVmaW5lZCcgOiBfdHlwZW9mKGlucHV0KSkgPT09ICdvYmplY3QnKSB7XFxuICAgIGZvciAodmFyIGtleSBpbiBpbnB1dCkge1xcbiAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1wcm90b3R5cGUtYnVpbHRpbnNcXG4gICAgICBpZiAoaW5wdXQuaGFzT3duUHJvcGVydHkoa2V5KSkge1xcbiAgICAgICAgaW5wdXRba2V5XSA9IHdhbGtNdXRhdGUoaW5wdXRba2V5XSwgcHJlZGljYXRlLCBtdXRhdG9yLCByZW1vdmVVbnJlc29sdmVkKTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHJlbW92ZVVucmVzb2x2ZWQpIHtcXG4gICAgICBpbnB1dCA9IGNsZWFuVXBMaW5rcyhpbnB1dCk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBpbnB1dDtcXG59O1xcblxcbnZhciBub3JtYWxpemVMaW5rID0gZnVuY3Rpb24gbm9ybWFsaXplTGluayhlbnRpdHlNYXAsIGxpbmssIHJlbW92ZVVucmVzb2x2ZWQpIHtcXG4gIHZhciByZXNvbHZlZExpbmsgPSBnZXRSZXNvbHZlZExpbmsoZW50aXR5TWFwLCBsaW5rKTtcXG4gIGlmIChyZXNvbHZlZExpbmsgPT09IFVOUkVTT0xWRURfTElOSykge1xcbiAgICByZXR1cm4gcmVtb3ZlVW5yZXNvbHZlZCA/IHJlc29sdmVkTGluayA6IGxpbms7XFxuICB9XFxuICByZXR1cm4gcmVzb2x2ZWRMaW5rO1xcbn07XFxuXFxudmFyIG1ha2VFbnRyeU9iamVjdCA9IGZ1bmN0aW9uIG1ha2VFbnRyeU9iamVjdChpdGVtLCBpdGVtRW50cnlQb2ludHMpIHtcXG4gIGlmICghQXJyYXkuaXNBcnJheShpdGVtRW50cnlQb2ludHMpKSB7XFxuICAgIHJldHVybiBpdGVtO1xcbiAgfVxcblxcbiAgdmFyIGVudHJ5UG9pbnRzID0gT2JqZWN0LmtleXMoaXRlbSkuZmlsdGVyKGZ1bmN0aW9uIChvd25LZXkpIHtcXG4gICAgcmV0dXJuIGl0ZW1FbnRyeVBvaW50cy5pbmRleE9mKG93bktleSkgIT09IC0xO1xcbiAgfSk7XFxuXFxuICByZXR1cm4gZW50cnlQb2ludHMucmVkdWNlKGZ1bmN0aW9uIChlbnRyeU9iaiwgZW50cnlQb2ludCkge1xcbiAgICBlbnRyeU9ialtlbnRyeVBvaW50XSA9IGl0ZW1bZW50cnlQb2ludF07XFxuICAgIHJldHVybiBlbnRyeU9iajtcXG4gIH0sIHt9KTtcXG59O1xcblxcbi8qKlxcbiAqIHJlc29sdmVSZXNwb25zZSBGdW5jdGlvblxcbiAqIFJlc29sdmVzIGNvbnRlbnRmdWwgcmVzcG9uc2UgdG8gbm9ybWFsaXplZCBmb3JtLlxcbiAqIEBwYXJhbSB7T2JqZWN0fSByZXNwb25zZSBDb250ZW50ZnVsIHJlc3BvbnNlXFxuICogQHBhcmFtIHt7cmVtb3ZlVW5yZXNvbHZlZDogQm9vbGVhbiwgaXRlbUVudHJ5UG9pbnRzOiBBcnJheTxTdHJpbmc+fXx7fX0gb3B0aW9uc1xcbiAqIEBwYXJhbSB7Qm9vbGVhbn0gb3B0aW9ucy5yZW1vdmVVbnJlc29sdmVkIC0gUmVtb3ZlIHVucmVzb2x2ZWQgbGlua3MgZGVmYXVsdDpmYWxzZVxcbiAqIEBwYXJhbSB7QXJyYXk8U3RyaW5nPn0gb3B0aW9ucy5pdGVtRW50cnlQb2ludHMgLSBSZXNvbHZlIGxpbmtzIG9ubHkgaW4gdGhvc2UgaXRlbSBwcm9wZXJ0aWVzXFxuICogQHJldHVybiB7T2JqZWN0fVxcbiAqL1xcbnZhciByZXNvbHZlUmVzcG9uc2UgPSBmdW5jdGlvbiByZXNvbHZlUmVzcG9uc2UocmVzcG9uc2UsIG9wdGlvbnMpIHtcXG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xcbiAgaWYgKCFyZXNwb25zZS5pdGVtcykge1xcbiAgICByZXR1cm4gW107XFxuICB9XFxuICB2YXIgcmVzcG9uc2VDbG9uZSA9IGZhc3RfY29weV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShyZXNwb25zZSk7XFxuICB2YXIgYWxsSW5jbHVkZXMgPSBPYmplY3Qua2V5cyhyZXNwb25zZUNsb25lLmluY2x1ZGVzIHx8IHt9KS5yZWR1Y2UoZnVuY3Rpb24gKGFsbCwgdHlwZSkge1xcbiAgICByZXR1cm4gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShhbGwpLCBfdG9Db25zdW1hYmxlQXJyYXkocmVzcG9uc2UuaW5jbHVkZXNbdHlwZV0pKTtcXG4gIH0sIFtdKTtcXG5cXG4gIHZhciBhbGxFbnRyaWVzID0gW10uY29uY2F0KF90b0NvbnN1bWFibGVBcnJheShyZXNwb25zZUNsb25lLml0ZW1zKSwgX3RvQ29uc3VtYWJsZUFycmF5KGFsbEluY2x1ZGVzKSkuZmlsdGVyKGZ1bmN0aW9uIChlbnRpdHkpIHtcXG4gICAgcmV0dXJuIEJvb2xlYW4oZW50aXR5LnN5cyk7XFxuICB9KTtcXG5cXG4gIHZhciBlbnRpdHlNYXAgPSBuZXcgTWFwKGFsbEVudHJpZXMucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGVudGl0eSkge1xcbiAgICB2YXIgZW50cmllcyA9IG1ha2VFbnRpdHlNYXBLZXlzKGVudGl0eS5zeXMpLm1hcChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgcmV0dXJuIFtrZXksIGVudGl0eV07XFxuICAgIH0pO1xcbiAgICBhY2MucHVzaC5hcHBseShhY2MsIF90b0NvbnN1bWFibGVBcnJheShlbnRyaWVzKSk7XFxuICAgIHJldHVybiBhY2M7XFxuICB9LCBbXSkpO1xcblxcbiAgYWxsRW50cmllcy5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIHZhciBlbnRyeU9iamVjdCA9IG1ha2VFbnRyeU9iamVjdChpdGVtLCBvcHRpb25zLml0ZW1FbnRyeVBvaW50cyk7XFxuXFxuICAgIE9iamVjdC5hc3NpZ24oaXRlbSwgd2Fsa011dGF0ZShlbnRyeU9iamVjdCwgZnVuY3Rpb24gKHgpIHtcXG4gICAgICByZXR1cm4gaXNMaW5rKHgpIHx8IGlzUmVzb3VyY2VMaW5rKHgpO1xcbiAgICB9LCBmdW5jdGlvbiAobGluaykge1xcbiAgICAgIHJldHVybiBub3JtYWxpemVMaW5rKGVudGl0eU1hcCwgbGluaywgb3B0aW9ucy5yZW1vdmVVbnJlc29sdmVkKTtcXG4gICAgfSwgb3B0aW9ucy5yZW1vdmVVbnJlc29sdmVkKSk7XFxuICB9KTtcXG5cXG4gIHJldHVybiByZXNwb25zZUNsb25lLml0ZW1zO1xcbn07XFxuXFxuLyogaGFybW9ueSBkZWZhdWx0IGV4cG9ydCAqLyBjb25zdCBfX1dFQlBBQ0tfREVGQVVMVF9FWFBPUlRfXyA9IChyZXNvbHZlUmVzcG9uc2UpO1xcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZS9kaXN0L2VzbS9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9jb250ZW50ZnVsLXNkay1jb3JlL2Rpc3QvaW5kZXguZXMtbW9kdWxlcy5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtc2RrLWNvcmUvZGlzdC9pbmRleC5lcy1tb2R1bGVzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiY3JlYXRlSHR0cENsaWVudFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGNyZWF0ZUh0dHBDbGllbnQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNyZWF0ZVJlcXVlc3RDb25maWdcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVSZXF1ZXN0Q29uZmlnKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJlbmZvcmNlT2JqUGF0aFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGVuZm9yY2VPYmpQYXRoKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJlcnJvckhhbmRsZXJcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBlcnJvckhhbmRsZXIpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImZyZWV6ZVN5c1xcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIGZyZWV6ZVN5cyksXFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZ2V0VXNlckFnZW50SGVhZGVyXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gZ2V0VXNlckFnZW50SGVhZGVyKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJ0b1BsYWluT2JqZWN0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdG9QbGFpbk9iamVjdClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZmFzdF9jb3B5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmYXN0LWNvcHkgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9mYXN0LWNvcHkvZGlzdC9mYXN0LWNvcHkuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgZmFzdF9jb3B5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oZmFzdF9jb3B5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBxc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgcXMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgcXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihxc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2lzc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBsb2Rhc2guaXNzdHJpbmcgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNzdHJpbmcvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2lzc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4obG9kYXNoX2lzc3RyaW5nX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwX3Rocm90dGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBwLXRocm90dGxlICovIFxcXCIuLi9ub2RlX21vZHVsZXMvcC10aHJvdHRsZS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBwX3Rocm90dGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4ocF90aHJvdHRsZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2lzcGxhaW5vYmplY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGxvZGFzaC5pc3BsYWlub2JqZWN0ICovIFxcXCIuLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzcGxhaW5vYmplY3QvaW5kZXguanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgbG9kYXNoX2lzcGxhaW5vYmplY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihsb2Rhc2hfaXNwbGFpbm9iamVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5mdW5jdGlvbiBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB7XFxuICB2YXIgX2kgPSBudWxsID09IGFyciA/IG51bGwgOiBcXFwidW5kZWZpbmVkXFxcIiAhPSB0eXBlb2YgU3ltYm9sICYmIGFycltTeW1ib2wuaXRlcmF0b3JdIHx8IGFycltcXFwiQEBpdGVyYXRvclxcXCJdO1xcbiAgaWYgKG51bGwgIT0gX2kpIHtcXG4gICAgdmFyIF9zLFxcbiAgICAgIF9lLFxcbiAgICAgIF94LFxcbiAgICAgIF9yLFxcbiAgICAgIF9hcnIgPSBbXSxcXG4gICAgICBfbiA9ICEwLFxcbiAgICAgIF9kID0gITE7XFxuICAgIHRyeSB7XFxuICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XFxuICAgICAgICBpZiAoT2JqZWN0KF9pKSAhPT0gX2kpIHJldHVybjtcXG4gICAgICAgIF9uID0gITE7XFxuICAgICAgfSBlbHNlIGZvciAoOyAhKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApO1xcbiAgICB9IGNhdGNoIChlcnIpIHtcXG4gICAgICBfZCA9ICEwLCBfZSA9IGVycjtcXG4gICAgfSBmaW5hbGx5IHtcXG4gICAgICB0cnkge1xcbiAgICAgICAgaWYgKCFfbiAmJiBudWxsICE9IF9pLnJldHVybiAmJiAoX3IgPSBfaS5yZXR1cm4oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XFxuICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiBfYXJyO1xcbiAgfVxcbn1cXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcXG4gIHZhciBrZXlzID0gT2JqZWN0LmtleXMob2JqZWN0KTtcXG4gIGlmIChPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKSB7XFxuICAgIHZhciBzeW1ib2xzID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpO1xcbiAgICBlbnVtZXJhYmxlT25seSAmJiAoc3ltYm9scyA9IHN5bWJvbHMuZmlsdGVyKGZ1bmN0aW9uIChzeW0pIHtcXG4gICAgICByZXR1cm4gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHN5bSkuZW51bWVyYWJsZTtcXG4gICAgfSkpLCBrZXlzLnB1c2guYXBwbHkoa2V5cywgc3ltYm9scyk7XFxuICB9XFxuICByZXR1cm4ga2V5cztcXG59XFxuZnVuY3Rpb24gX29iamVjdFNwcmVhZDIodGFyZ2V0KSB7XFxuICBmb3IgKHZhciBpID0gMTsgaSA8IGFyZ3VtZW50cy5sZW5ndGg7IGkrKykge1xcbiAgICB2YXIgc291cmNlID0gbnVsbCAhPSBhcmd1bWVudHNbaV0gPyBhcmd1bWVudHNbaV0gOiB7fTtcXG4gICAgaSAlIDIgPyBvd25LZXlzKE9iamVjdChzb3VyY2UpLCAhMCkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgX2RlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBzb3VyY2Vba2V5XSk7XFxuICAgIH0pIDogT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMgPyBPYmplY3QuZGVmaW5lUHJvcGVydGllcyh0YXJnZXQsIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3JzKHNvdXJjZSkpIDogb3duS2V5cyhPYmplY3Qoc291cmNlKSkuZm9yRWFjaChmdW5jdGlvbiAoa2V5KSB7XFxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHRhcmdldCwga2V5LCBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKHNvdXJjZSwga2V5KSk7XFxuICAgIH0pO1xcbiAgfVxcbiAgcmV0dXJuIHRhcmdldDtcXG59XFxuZnVuY3Rpb24gX3R5cGVvZihvYmopIHtcXG4gIFxcXCJAYmFiZWwvaGVscGVycyAtIHR5cGVvZlxcXCI7XFxuXFxuICByZXR1cm4gX3R5cGVvZiA9IFxcXCJmdW5jdGlvblxcXCIgPT0gdHlwZW9mIFN5bWJvbCAmJiBcXFwic3ltYm9sXFxcIiA9PSB0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID8gZnVuY3Rpb24gKG9iaikge1xcbiAgICByZXR1cm4gdHlwZW9mIG9iajtcXG4gIH0gOiBmdW5jdGlvbiAob2JqKSB7XFxuICAgIHJldHVybiBvYmogJiYgXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2YgU3ltYm9sICYmIG9iai5jb25zdHJ1Y3RvciA9PT0gU3ltYm9sICYmIG9iaiAhPT0gU3ltYm9sLnByb3RvdHlwZSA/IFxcXCJzeW1ib2xcXFwiIDogdHlwZW9mIG9iajtcXG4gIH0sIF90eXBlb2Yob2JqKTtcXG59XFxuZnVuY3Rpb24gX3dyYXBSZWdFeHAoKSB7XFxuICBfd3JhcFJlZ0V4cCA9IGZ1bmN0aW9uIChyZSwgZ3JvdXBzKSB7XFxuICAgIHJldHVybiBuZXcgQmFiZWxSZWdFeHAocmUsIHZvaWQgMCwgZ3JvdXBzKTtcXG4gIH07XFxuICB2YXIgX3N1cGVyID0gUmVnRXhwLnByb3RvdHlwZSxcXG4gICAgX2dyb3VwcyA9IG5ldyBXZWFrTWFwKCk7XFxuICBmdW5jdGlvbiBCYWJlbFJlZ0V4cChyZSwgZmxhZ3MsIGdyb3Vwcykge1xcbiAgICB2YXIgX3RoaXMgPSBuZXcgUmVnRXhwKHJlLCBmbGFncyk7XFxuICAgIHJldHVybiBfZ3JvdXBzLnNldChfdGhpcywgZ3JvdXBzIHx8IF9ncm91cHMuZ2V0KHJlKSksIF9zZXRQcm90b3R5cGVPZihfdGhpcywgQmFiZWxSZWdFeHAucHJvdG90eXBlKTtcXG4gIH1cXG4gIGZ1bmN0aW9uIGJ1aWxkR3JvdXBzKHJlc3VsdCwgcmUpIHtcXG4gICAgdmFyIGcgPSBfZ3JvdXBzLmdldChyZSk7XFxuICAgIHJldHVybiBPYmplY3Qua2V5cyhnKS5yZWR1Y2UoZnVuY3Rpb24gKGdyb3VwcywgbmFtZSkge1xcbiAgICAgIHZhciBpID0gZ1tuYW1lXTtcXG4gICAgICBpZiAoXFxcIm51bWJlclxcXCIgPT0gdHlwZW9mIGkpIGdyb3Vwc1tuYW1lXSA9IHJlc3VsdFtpXTtlbHNlIHtcXG4gICAgICAgIGZvciAodmFyIGsgPSAwOyB2b2lkIDAgPT09IHJlc3VsdFtpW2tdXSAmJiBrICsgMSA8IGkubGVuZ3RoOykgaysrO1xcbiAgICAgICAgZ3JvdXBzW25hbWVdID0gcmVzdWx0W2lba11dO1xcbiAgICAgIH1cXG4gICAgICByZXR1cm4gZ3JvdXBzO1xcbiAgICB9LCBPYmplY3QuY3JlYXRlKG51bGwpKTtcXG4gIH1cXG4gIHJldHVybiBfaW5oZXJpdHMoQmFiZWxSZWdFeHAsIFJlZ0V4cCksIEJhYmVsUmVnRXhwLnByb3RvdHlwZS5leGVjID0gZnVuY3Rpb24gKHN0cikge1xcbiAgICB2YXIgcmVzdWx0ID0gX3N1cGVyLmV4ZWMuY2FsbCh0aGlzLCBzdHIpO1xcbiAgICBpZiAocmVzdWx0KSB7XFxuICAgICAgcmVzdWx0Lmdyb3VwcyA9IGJ1aWxkR3JvdXBzKHJlc3VsdCwgdGhpcyk7XFxuICAgICAgdmFyIGluZGljZXMgPSByZXN1bHQuaW5kaWNlcztcXG4gICAgICBpbmRpY2VzICYmIChpbmRpY2VzLmdyb3VwcyA9IGJ1aWxkR3JvdXBzKGluZGljZXMsIHRoaXMpKTtcXG4gICAgfVxcbiAgICByZXR1cm4gcmVzdWx0O1xcbiAgfSwgQmFiZWxSZWdFeHAucHJvdG90eXBlW1N5bWJvbC5yZXBsYWNlXSA9IGZ1bmN0aW9uIChzdHIsIHN1YnN0aXR1dGlvbikge1xcbiAgICBpZiAoXFxcInN0cmluZ1xcXCIgPT0gdHlwZW9mIHN1YnN0aXR1dGlvbikge1xcbiAgICAgIHZhciBncm91cHMgPSBfZ3JvdXBzLmdldCh0aGlzKTtcXG4gICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgc3Vic3RpdHV0aW9uLnJlcGxhY2UoL1xcXFwkPChbXj5dKyk+L2csIGZ1bmN0aW9uIChfLCBuYW1lKSB7XFxuICAgICAgICB2YXIgZ3JvdXAgPSBncm91cHNbbmFtZV07XFxuICAgICAgICByZXR1cm4gXFxcIiRcXFwiICsgKEFycmF5LmlzQXJyYXkoZ3JvdXApID8gZ3JvdXAuam9pbihcXFwiJFxcXCIpIDogZ3JvdXApO1xcbiAgICAgIH0pKTtcXG4gICAgfVxcbiAgICBpZiAoXFxcImZ1bmN0aW9uXFxcIiA9PSB0eXBlb2Ygc3Vic3RpdHV0aW9uKSB7XFxuICAgICAgdmFyIF90aGlzID0gdGhpcztcXG4gICAgICByZXR1cm4gX3N1cGVyW1N5bWJvbC5yZXBsYWNlXS5jYWxsKHRoaXMsIHN0ciwgZnVuY3Rpb24gKCkge1xcbiAgICAgICAgdmFyIGFyZ3MgPSBhcmd1bWVudHM7XFxuICAgICAgICByZXR1cm4gXFxcIm9iamVjdFxcXCIgIT0gdHlwZW9mIGFyZ3NbYXJncy5sZW5ndGggLSAxXSAmJiAoYXJncyA9IFtdLnNsaWNlLmNhbGwoYXJncykpLnB1c2goYnVpbGRHcm91cHMoYXJncywgX3RoaXMpKSwgc3Vic3RpdHV0aW9uLmFwcGx5KHRoaXMsIGFyZ3MpO1xcbiAgICAgIH0pO1xcbiAgICB9XFxuICAgIHJldHVybiBfc3VwZXJbU3ltYm9sLnJlcGxhY2VdLmNhbGwodGhpcywgc3RyLCBzdWJzdGl0dXRpb24pO1xcbiAgfSwgX3dyYXBSZWdFeHAuYXBwbHkodGhpcywgYXJndW1lbnRzKTtcXG59XFxuZnVuY3Rpb24gX2RlZmluZVByb3BlcnR5KG9iaiwga2V5LCB2YWx1ZSkge1xcbiAga2V5ID0gX3RvUHJvcGVydHlLZXkoa2V5KTtcXG4gIGlmIChrZXkgaW4gb2JqKSB7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xcbiAgICAgIHZhbHVlOiB2YWx1ZSxcXG4gICAgICBlbnVtZXJhYmxlOiB0cnVlLFxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcXG4gICAgICB3cml0YWJsZTogdHJ1ZVxcbiAgICB9KTtcXG4gIH0gZWxzZSB7XFxuICAgIG9ialtrZXldID0gdmFsdWU7XFxuICB9XFxuICByZXR1cm4gb2JqO1xcbn1cXG5mdW5jdGlvbiBfaW5oZXJpdHMoc3ViQ2xhc3MsIHN1cGVyQ2xhc3MpIHtcXG4gIGlmICh0eXBlb2Ygc3VwZXJDbGFzcyAhPT0gXFxcImZ1bmN0aW9uXFxcIiAmJiBzdXBlckNsYXNzICE9PSBudWxsKSB7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIlN1cGVyIGV4cHJlc3Npb24gbXVzdCBlaXRoZXIgYmUgbnVsbCBvciBhIGZ1bmN0aW9uXFxcIik7XFxuICB9XFxuICBzdWJDbGFzcy5wcm90b3R5cGUgPSBPYmplY3QuY3JlYXRlKHN1cGVyQ2xhc3MgJiYgc3VwZXJDbGFzcy5wcm90b3R5cGUsIHtcXG4gICAgY29uc3RydWN0b3I6IHtcXG4gICAgICB2YWx1ZTogc3ViQ2xhc3MsXFxuICAgICAgd3JpdGFibGU6IHRydWUsXFxuICAgICAgY29uZmlndXJhYmxlOiB0cnVlXFxuICAgIH1cXG4gIH0pO1xcbiAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHN1YkNsYXNzLCBcXFwicHJvdG90eXBlXFxcIiwge1xcbiAgICB3cml0YWJsZTogZmFsc2VcXG4gIH0pO1xcbiAgaWYgKHN1cGVyQ2xhc3MpIF9zZXRQcm90b3R5cGVPZihzdWJDbGFzcywgc3VwZXJDbGFzcyk7XFxufVxcbmZ1bmN0aW9uIF9zZXRQcm90b3R5cGVPZihvLCBwKSB7XFxuICBfc2V0UHJvdG90eXBlT2YgPSBPYmplY3Quc2V0UHJvdG90eXBlT2YgPyBPYmplY3Quc2V0UHJvdG90eXBlT2YuYmluZCgpIDogZnVuY3Rpb24gX3NldFByb3RvdHlwZU9mKG8sIHApIHtcXG4gICAgby5fX3Byb3RvX18gPSBwO1xcbiAgICByZXR1cm4gbztcXG4gIH07XFxuICByZXR1cm4gX3NldFByb3RvdHlwZU9mKG8sIHApO1xcbn1cXG5mdW5jdGlvbiBfc2xpY2VkVG9BcnJheShhcnIsIGkpIHtcXG4gIHJldHVybiBfYXJyYXlXaXRoSG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5TGltaXQoYXJyLCBpKSB8fCBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkoYXJyLCBpKSB8fCBfbm9uSXRlcmFibGVSZXN0KCk7XFxufVxcbmZ1bmN0aW9uIF9hcnJheVdpdGhIb2xlcyhhcnIpIHtcXG4gIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XFxufVxcbmZ1bmN0aW9uIF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShvLCBtaW5MZW4pIHtcXG4gIGlmICghbykgcmV0dXJuO1xcbiAgaWYgKHR5cGVvZiBvID09PSBcXFwic3RyaW5nXFxcIikgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XFxuICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XFxuICBpZiAobiA9PT0gXFxcIk9iamVjdFxcXCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcXG4gIGlmIChuID09PSBcXFwiTWFwXFxcIiB8fCBuID09PSBcXFwiU2V0XFxcIikgcmV0dXJuIEFycmF5LmZyb20obyk7XFxuICBpZiAobiA9PT0gXFxcIkFyZ3VtZW50c1xcXCIgfHwgL14oPzpVaXxJKW50KD86OHwxNnwzMikoPzpDbGFtcGVkKT9BcnJheSQvLnRlc3QobikpIHJldHVybiBfYXJyYXlMaWtlVG9BcnJheShvLCBtaW5MZW4pO1xcbn1cXG5mdW5jdGlvbiBfYXJyYXlMaWtlVG9BcnJheShhcnIsIGxlbikge1xcbiAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XFxuICBmb3IgKHZhciBpID0gMCwgYXJyMiA9IG5ldyBBcnJheShsZW4pOyBpIDwgbGVuOyBpKyspIGFycjJbaV0gPSBhcnJbaV07XFxuICByZXR1cm4gYXJyMjtcXG59XFxuZnVuY3Rpb24gX25vbkl0ZXJhYmxlUmVzdCgpIHtcXG4gIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxcXG5JbiBvcmRlciB0byBiZSBpdGVyYWJsZSwgbm9uLWFycmF5IG9iamVjdHMgbXVzdCBoYXZlIGEgW1N5bWJvbC5pdGVyYXRvcl0oKSBtZXRob2QuXFxcIik7XFxufVxcbmZ1bmN0aW9uIF9jcmVhdGVGb3JPZkl0ZXJhdG9ySGVscGVyKG8sIGFsbG93QXJyYXlMaWtlKSB7XFxuICB2YXIgaXQgPSB0eXBlb2YgU3ltYm9sICE9PSBcXFwidW5kZWZpbmVkXFxcIiAmJiBvW1N5bWJvbC5pdGVyYXRvcl0gfHwgb1tcXFwiQEBpdGVyYXRvclxcXCJdO1xcbiAgaWYgKCFpdCkge1xcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvKSB8fCAoaXQgPSBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobykpIHx8IGFsbG93QXJyYXlMaWtlICYmIG8gJiYgdHlwZW9mIG8ubGVuZ3RoID09PSBcXFwibnVtYmVyXFxcIikge1xcbiAgICAgIGlmIChpdCkgbyA9IGl0O1xcbiAgICAgIHZhciBpID0gMDtcXG4gICAgICB2YXIgRiA9IGZ1bmN0aW9uICgpIHt9O1xcbiAgICAgIHJldHVybiB7XFxuICAgICAgICBzOiBGLFxcbiAgICAgICAgbjogZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICBpZiAoaSA+PSBvLmxlbmd0aCkgcmV0dXJuIHtcXG4gICAgICAgICAgICBkb25lOiB0cnVlXFxuICAgICAgICAgIH07XFxuICAgICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgZG9uZTogZmFsc2UsXFxuICAgICAgICAgICAgdmFsdWU6IG9baSsrXVxcbiAgICAgICAgICB9O1xcbiAgICAgICAgfSxcXG4gICAgICAgIGU6IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgICAgIHRocm93IGU7XFxuICAgICAgICB9LFxcbiAgICAgICAgZjogRlxcbiAgICAgIH07XFxuICAgIH1cXG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcXFwiSW52YWxpZCBhdHRlbXB0IHRvIGl0ZXJhdGUgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlxcXCIpO1xcbiAgfVxcbiAgdmFyIG5vcm1hbENvbXBsZXRpb24gPSB0cnVlLFxcbiAgICBkaWRFcnIgPSBmYWxzZSxcXG4gICAgZXJyO1xcbiAgcmV0dXJuIHtcXG4gICAgczogZnVuY3Rpb24gKCkge1xcbiAgICAgIGl0ID0gaXQuY2FsbChvKTtcXG4gICAgfSxcXG4gICAgbjogZnVuY3Rpb24gKCkge1xcbiAgICAgIHZhciBzdGVwID0gaXQubmV4dCgpO1xcbiAgICAgIG5vcm1hbENvbXBsZXRpb24gPSBzdGVwLmRvbmU7XFxuICAgICAgcmV0dXJuIHN0ZXA7XFxuICAgIH0sXFxuICAgIGU6IGZ1bmN0aW9uIChlKSB7XFxuICAgICAgZGlkRXJyID0gdHJ1ZTtcXG4gICAgICBlcnIgPSBlO1xcbiAgICB9LFxcbiAgICBmOiBmdW5jdGlvbiAoKSB7XFxuICAgICAgdHJ5IHtcXG4gICAgICAgIGlmICghbm9ybWFsQ29tcGxldGlvbiAmJiBpdC5yZXR1cm4gIT0gbnVsbCkgaXQucmV0dXJuKCk7XFxuICAgICAgfSBmaW5hbGx5IHtcXG4gICAgICAgIGlmIChkaWRFcnIpIHRocm93IGVycjtcXG4gICAgICB9XFxuICAgIH1cXG4gIH07XFxufVxcbmZ1bmN0aW9uIF90b1ByaW1pdGl2ZShpbnB1dCwgaGludCkge1xcbiAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXFxcIm9iamVjdFxcXCIgfHwgaW5wdXQgPT09IG51bGwpIHJldHVybiBpbnB1dDtcXG4gIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcXG4gIGlmIChwcmltICE9PSB1bmRlZmluZWQpIHtcXG4gICAgdmFyIHJlcyA9IHByaW0uY2FsbChpbnB1dCwgaGludCB8fCBcXFwiZGVmYXVsdFxcXCIpO1xcbiAgICBpZiAodHlwZW9mIHJlcyAhPT0gXFxcIm9iamVjdFxcXCIpIHJldHVybiByZXM7XFxuICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXFxcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXFxcIik7XFxuICB9XFxuICByZXR1cm4gKGhpbnQgPT09IFxcXCJzdHJpbmdcXFwiID8gU3RyaW5nIDogTnVtYmVyKShpbnB1dCk7XFxufVxcbmZ1bmN0aW9uIF90b1Byb3BlcnR5S2V5KGFyZykge1xcbiAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFxcXCJzdHJpbmdcXFwiKTtcXG4gIHJldHVybiB0eXBlb2Yga2V5ID09PSBcXFwic3ltYm9sXFxcIiA/IGtleSA6IFN0cmluZyhrZXkpO1xcbn1cXG5cXG5mdW5jdGlvbiBpc05vZGUoKSB7XFxuICAvKipcXG4gICAqIFBvbHlmaWxscyBvZiAncHJvY2VzcycgbWlnaHQgc2V0IHByb2Nlc3MuYnJvd3NlciA9PT0gdHJ1ZVxcbiAgICpcXG4gICAqIFNlZTpcXG4gICAqIGh0dHBzOi8vZ2l0aHViLmNvbS93ZWJwYWNrL25vZGUtbGlicy1icm93c2VyL2Jsb2IvbWFzdGVyL21vY2svcHJvY2Vzcy5qcyNMOFxcbiAgICogaHR0cHM6Ly9naXRodWIuY29tL2RlZnVuY3R6b21iaWUvbm9kZS1wcm9jZXNzL2Jsb2IvbWFzdGVyL2Jyb3dzZXIuanMjTDE1NlxcbiAgICoqL1xcbiAgcmV0dXJuIHR5cGVvZiBwcm9jZXNzICE9PSAndW5kZWZpbmVkJyAmJiAhcHJvY2Vzcy5icm93c2VyO1xcbn1cXG5mdW5jdGlvbiBpc1JlYWN0TmF0aXZlKCkge1xcbiAgcmV0dXJuIHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnICYmICduYXZpZ2F0b3InIGluIHdpbmRvdyAmJiAncHJvZHVjdCcgaW4gd2luZG93Lm5hdmlnYXRvciAmJiB3aW5kb3cubmF2aWdhdG9yLnByb2R1Y3QgPT09ICdSZWFjdE5hdGl2ZSc7XFxufVxcbmZ1bmN0aW9uIGdldE5vZGVWZXJzaW9uKCkge1xcbiAgcmV0dXJuIHByb2Nlc3MudmVyc2lvbnMgJiYgcHJvY2Vzcy52ZXJzaW9ucy5ub2RlID8gXFxcInZcXFwiLmNvbmNhdChwcm9jZXNzLnZlcnNpb25zLm5vZGUpIDogcHJvY2Vzcy52ZXJzaW9uO1xcbn1cXG5mdW5jdGlvbiBnZXRXaW5kb3coKSB7XFxuICByZXR1cm4gd2luZG93O1xcbn1cXG5mdW5jdGlvbiBub29wKCkge1xcbiAgcmV0dXJuIHVuZGVmaW5lZDtcXG59XFxuXFxudmFyIFBFUkNFTlRBR0VfUkVHRVggPSAvKiNfX1BVUkVfXyovX3dyYXBSZWdFeHAoLyhcXFxcZCspKCUpLywge1xcbiAgdmFsdWU6IDFcXG59KTtcXG5mdW5jdGlvbiBjYWxjdWxhdGVMaW1pdCh0eXBlKSB7XFxuICB2YXIgbWF4ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA3O1xcbiAgdmFyIGxpbWl0ID0gbWF4O1xcbiAgaWYgKFBFUkNFTlRBR0VfUkVHRVgudGVzdCh0eXBlKSkge1xcbiAgICB2YXIgX3R5cGUkbWF0Y2g7XFxuICAgIHZhciBncm91cHMgPSAoX3R5cGUkbWF0Y2ggPSB0eXBlLm1hdGNoKFBFUkNFTlRBR0VfUkVHRVgpKSA9PT0gbnVsbCB8fCBfdHlwZSRtYXRjaCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX3R5cGUkbWF0Y2guZ3JvdXBzO1xcbiAgICBpZiAoZ3JvdXBzICYmIGdyb3Vwcy52YWx1ZSkge1xcbiAgICAgIHZhciBwZXJjZW50YWdlID0gcGFyc2VJbnQoZ3JvdXBzLnZhbHVlKSAvIDEwMDtcXG4gICAgICBsaW1pdCA9IE1hdGgucm91bmQobWF4ICogcGVyY2VudGFnZSk7XFxuICAgIH1cXG4gIH1cXG4gIHJldHVybiBNYXRoLm1pbigzMCwgTWF0aC5tYXgoMSwgbGltaXQpKTtcXG59XFxuZnVuY3Rpb24gY3JlYXRlVGhyb3R0bGUobGltaXQsIGxvZ2dlcikge1xcbiAgbG9nZ2VyKCdpbmZvJywgXFxcIlRocm90dGxlIHJlcXVlc3QgdG8gXFxcIi5jb25jYXQobGltaXQsIFxcXCIvc1xcXCIpKTtcXG4gIHJldHVybiBwX3Rocm90dGxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19fZGVmYXVsdCgpKHtcXG4gICAgbGltaXQ6IGxpbWl0LFxcbiAgICBpbnRlcnZhbDogMTAwMCxcXG4gICAgc3RyaWN0OiBmYWxzZVxcbiAgfSk7XFxufVxcbnZhciByYXRlTGltaXRUaHJvdHRsZSA9IChmdW5jdGlvbiAoYXhpb3NJbnN0YW5jZSkge1xcbiAgdmFyIHR5cGUgPSBhcmd1bWVudHMubGVuZ3RoID4gMSAmJiBhcmd1bWVudHNbMV0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1sxXSA6ICdhdXRvJztcXG4gIHZhciBfYXhpb3NJbnN0YW5jZSRkZWZhdWwgPSBheGlvc0luc3RhbmNlLmRlZmF1bHRzLmxvZ0hhbmRsZXIsXFxuICAgIGxvZ0hhbmRsZXIgPSBfYXhpb3NJbnN0YW5jZSRkZWZhdWwgPT09IHZvaWQgMCA/IG5vb3AgOiBfYXhpb3NJbnN0YW5jZSRkZWZhdWw7XFxuICB2YXIgbGltaXQgPSBsb2Rhc2hfaXNzdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0KCkodHlwZSkgPyBjYWxjdWxhdGVMaW1pdCh0eXBlKSA6IGNhbGN1bGF0ZUxpbWl0KCdhdXRvJywgdHlwZSk7XFxuICB2YXIgdGhyb3R0bGUgPSBjcmVhdGVUaHJvdHRsZShsaW1pdCwgbG9nSGFuZGxlcik7XFxuICB2YXIgaXNDYWxjdWxhdGVkID0gZmFsc2U7XFxuICB2YXIgcmVxdWVzdEludGVyY2VwdG9ySWQgPSBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShmdW5jdGlvbiAoY29uZmlnKSB7XFxuICAgIHJldHVybiB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgfSkoKTtcXG4gIH0sIGZ1bmN0aW9uIChlcnJvcikge1xcbiAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xcbiAgfSk7XFxuICB2YXIgcmVzcG9uc2VJbnRlcmNlcHRvcklkID0gYXhpb3NJbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICBpZiAoIWlzQ2FsY3VsYXRlZCAmJiBsb2Rhc2hfaXNzdHJpbmdfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX19kZWZhdWx0KCkodHlwZSkgJiYgKHR5cGUgPT09ICdhdXRvJyB8fCBQRVJDRU5UQUdFX1JFR0VYLnRlc3QodHlwZSkpICYmIHJlc3BvbnNlLmhlYWRlcnMgJiYgcmVzcG9uc2UuaGVhZGVyc1sneC1jb250ZW50ZnVsLXJhdGVsaW1pdC1zZWNvbmQtbGltaXQnXSkge1xcbiAgICAgIHZhciByYXdMaW1pdCA9IHBhcnNlSW50KHJlc3BvbnNlLmhlYWRlcnNbJ3gtY29udGVudGZ1bC1yYXRlbGltaXQtc2Vjb25kLWxpbWl0J10pO1xcbiAgICAgIHZhciBuZXh0TGltaXQgPSBjYWxjdWxhdGVMaW1pdCh0eXBlLCByYXdMaW1pdCk7XFxuICAgICAgaWYgKG5leHRMaW1pdCAhPT0gbGltaXQpIHtcXG4gICAgICAgIGlmIChyZXF1ZXN0SW50ZXJjZXB0b3JJZCkge1xcbiAgICAgICAgICBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LmVqZWN0KHJlcXVlc3RJbnRlcmNlcHRvcklkKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGxpbWl0ID0gbmV4dExpbWl0O1xcbiAgICAgICAgdGhyb3R0bGUgPSBjcmVhdGVUaHJvdHRsZShuZXh0TGltaXQsIGxvZ0hhbmRsZXIpO1xcbiAgICAgICAgcmVxdWVzdEludGVyY2VwdG9ySWQgPSBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShmdW5jdGlvbiAoY29uZmlnKSB7XFxuICAgICAgICAgIHJldHVybiB0aHJvdHRsZShmdW5jdGlvbiAoKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGNvbmZpZztcXG4gICAgICAgICAgfSkoKTtcXG4gICAgICAgIH0sIGZ1bmN0aW9uIChlcnJvcikge1xcbiAgICAgICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xcbiAgICAgICAgfSk7XFxuICAgICAgfVxcbiAgICAgIGlzQ2FsY3VsYXRlZCA9IHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xcbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XFxuICB9KTtcXG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XFxuICAgIGF4aW9zSW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QuZWplY3QocmVxdWVzdEludGVyY2VwdG9ySWQpO1xcbiAgICBheGlvc0luc3RhbmNlLmludGVyY2VwdG9ycy5yZXNwb25zZS5lamVjdChyZXNwb25zZUludGVyY2VwdG9ySWQpO1xcbiAgfTtcXG59KTtcXG5cXG52YXIgZGVsYXkgPSBmdW5jdGlvbiBkZWxheShtcykge1xcbiAgcmV0dXJuIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7XFxuICAgIHNldFRpbWVvdXQocmVzb2x2ZSwgbXMpO1xcbiAgfSk7XFxufTtcXG52YXIgZGVmYXVsdFdhaXQgPSBmdW5jdGlvbiBkZWZhdWx0V2FpdChhdHRlbXB0cykge1xcbiAgcmV0dXJuIE1hdGgucG93KE1hdGguU1FSVDIsIGF0dGVtcHRzKTtcXG59O1xcbmZ1bmN0aW9uIHJhdGVMaW1pdChpbnN0YW5jZSkge1xcbiAgdmFyIG1heFJldHJ5ID0gYXJndW1lbnRzLmxlbmd0aCA+IDEgJiYgYXJndW1lbnRzWzFdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMV0gOiA1O1xcbiAgdmFyIF9pbnN0YW5jZSRkZWZhdWx0cyA9IGluc3RhbmNlLmRlZmF1bHRzLFxcbiAgICBfaW5zdGFuY2UkZGVmYXVsdHMkcmUgPSBfaW5zdGFuY2UkZGVmYXVsdHMucmVzcG9uc2VMb2dnZXIsXFxuICAgIHJlc3BvbnNlTG9nZ2VyID0gX2luc3RhbmNlJGRlZmF1bHRzJHJlID09PSB2b2lkIDAgPyBub29wIDogX2luc3RhbmNlJGRlZmF1bHRzJHJlLFxcbiAgICBfaW5zdGFuY2UkZGVmYXVsdHMkcmUyID0gX2luc3RhbmNlJGRlZmF1bHRzLnJlcXVlc3RMb2dnZXIsXFxuICAgIHJlcXVlc3RMb2dnZXIgPSBfaW5zdGFuY2UkZGVmYXVsdHMkcmUyID09PSB2b2lkIDAgPyBub29wIDogX2luc3RhbmNlJGRlZmF1bHRzJHJlMjtcXG4gIGluc3RhbmNlLmludGVyY2VwdG9ycy5yZXF1ZXN0LnVzZShmdW5jdGlvbiAoY29uZmlnKSB7XFxuICAgIHJlcXVlc3RMb2dnZXIoY29uZmlnKTtcXG4gICAgcmV0dXJuIGNvbmZpZztcXG4gIH0sIGZ1bmN0aW9uIChlcnJvcikge1xcbiAgICByZXF1ZXN0TG9nZ2VyKGVycm9yKTtcXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gIH0pO1xcbiAgaW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlc3BvbnNlLnVzZShmdW5jdGlvbiAocmVzcG9uc2UpIHtcXG4gICAgLy8gd2UgZG9uJ3QgbmVlZCB0byBkbyBhbnl0aGluZyBoZXJlXFxuICAgIHJlc3BvbnNlTG9nZ2VyKHJlc3BvbnNlKTtcXG4gICAgcmV0dXJuIHJlc3BvbnNlO1xcbiAgfSwgZnVuY3Rpb24gKGVycm9yKSB7XFxuICAgIHZhciByZXNwb25zZSA9IGVycm9yLnJlc3BvbnNlO1xcbiAgICB2YXIgY29uZmlnID0gZXJyb3IuY29uZmlnO1xcbiAgICByZXNwb25zZUxvZ2dlcihlcnJvcik7XFxuICAgIC8vIERvIG5vdCByZXRyeSBpZiBpdCBpcyBkaXNhYmxlZCBvciBubyByZXF1ZXN0IGNvbmZpZyBleGlzdHMgKG5vdCBhbiBheGlvcyBlcnJvcilcXG4gICAgaWYgKCFjb25maWcgfHwgIWluc3RhbmNlLmRlZmF1bHRzLnJldHJ5T25FcnJvcikge1xcbiAgICAgIHJldHVybiBQcm9taXNlLnJlamVjdChlcnJvcik7XFxuICAgIH1cXG5cXG4gICAgLy8gUmV0cmllZCBhbHJlYWR5IGZvciBtYXggYXR0ZW1wdHNcXG4gICAgdmFyIGRvbmVBdHRlbXB0cyA9IGNvbmZpZy5hdHRlbXB0cyB8fCAxO1xcbiAgICBpZiAoZG9uZUF0dGVtcHRzID4gbWF4UmV0cnkpIHtcXG4gICAgICBlcnJvci5hdHRlbXB0cyA9IGNvbmZpZy5hdHRlbXB0cztcXG4gICAgICByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyb3IpO1xcbiAgICB9XFxuICAgIHZhciByZXRyeUVycm9yVHlwZSA9IG51bGw7XFxuICAgIHZhciB3YWl0ID0gZGVmYXVsdFdhaXQoZG9uZUF0dGVtcHRzKTtcXG5cXG4gICAgLy8gRXJyb3JzIHdpdGhvdXQgcmVzcG9uc2UgZGlkIG5vdCByZWNlaXZlIGFueXRoaW5nIGZyb20gdGhlIHNlcnZlclxcbiAgICBpZiAoIXJlc3BvbnNlKSB7XFxuICAgICAgcmV0cnlFcnJvclR5cGUgPSAnQ29ubmVjdGlvbic7XFxuICAgIH0gZWxzZSBpZiAocmVzcG9uc2Uuc3RhdHVzID49IDUwMCAmJiByZXNwb25zZS5zdGF0dXMgPCA2MDApIHtcXG4gICAgICAvLyA1KiogZXJyb3JzIGFyZSBzZXJ2ZXIgcmVsYXRlZFxcbiAgICAgIHJldHJ5RXJyb3JUeXBlID0gXFxcIlNlcnZlciBcXFwiLmNvbmNhdChyZXNwb25zZS5zdGF0dXMpO1xcbiAgICB9IGVsc2UgaWYgKHJlc3BvbnNlLnN0YXR1cyA9PT0gNDI5KSB7XFxuICAgICAgLy8gNDI5IGVycm9ycyBhcmUgZXhjZWVkZWQgcmF0ZSBsaW1pdCBleGNlcHRpb25zXFxuICAgICAgcmV0cnlFcnJvclR5cGUgPSAnUmF0ZSBsaW1pdCc7XFxuICAgICAgLy8gYWxsIGhlYWRlcnMgYXJlIGxvd2VyY2FzZWQgYnkgYXhpb3MgaHR0cHM6Ly9naXRodWIuY29tL216YWJyaXNraWUvYXhpb3MvaXNzdWVzLzQxM1xcbiAgICAgIGlmIChyZXNwb25zZS5oZWFkZXJzICYmIGVycm9yLnJlc3BvbnNlLmhlYWRlcnNbJ3gtY29udGVudGZ1bC1yYXRlbGltaXQtcmVzZXQnXSkge1xcbiAgICAgICAgd2FpdCA9IHJlc3BvbnNlLmhlYWRlcnNbJ3gtY29udGVudGZ1bC1yYXRlbGltaXQtcmVzZXQnXTtcXG4gICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHJldHJ5RXJyb3JUeXBlKSB7XFxuICAgICAgLy8gY29udmVydCB0byBtcyBhbmQgYWRkIGppdHRlclxcbiAgICAgIHdhaXQgPSBNYXRoLmZsb29yKHdhaXQgKiAxMDAwICsgTWF0aC5yYW5kb20oKSAqIDIwMCArIDUwMCk7XFxuICAgICAgaW5zdGFuY2UuZGVmYXVsdHMubG9nSGFuZGxlcignd2FybmluZycsIFxcXCJcXFwiLmNvbmNhdChyZXRyeUVycm9yVHlwZSwgXFxcIiBlcnJvciBvY2N1cnJlZC4gV2FpdGluZyBmb3IgXFxcIikuY29uY2F0KHdhaXQsIFxcXCIgbXMgYmVmb3JlIHJldHJ5aW5nLi4uXFxcIikpO1xcblxcbiAgICAgIC8vIGluY3JlYXNlIGF0dGVtcHRzIGNvdW50ZXJcXG4gICAgICBjb25maWcuYXR0ZW1wdHMgPSBkb25lQXR0ZW1wdHMgKyAxO1xcblxcbiAgICAgIC8qIFNvbWVob3cgYmV0d2VlbiB0aGUgaW50ZXJjZXB0b3IgYW5kIHJldHJ5aW5nIHRoZSByZXF1ZXN0IHRoZSBodHRwQWdlbnQvaHR0cHNBZ2VudCBnZXRzIHRyYW5zZm9ybWVkIGZyb20gYW4gQWdlbnQtbGlrZSBvYmplY3RcXG4gICAgICAgdG8gYSByZWd1bGFyIG9iamVjdCwgY2F1c2luZyBmYWlsdXJlcyBvbiByZXRyaWVzIGFmdGVyIHJhdGUgbGltaXRzLiBSZW1vdmluZyB0aGVzZSBwcm9wZXJ0aWVzIGhlcmUgZml4ZXMgdGhlIGVycm9yLCBidXQgcmV0cnlcXG4gICAgICAgcmVxdWVzdHMgc3RpbGwgdXNlIHRoZSBvcmlnaW5hbCBodHRwL2h0dHBzQWdlbnQgcHJvcGVydHkgKi9cXG4gICAgICBkZWxldGUgY29uZmlnLmh0dHBBZ2VudDtcXG4gICAgICBkZWxldGUgY29uZmlnLmh0dHBzQWdlbnQ7XFxuICAgICAgcmV0dXJuIGRlbGF5KHdhaXQpLnRoZW4oZnVuY3Rpb24gKCkge1xcbiAgICAgICAgcmV0dXJuIGluc3RhbmNlKGNvbmZpZyk7XFxuICAgICAgfSk7XFxuICAgIH1cXG4gICAgcmV0dXJuIFByb21pc2UucmVqZWN0KGVycm9yKTtcXG4gIH0pO1xcbn1cXG5cXG5mdW5jdGlvbiBhc3luY1Rva2VuKGluc3RhbmNlLCBnZXRUb2tlbikge1xcbiAgaW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGZ1bmN0aW9uIChjb25maWcpIHtcXG4gICAgcmV0dXJuIGdldFRva2VuKCkudGhlbihmdW5jdGlvbiAoYWNjZXNzVG9rZW4pIHtcXG4gICAgICBjb25maWcuaGVhZGVycyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBjb25maWcuaGVhZGVycyksIHt9LCB7XFxuICAgICAgICBBdXRob3JpemF0aW9uOiBcXFwiQmVhcmVyIFxcXCIuY29uY2F0KGFjY2Vzc1Rva2VuKVxcbiAgICAgIH0pO1xcbiAgICAgIHJldHVybiBjb25maWc7XFxuICAgIH0pO1xcbiAgfSk7XFxufVxcblxcbi8vIE1hdGNoZXMgJ3N1Yi5ob3N0OnBvcnQnIG9yICdob3N0OnBvcnQnIGFuZCBleHRyYWN0cyBob3N0bmFtZSBhbmQgcG9ydFxcbi8vIEFsc28gZW5mb3JjZXMgdG9wbGV2ZWwgZG9tYWluIHNwZWNpZmllZCwgbm8gc3BhY2VzIGFuZCBubyBwcm90b2NvbFxcbnZhciBIT1NUX1JFR0VYID0gL14oPyFcXFxcdys6XFxcXC9cXFxcLykoW15cXFxcczpdK1xcXFwuP1teXFxcXHM6XSspKD86OihcXFxcZCspKT8oPyE6KSQvO1xcblxcbi8qKlxcbiAqIENyZWF0ZSBwcmUgY29uZmlndXJlZCBheGlvcyBpbnN0YW5jZVxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtBeGlvc1N0YXRpY30gYXhpb3MgLSBBeGlvcyBsaWJyYXJ5XFxuICogQHBhcmFtIHtDcmVhdGVIdHRwQ2xpZW50UGFyYW1zfSBvcHRpb25zIC0gSW5pdGlhbGl6YXRpb24gcGFyYW1ldGVycyBmb3IgdGhlIEhUVFAgY2xpZW50XFxuICogQHJldHVybiB7Q29udGVudGZ1bEF4aW9zSW5zdGFuY2V9IEluaXRpYWxpemVkIGF4aW9zIGluc3RhbmNlXFxuICovXFxuZnVuY3Rpb24gY3JlYXRlSHR0cENsaWVudChheGlvcywgb3B0aW9ucykge1xcbiAgdmFyIGRlZmF1bHRDb25maWcgPSB7XFxuICAgIGluc2VjdXJlOiBmYWxzZSxcXG4gICAgcmV0cnlPbkVycm9yOiB0cnVlLFxcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxcbiAgICBsb2dIYW5kbGVyOiBmdW5jdGlvbiBsb2dIYW5kbGVyKGxldmVsLCBkYXRhKSB7XFxuICAgICAgaWYgKGxldmVsID09PSAnZXJyb3InICYmIGRhdGEpIHtcXG4gICAgICAgIHZhciB0aXRsZSA9IFtkYXRhLm5hbWUsIGRhdGEubWVzc2FnZV0uZmlsdGVyKGZ1bmN0aW9uIChhKSB7XFxuICAgICAgICAgIHJldHVybiBhO1xcbiAgICAgICAgfSkuam9pbignIC0gJyk7XFxuICAgICAgICBjb25zb2xlLmVycm9yKFxcXCJbZXJyb3JdIFxcXCIuY29uY2F0KHRpdGxlKSk7XFxuICAgICAgICBjb25zb2xlLmVycm9yKGRhdGEpO1xcbiAgICAgICAgcmV0dXJuO1xcbiAgICAgIH1cXG4gICAgICBjb25zb2xlLmxvZyhcXFwiW1xcXCIuY29uY2F0KGxldmVsLCBcXFwiXSBcXFwiKS5jb25jYXQoZGF0YSkpO1xcbiAgICB9LFxcbiAgICAvLyBQYXNzZWQgdG8gYXhpb3NcXG4gICAgaGVhZGVyczoge30sXFxuICAgIGh0dHBBZ2VudDogZmFsc2UsXFxuICAgIGh0dHBzQWdlbnQ6IGZhbHNlLFxcbiAgICB0aW1lb3V0OiAzMDAwMCxcXG4gICAgdGhyb3R0bGU6IDAsXFxuICAgIHByb3h5OiBmYWxzZSxcXG4gICAgYmFzZVBhdGg6ICcnLFxcbiAgICBhZGFwdGVyOiB1bmRlZmluZWQsXFxuICAgIG1heENvbnRlbnRMZW5ndGg6IDEwNzM3NDE4MjQsXFxuICAgIC8vIDFHQlxcbiAgICBtYXhCb2R5TGVuZ3RoOiAxMDczNzQxODI0IC8vIDFHQlxcbiAgfTtcXG5cXG4gIHZhciBjb25maWcgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdENvbmZpZyksIG9wdGlvbnMpO1xcbiAgaWYgKCFjb25maWcuYWNjZXNzVG9rZW4pIHtcXG4gICAgdmFyIG1pc3NpbmdBY2Nlc3NUb2tlbkVycm9yID0gbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgcGFyYW1ldGVyIGFjY2Vzc1Rva2VuJyk7XFxuICAgIGNvbmZpZy5sb2dIYW5kbGVyKCdlcnJvcicsIG1pc3NpbmdBY2Nlc3NUb2tlbkVycm9yKTtcXG4gICAgdGhyb3cgbWlzc2luZ0FjY2Vzc1Rva2VuRXJyb3I7XFxuICB9XFxuXFxuICAvLyBDb25zdHJ1Y3QgYXhpb3MgYmFzZVVSTCBvcHRpb25cXG4gIHZhciBwcm90b2NvbCA9IGNvbmZpZy5pbnNlY3VyZSA/ICdodHRwJyA6ICdodHRwcyc7XFxuICB2YXIgc3BhY2UgPSBjb25maWcuc3BhY2UgPyBcXFwiXFxcIi5jb25jYXQoY29uZmlnLnNwYWNlLCBcXFwiL1xcXCIpIDogJyc7XFxuICB2YXIgaG9zdG5hbWUgPSBjb25maWcuZGVmYXVsdEhvc3RuYW1lO1xcbiAgdmFyIHBvcnQgPSBjb25maWcuaW5zZWN1cmUgPyA4MCA6IDQ0MztcXG4gIGlmIChjb25maWcuaG9zdCAmJiBIT1NUX1JFR0VYLnRlc3QoY29uZmlnLmhvc3QpKSB7XFxuICAgIHZhciBwYXJzZWQgPSBjb25maWcuaG9zdC5zcGxpdCgnOicpO1xcbiAgICBpZiAocGFyc2VkLmxlbmd0aCA9PT0gMikge1xcbiAgICAgIHZhciBfcGFyc2VkID0gX3NsaWNlZFRvQXJyYXkocGFyc2VkLCAyKTtcXG4gICAgICBob3N0bmFtZSA9IF9wYXJzZWRbMF07XFxuICAgICAgcG9ydCA9IF9wYXJzZWRbMV07XFxuICAgIH0gZWxzZSB7XFxuICAgICAgaG9zdG5hbWUgPSBwYXJzZWRbMF07XFxuICAgIH1cXG4gIH1cXG5cXG4gIC8vIEVuc3VyZSB0aGF0IGJhc2VQYXRoIGRvZXMgc3RhcnQgYnV0IG5vdCBlbmQgd2l0aCBhIHNsYXNoXFxuICBpZiAoY29uZmlnLmJhc2VQYXRoKSB7XFxuICAgIGNvbmZpZy5iYXNlUGF0aCA9IFxcXCIvXFxcIi5jb25jYXQoY29uZmlnLmJhc2VQYXRoLnNwbGl0KCcvJykuZmlsdGVyKEJvb2xlYW4pLmpvaW4oJy8nKSk7XFxuICB9XFxuICB2YXIgYmFzZVVSTCA9IG9wdGlvbnMuYmFzZVVSTCB8fCBcXFwiXFxcIi5jb25jYXQocHJvdG9jb2wsIFxcXCI6Ly9cXFwiKS5jb25jYXQoaG9zdG5hbWUsIFxcXCI6XFxcIikuY29uY2F0KHBvcnQpLmNvbmNhdChjb25maWcuYmFzZVBhdGgsIFxcXCIvc3BhY2VzL1xcXCIpLmNvbmNhdChzcGFjZSk7XFxuICBpZiAoIWNvbmZpZy5oZWFkZXJzLkF1dGhvcml6YXRpb24gJiYgdHlwZW9mIGNvbmZpZy5hY2Nlc3NUb2tlbiAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICBjb25maWcuaGVhZGVycy5BdXRob3JpemF0aW9uID0gJ0JlYXJlciAnICsgY29uZmlnLmFjY2Vzc1Rva2VuO1xcbiAgfVxcbiAgdmFyIGF4aW9zT3B0aW9ucyA9IHtcXG4gICAgLy8gQXhpb3NcXG4gICAgYmFzZVVSTDogYmFzZVVSTCxcXG4gICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXFxuICAgIGh0dHBBZ2VudDogY29uZmlnLmh0dHBBZ2VudCxcXG4gICAgaHR0cHNBZ2VudDogY29uZmlnLmh0dHBzQWdlbnQsXFxuICAgIHBhcmFtc1NlcmlhbGl6ZXI6IChxc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fX2RlZmF1bHQoKS5zdHJpbmdpZnkpLFxcbiAgICBwcm94eTogY29uZmlnLnByb3h5LFxcbiAgICB0aW1lb3V0OiBjb25maWcudGltZW91dCxcXG4gICAgYWRhcHRlcjogY29uZmlnLmFkYXB0ZXIsXFxuICAgIG1heENvbnRlbnRMZW5ndGg6IGNvbmZpZy5tYXhDb250ZW50TGVuZ3RoLFxcbiAgICBtYXhCb2R5TGVuZ3RoOiBjb25maWcubWF4Qm9keUxlbmd0aCxcXG4gICAgLy8gQ29udGVudGZ1bFxcbiAgICBsb2dIYW5kbGVyOiBjb25maWcubG9nSGFuZGxlcixcXG4gICAgcmVzcG9uc2VMb2dnZXI6IGNvbmZpZy5yZXNwb25zZUxvZ2dlcixcXG4gICAgcmVxdWVzdExvZ2dlcjogY29uZmlnLnJlcXVlc3RMb2dnZXIsXFxuICAgIHJldHJ5T25FcnJvcjogY29uZmlnLnJldHJ5T25FcnJvclxcbiAgfTtcXG4gIHZhciBpbnN0YW5jZSA9IGF4aW9zLmNyZWF0ZShheGlvc09wdGlvbnMpO1xcbiAgaW5zdGFuY2UuaHR0cENsaWVudFBhcmFtcyA9IG9wdGlvbnM7XFxuXFxuICAvKipcXG4gICAqIENyZWF0ZXMgYSBuZXcgYXhpb3MgaW5zdGFuY2Ugd2l0aCB0aGUgc2FtZSBkZWZhdWx0IGJhc2UgcGFyYW1ldGVycyBhcyB0aGVcXG4gICAqIGN1cnJlbnQgb25lLCBhbmQgd2l0aCBhbnkgb3ZlcnJpZGVzIHBhc3NlZCB0byB0aGUgbmV3UGFyYW1zIG9iamVjdFxcbiAgICogVGhpcyBpcyB1c2VmdWwgYXMgdGhlIFNES3MgdXNlIGRlcGVuZGVuY3kgaW5qZWN0aW9uIHRvIGdldCB0aGUgYXhpb3MgbGlicmFyeVxcbiAgICogYW5kIHRoZSB2ZXJzaW9uIG9mIHRoZSBsaWJyYXJ5IGNvbWVzIGZyb20gZGlmZmVyZW50IHBsYWNlcyBkZXBlbmRpbmdcXG4gICAqIG9uIHdoZXRoZXIgaXQncyBhIGJyb3dzZXIgYnVpbGQgb3IgYSBub2RlLmpzIGJ1aWxkLlxcbiAgICogQHByaXZhdGVcXG4gICAqIEBwYXJhbSB7Q3JlYXRlSHR0cENsaWVudFBhcmFtc30gaHR0cENsaWVudFBhcmFtcyAtIEluaXRpYWxpemF0aW9uIHBhcmFtZXRlcnMgZm9yIHRoZSBIVFRQIGNsaWVudFxcbiAgICogQHJldHVybiB7Q29udGVudGZ1bEF4aW9zSW5zdGFuY2V9IEluaXRpYWxpemVkIGF4aW9zIGluc3RhbmNlXFxuICAgKi9cXG4gIGluc3RhbmNlLmNsb25lV2l0aE5ld1BhcmFtcyA9IGZ1bmN0aW9uIChuZXdQYXJhbXMpIHtcXG4gICAgcmV0dXJuIGNyZWF0ZUh0dHBDbGllbnQoYXhpb3MsIF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBmYXN0X2NvcHlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0KCkob3B0aW9ucykpLCBuZXdQYXJhbXMpKTtcXG4gIH07XFxuXFxuICAvKipcXG4gICAqIEFwcGx5IGludGVyY2VwdG9ycy5cXG4gICAqIFBsZWFzZSBub3RlIHRoYXQgdGhlIG9yZGVyIG9mIGludGVyY2VwdG9ycyBpcyBpbXBvcnRhbnRcXG4gICAqL1xcblxcbiAgaWYgKGNvbmZpZy5vbkJlZm9yZVJlcXVlc3QpIHtcXG4gICAgaW5zdGFuY2UuaW50ZXJjZXB0b3JzLnJlcXVlc3QudXNlKGNvbmZpZy5vbkJlZm9yZVJlcXVlc3QpO1xcbiAgfVxcbiAgaWYgKHR5cGVvZiBjb25maWcuYWNjZXNzVG9rZW4gPT09ICdmdW5jdGlvbicpIHtcXG4gICAgYXN5bmNUb2tlbihpbnN0YW5jZSwgY29uZmlnLmFjY2Vzc1Rva2VuKTtcXG4gIH1cXG4gIGlmIChjb25maWcudGhyb3R0bGUpIHtcXG4gICAgcmF0ZUxpbWl0VGhyb3R0bGUoaW5zdGFuY2UsIGNvbmZpZy50aHJvdHRsZSk7XFxuICB9XFxuICByYXRlTGltaXQoaW5zdGFuY2UsIGNvbmZpZy5yZXRyeUxpbWl0KTtcXG4gIGlmIChjb25maWcub25FcnJvcikge1xcbiAgICBpbnN0YW5jZS5pbnRlcmNlcHRvcnMucmVzcG9uc2UudXNlKGZ1bmN0aW9uIChyZXNwb25zZSkge1xcbiAgICAgIHJldHVybiByZXNwb25zZTtcXG4gICAgfSwgY29uZmlnLm9uRXJyb3IpO1xcbiAgfVxcbiAgcmV0dXJuIGluc3RhbmNlO1xcbn1cXG5cXG4vKiBlc2xpbnQtZGlzYWJsZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tZXhwbGljaXQtYW55ICovXFxuLyoqXFxuICogQ3JlYXRlcyByZXF1ZXN0IHBhcmFtZXRlcnMgY29uZmlndXJhdGlvbiBieSBwYXJzaW5nIGFuIGV4aXN0aW5nIHF1ZXJ5IG9iamVjdFxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHtPYmplY3R9IHF1ZXJ5XFxuICogQHJldHVybiB7T2JqZWN0fSBDb25maWcgb2JqZWN0IHdpdGggYHBhcmFtc2AgcHJvcGVydHksIHJlYWR5IHRvIGJlIHVzZWQgaW4gYXhpb3NcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0Q29uZmlnKF9yZWYpIHtcXG4gIHZhciBxdWVyeSA9IF9yZWYucXVlcnk7XFxuICB2YXIgY29uZmlnID0ge307XFxuICBkZWxldGUgcXVlcnkucmVzb2x2ZUxpbmtzO1xcbiAgY29uZmlnLnBhcmFtcyA9IGZhc3RfY29weV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKShxdWVyeSk7XFxuICByZXR1cm4gY29uZmlnO1xcbn1cXG5cXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgQHR5cGVzY3JpcHQtZXNsaW50L25vLWV4cGxpY2l0LWFueVxcbmZ1bmN0aW9uIGVuZm9yY2VPYmpQYXRoKG9iaiwgcGF0aCkge1xcbiAgaWYgKCEocGF0aCBpbiBvYmopKSB7XFxuICAgIHZhciBlcnIgPSBuZXcgRXJyb3IoKTtcXG4gICAgZXJyLm5hbWUgPSAnUHJvcGVydHlNaXNzaW5nJztcXG4gICAgZXJyLm1lc3NhZ2UgPSBcXFwiUmVxdWlyZWQgcHJvcGVydHkgXFxcIi5jb25jYXQocGF0aCwgXFxcIiBtaXNzaW5nIGZyb206XFxcXG5cXFxcblxcXCIpLmNvbmNhdChKU09OLnN0cmluZ2lmeShvYmopLCBcXFwiXFxcXG5cXFxcblxcXCIpO1xcbiAgICB0aHJvdyBlcnI7XFxuICB9XFxuICByZXR1cm4gdHJ1ZTtcXG59XFxuXFxuLy8gY29waWVkIGZyb20gaHR0cHM6Ly9kZXZlbG9wZXIubW96aWxsYS5vcmcvZW4tVVMvZG9jcy9XZWIvSmF2YVNjcmlwdC9SZWZlcmVuY2UvR2xvYmFsX09iamVjdHMvT2JqZWN0L2ZyZWV6ZVxcblxcbmZ1bmN0aW9uIGRlZXBGcmVlemUob2JqZWN0KSB7XFxuICB2YXIgcHJvcE5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMob2JqZWN0KTtcXG4gIHZhciBfaXRlcmF0b3IgPSBfY3JlYXRlRm9yT2ZJdGVyYXRvckhlbHBlcihwcm9wTmFtZXMpLFxcbiAgICBfc3RlcDtcXG4gIHRyeSB7XFxuICAgIGZvciAoX2l0ZXJhdG9yLnMoKTsgIShfc3RlcCA9IF9pdGVyYXRvci5uKCkpLmRvbmU7KSB7XFxuICAgICAgdmFyIG5hbWUgPSBfc3RlcC52YWx1ZTtcXG4gICAgICB2YXIgdmFsdWUgPSBvYmplY3RbbmFtZV07XFxuICAgICAgaWYgKHZhbHVlICYmIF90eXBlb2YodmFsdWUpID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgZGVlcEZyZWV6ZSh2YWx1ZSk7XFxuICAgICAgfVxcbiAgICB9XFxuICB9IGNhdGNoIChlcnIpIHtcXG4gICAgX2l0ZXJhdG9yLmUoZXJyKTtcXG4gIH0gZmluYWxseSB7XFxuICAgIF9pdGVyYXRvci5mKCk7XFxuICB9XFxuICByZXR1cm4gT2JqZWN0LmZyZWV6ZShvYmplY3QpO1xcbn1cXG5mdW5jdGlvbiBmcmVlemVTeXMob2JqKSB7XFxuICBkZWVwRnJlZXplKG9iai5zeXMgfHwge30pO1xcbiAgcmV0dXJuIG9iajtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0QnJvd3Nlck9TKCkge1xcbiAgdmFyIHdpbiA9IGdldFdpbmRvdygpO1xcbiAgaWYgKCF3aW4pIHtcXG4gICAgcmV0dXJuIG51bGw7XFxuICB9XFxuICB2YXIgdXNlckFnZW50ID0gd2luLm5hdmlnYXRvci51c2VyQWdlbnQ7XFxuICAvLyBUT0RPOiBwbGF0Zm9ybSBpcyBkZXByZWNhdGVkLlxcbiAgdmFyIHBsYXRmb3JtID0gd2luLm5hdmlnYXRvci5wbGF0Zm9ybTtcXG4gIHZhciBtYWNvc1BsYXRmb3JtcyA9IFsnTWFjaW50b3NoJywgJ01hY0ludGVsJywgJ01hY1BQQycsICdNYWM2OEsnXTtcXG4gIHZhciB3aW5kb3dzUGxhdGZvcm1zID0gWydXaW4zMicsICdXaW42NCcsICdXaW5kb3dzJywgJ1dpbkNFJ107XFxuICB2YXIgaW9zUGxhdGZvcm1zID0gWydpUGhvbmUnLCAnaVBhZCcsICdpUG9kJ107XFxuICBpZiAobWFjb3NQbGF0Zm9ybXMuaW5kZXhPZihwbGF0Zm9ybSkgIT09IC0xKSB7XFxuICAgIHJldHVybiAnbWFjT1MnO1xcbiAgfSBlbHNlIGlmIChpb3NQbGF0Zm9ybXMuaW5kZXhPZihwbGF0Zm9ybSkgIT09IC0xKSB7XFxuICAgIHJldHVybiAnaU9TJztcXG4gIH0gZWxzZSBpZiAod2luZG93c1BsYXRmb3Jtcy5pbmRleE9mKHBsYXRmb3JtKSAhPT0gLTEpIHtcXG4gICAgcmV0dXJuICdXaW5kb3dzJztcXG4gIH0gZWxzZSBpZiAoL0FuZHJvaWQvLnRlc3QodXNlckFnZW50KSkge1xcbiAgICByZXR1cm4gJ0FuZHJvaWQnO1xcbiAgfSBlbHNlIGlmICgvTGludXgvLnRlc3QocGxhdGZvcm0pKSB7XFxuICAgIHJldHVybiAnTGludXgnO1xcbiAgfVxcbiAgcmV0dXJuIG51bGw7XFxufVxcbmZ1bmN0aW9uIGdldE5vZGVPUygpIHtcXG4gIHZhciBwbGF0Zm9ybSA9IHByb2Nlc3MucGxhdGZvcm0gfHwgJ2xpbnV4JztcXG4gIHZhciB2ZXJzaW9uID0gcHJvY2Vzcy52ZXJzaW9uIHx8ICcwLjAuMCc7XFxuICB2YXIgcGxhdGZvcm1NYXAgPSB7XFxuICAgIGFuZHJvaWQ6ICdBbmRyb2lkJyxcXG4gICAgYWl4OiAnTGludXgnLFxcbiAgICBkYXJ3aW46ICdtYWNPUycsXFxuICAgIGZyZWVic2Q6ICdMaW51eCcsXFxuICAgIGxpbnV4OiAnTGludXgnLFxcbiAgICBvcGVuYnNkOiAnTGludXgnLFxcbiAgICBzdW5vczogJ0xpbnV4JyxcXG4gICAgd2luMzI6ICdXaW5kb3dzJ1xcbiAgfTtcXG4gIGlmIChwbGF0Zm9ybSBpbiBwbGF0Zm9ybU1hcCkge1xcbiAgICByZXR1cm4gXFxcIlxcXCIuY29uY2F0KHBsYXRmb3JtTWFwW3BsYXRmb3JtXSB8fCAnTGludXgnLCBcXFwiL1xcXCIpLmNvbmNhdCh2ZXJzaW9uKTtcXG4gIH1cXG4gIHJldHVybiBudWxsO1xcbn1cXG5mdW5jdGlvbiBnZXRVc2VyQWdlbnRIZWFkZXIoc2RrLCBhcHBsaWNhdGlvbiwgaW50ZWdyYXRpb24sIGZlYXR1cmUpIHtcXG4gIHZhciBoZWFkZXJQYXJ0cyA9IFtdO1xcbiAgaWYgKGFwcGxpY2F0aW9uKSB7XFxuICAgIGhlYWRlclBhcnRzLnB1c2goXFxcImFwcCBcXFwiLmNvbmNhdChhcHBsaWNhdGlvbikpO1xcbiAgfVxcbiAgaWYgKGludGVncmF0aW9uKSB7XFxuICAgIGhlYWRlclBhcnRzLnB1c2goXFxcImludGVncmF0aW9uIFxcXCIuY29uY2F0KGludGVncmF0aW9uKSk7XFxuICB9XFxuICBpZiAoZmVhdHVyZSkge1xcbiAgICBoZWFkZXJQYXJ0cy5wdXNoKCdmZWF0dXJlICcgKyBmZWF0dXJlKTtcXG4gIH1cXG4gIGhlYWRlclBhcnRzLnB1c2goXFxcInNkayBcXFwiLmNvbmNhdChzZGspKTtcXG4gIHZhciBwbGF0Zm9ybSA9IG51bGw7XFxuICB0cnkge1xcbiAgICBpZiAoaXNSZWFjdE5hdGl2ZSgpKSB7XFxuICAgICAgcGxhdGZvcm0gPSBnZXRCcm93c2VyT1MoKTtcXG4gICAgICBoZWFkZXJQYXJ0cy5wdXNoKCdwbGF0Zm9ybSBSZWFjdE5hdGl2ZScpO1xcbiAgICB9IGVsc2UgaWYgKGlzTm9kZSgpKSB7XFxuICAgICAgcGxhdGZvcm0gPSBnZXROb2RlT1MoKTtcXG4gICAgICBoZWFkZXJQYXJ0cy5wdXNoKFxcXCJwbGF0Zm9ybSBub2RlLmpzL1xcXCIuY29uY2F0KGdldE5vZGVWZXJzaW9uKCkpKTtcXG4gICAgfSBlbHNlIHtcXG4gICAgICBwbGF0Zm9ybSA9IGdldEJyb3dzZXJPUygpO1xcbiAgICAgIGhlYWRlclBhcnRzLnB1c2goJ3BsYXRmb3JtIGJyb3dzZXInKTtcXG4gICAgfVxcbiAgfSBjYXRjaCAoZSkge1xcbiAgICBwbGF0Zm9ybSA9IG51bGw7XFxuICB9XFxuICBpZiAocGxhdGZvcm0pIHtcXG4gICAgaGVhZGVyUGFydHMucHVzaChcXFwib3MgXFxcIi5jb25jYXQocGxhdGZvcm0pKTtcXG4gIH1cXG4gIHJldHVybiBcXFwiXFxcIi5jb25jYXQoaGVhZGVyUGFydHMuZmlsdGVyKGZ1bmN0aW9uIChpdGVtKSB7XFxuICAgIHJldHVybiBpdGVtICE9PSAnJztcXG4gIH0pLmpvaW4oJzsgJyksIFxcXCI7XFxcIik7XFxufVxcblxcbi8qKlxcbiAqIE1peGVzIGluIGEgbWV0aG9kIHRvIHJldHVybiBqdXN0IGEgcGxhaW4gb2JqZWN0IHdpdGggbm8gYWRkaXRpb25hbCBtZXRob2RzXFxuICogQHByaXZhdGVcXG4gKiBAcGFyYW0gZGF0YSAtIEFueSBwbGFpbiBKU09OIHJlc3BvbnNlIHJldHVybmVkIGZyb20gdGhlIEFQSVxcbiAqIEByZXR1cm4gRW5oYW5jZWQgb2JqZWN0IHdpdGggdG9QbGFpbk9iamVjdCBtZXRob2RcXG4gKi9cXG5mdW5jdGlvbiB0b1BsYWluT2JqZWN0KGRhdGEpIHtcXG4gIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvYmFuLXRzLWNvbW1lbnRcXG4gIC8vIEB0cy1leHBlY3QtZXJyb3JcXG4gIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YSwgJ3RvUGxhaW5PYmplY3QnLCB7XFxuICAgIGVudW1lcmFibGU6IGZhbHNlLFxcbiAgICBjb25maWd1cmFibGU6IGZhbHNlLFxcbiAgICB3cml0YWJsZTogZmFsc2UsXFxuICAgIHZhbHVlOiBmdW5jdGlvbiB2YWx1ZSgpIHtcXG4gICAgICByZXR1cm4gZmFzdF9jb3B5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMpO1xcbiAgICB9XFxuICB9KTtcXG59XFxuXFxuLyoqXFxuICogSGFuZGxlcyBlcnJvcnMgcmVjZWl2ZWQgZnJvbSB0aGUgc2VydmVyLiBQYXJzZXMgdGhlIGVycm9yIGludG8gYSBtb3JlIHVzZWZ1bFxcbiAqIGZvcm1hdCwgcGxhY2VzIGl0IGluIGFuIGV4Y2VwdGlvbiBhbmQgdGhyb3dzIGl0LlxcbiAqIFNlZSBodHRwczovL3d3dy5jb250ZW50ZnVsLmNvbS9kZXZlbG9wZXJzL2RvY3MvcmVmZXJlbmNlcy9lcnJvcnMvXFxuICogZm9yIG1vcmUgZGV0YWlscyBvbiB0aGUgZGF0YSByZWNlaXZlZCBvbiB0aGUgZXJyb3JSZXNwb25zZS5kYXRhIHByb3BlcnR5XFxuICogYW5kIHRoZSBleHBlY3RlZCBlcnJvciBjb2Rlcy5cXG4gKiBAcHJpdmF0ZVxcbiAqL1xcbmZ1bmN0aW9uIGVycm9ySGFuZGxlcihlcnJvclJlc3BvbnNlKSB7XFxuICB2YXIgY29uZmlnID0gZXJyb3JSZXNwb25zZS5jb25maWcsXFxuICAgIHJlc3BvbnNlID0gZXJyb3JSZXNwb25zZS5yZXNwb25zZTtcXG4gIHZhciBlcnJvck5hbWU7XFxuXFxuICAvLyBPYnNjdXJlIHRoZSBNYW5hZ2VtZW50IHRva2VuXFxuICBpZiAoY29uZmlnICYmIGNvbmZpZy5oZWFkZXJzICYmIGNvbmZpZy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10pIHtcXG4gICAgdmFyIHRva2VuID0gXFxcIi4uLlxcXCIuY29uY2F0KGNvbmZpZy5oZWFkZXJzWydBdXRob3JpemF0aW9uJ10udG9TdHJpbmcoKS5zdWJzdHIoLTUpKTtcXG4gICAgY29uZmlnLmhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IFxcXCJCZWFyZXIgXFxcIi5jb25jYXQodG9rZW4pO1xcbiAgfVxcbiAgaWYgKCFsb2Rhc2hfaXNwbGFpbm9iamVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fX2RlZmF1bHQoKShyZXNwb25zZSkgfHwgIWxvZGFzaF9pc3BsYWlub2JqZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19fZGVmYXVsdCgpKGNvbmZpZykpIHtcXG4gICAgdGhyb3cgZXJyb3JSZXNwb25zZTtcXG4gIH1cXG4gIHZhciBkYXRhID0gcmVzcG9uc2UgPT09IG51bGwgfHwgcmVzcG9uc2UgPT09IHZvaWQgMCA/IHZvaWQgMCA6IHJlc3BvbnNlLmRhdGE7XFxuICB2YXIgZXJyb3JEYXRhID0ge1xcbiAgICBzdGF0dXM6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsXFxuICAgIHN0YXR1c1RleHQ6IHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0LFxcbiAgICBtZXNzYWdlOiAnJyxcXG4gICAgZGV0YWlsczoge31cXG4gIH07XFxuICBpZiAobG9kYXNoX2lzcGxhaW5vYmplY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0KCkoY29uZmlnKSkge1xcbiAgICBlcnJvckRhdGEucmVxdWVzdCA9IHtcXG4gICAgICB1cmw6IGNvbmZpZy51cmwsXFxuICAgICAgaGVhZGVyczogY29uZmlnLmhlYWRlcnMsXFxuICAgICAgbWV0aG9kOiBjb25maWcubWV0aG9kLFxcbiAgICAgIHBheWxvYWREYXRhOiBjb25maWcuZGF0YVxcbiAgICB9O1xcbiAgfVxcbiAgaWYgKGRhdGEgJiYgbG9kYXNoX2lzcGxhaW5vYmplY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfX19kZWZhdWx0KCkoZGF0YSkpIHtcXG4gICAgaWYgKCdyZXF1ZXN0SWQnIGluIGRhdGEpIHtcXG4gICAgICBlcnJvckRhdGEucmVxdWVzdElkID0gZGF0YS5yZXF1ZXN0SWQgfHwgJ1VOS05PV04nO1xcbiAgICB9XFxuICAgIGlmICgnbWVzc2FnZScgaW4gZGF0YSkge1xcbiAgICAgIGVycm9yRGF0YS5tZXNzYWdlID0gZGF0YS5tZXNzYWdlIHx8ICcnO1xcbiAgICB9XFxuICAgIGlmICgnZGV0YWlscycgaW4gZGF0YSkge1xcbiAgICAgIGVycm9yRGF0YS5kZXRhaWxzID0gZGF0YS5kZXRhaWxzIHx8IHt9O1xcbiAgICB9XFxuICAgIGlmICgnc3lzJyBpbiBkYXRhKSB7XFxuICAgICAgaWYgKCdpZCcgaW4gZGF0YS5zeXMpIHtcXG4gICAgICAgIGVycm9yTmFtZSA9IGRhdGEuc3lzLmlkO1xcbiAgICAgIH1cXG4gICAgfVxcbiAgfVxcbiAgdmFyIGVycm9yID0gbmV3IEVycm9yKCk7XFxuICBlcnJvci5uYW1lID0gZXJyb3JOYW1lICYmIGVycm9yTmFtZSAhPT0gJ1Vua25vd24nID8gZXJyb3JOYW1lIDogXFxcIlxcXCIuY29uY2F0KHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXMsIFxcXCIgXFxcIikuY29uY2F0KHJlc3BvbnNlID09PSBudWxsIHx8IHJlc3BvbnNlID09PSB2b2lkIDAgPyB2b2lkIDAgOiByZXNwb25zZS5zdGF0dXNUZXh0KTtcXG4gIHRyeSB7XFxuICAgIGVycm9yLm1lc3NhZ2UgPSBKU09OLnN0cmluZ2lmeShlcnJvckRhdGEsIG51bGwsICcgICcpO1xcbiAgfSBjYXRjaCAoX3VudXNlZCkge1xcbiAgICB2YXIgX2Vycm9yRGF0YSRtZXNzYWdlO1xcbiAgICBlcnJvci5tZXNzYWdlID0gKF9lcnJvckRhdGEkbWVzc2FnZSA9IGVycm9yRGF0YSA9PT0gbnVsbCB8fCBlcnJvckRhdGEgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGVycm9yRGF0YS5tZXNzYWdlKSAhPT0gbnVsbCAmJiBfZXJyb3JEYXRhJG1lc3NhZ2UgIT09IHZvaWQgMCA/IF9lcnJvckRhdGEkbWVzc2FnZSA6ICcnO1xcbiAgfVxcbiAgdGhyb3cgZXJyb3I7XFxufVxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtc2RrLWNvcmUvZGlzdC9pbmRleC5lcy1tb2R1bGVzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2Zhc3QtY29weS9kaXN0L2Zhc3QtY29weS5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9mYXN0LWNvcHkvZGlzdC9mYXN0LWNvcHkuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovIChmdW5jdGlvbihtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykge1xuXG5ldmFsKFwiKGZ1bmN0aW9uIChnbG9iYWwsIGZhY3RvcnkpIHtcXG4gICAgIHRydWUgPyBtb2R1bGUuZXhwb3J0cyA9IGZhY3RvcnkoKSA6XFxuICAgIDA7XFxufSkodGhpcywgKGZ1bmN0aW9uICgpIHsgJ3VzZSBzdHJpY3QnO1xcblxcbiAgICB2YXIgdG9TdHJpbmdGdW5jdGlvbiA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcXG4gICAgdmFyIGNyZWF0ZSA9IE9iamVjdC5jcmVhdGUsIGRlZmluZVByb3BlcnR5ID0gT2JqZWN0LmRlZmluZVByb3BlcnR5LCBnZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yLCBnZXRPd25Qcm9wZXJ0eU5hbWVzID0gT2JqZWN0LmdldE93blByb3BlcnR5TmFtZXMsIGdldE93blByb3BlcnR5U3ltYm9scyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMsIGdldFByb3RvdHlwZU9mJDEgPSBPYmplY3QuZ2V0UHJvdG90eXBlT2Y7XFxuICAgIHZhciBfYSA9IE9iamVjdC5wcm90b3R5cGUsIGhhc093blByb3BlcnR5ID0gX2EuaGFzT3duUHJvcGVydHksIHByb3BlcnR5SXNFbnVtZXJhYmxlID0gX2EucHJvcGVydHlJc0VudW1lcmFibGU7XFxuICAgIHZhciBTWU1CT0xfUFJPUEVSVElFUyA9IHR5cGVvZiBnZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09ICdmdW5jdGlvbic7XFxuICAgIHZhciBXRUFLX01BUCA9IHR5cGVvZiBXZWFrTWFwID09PSAnZnVuY3Rpb24nO1xcbiAgICAvKipcXG4gICAgICogQGZ1bmN0aW9uIGNyZWF0ZUNhY2hlXFxuICAgICAqXFxuICAgICAqIEBkZXNjcmlwdGlvblxcbiAgICAgKiBnZXQgYSBuZXcgY2FjaGUgb2JqZWN0IHRvIHByZXZlbnQgY2lyY3VsYXIgcmVmZXJlbmNlc1xcbiAgICAgKlxcbiAgICAgKiBAcmV0dXJucyB0aGUgbmV3IGNhY2hlIG9iamVjdFxcbiAgICAgKi9cXG4gICAgdmFyIGNyZWF0ZUNhY2hlID0gKGZ1bmN0aW9uICgpIHtcXG4gICAgICAgIGlmIChXRUFLX01BUCkge1xcbiAgICAgICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgV2Vha01hcCgpOyB9O1xcbiAgICAgICAgfVxcbiAgICAgICAgdmFyIENhY2hlID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgICAgIGZ1bmN0aW9uIENhY2hlKCkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzID0gW107XFxuICAgICAgICAgICAgICAgIHRoaXMuX3ZhbHVlcyA9IFtdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBDYWNoZS5wcm90b3R5cGUuaGFzID0gZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gISF+dGhpcy5fa2V5cy5pbmRleE9mKGtleSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICBDYWNoZS5wcm90b3R5cGUuZ2V0ID0gZnVuY3Rpb24gKGtleSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdGhpcy5fdmFsdWVzW3RoaXMuX2tleXMuaW5kZXhPZihrZXkpXTtcXG4gICAgICAgICAgICB9O1xcbiAgICAgICAgICAgIENhY2hlLnByb3RvdHlwZS5zZXQgPSBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICB0aGlzLl9rZXlzLnB1c2goa2V5KTtcXG4gICAgICAgICAgICAgICAgdGhpcy5fdmFsdWVzLnB1c2godmFsdWUpO1xcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgcmV0dXJuIENhY2hlO1xcbiAgICAgICAgfSgpKTtcXG4gICAgICAgIHJldHVybiBmdW5jdGlvbiAoKSB7IHJldHVybiBuZXcgQ2FjaGUoKTsgfTtcXG4gICAgfSkoKTtcXG4gICAgLyoqXFxuICAgICAqIEBmdW5jdGlvbiBnZXRDbGVhbkNsb25lXFxuICAgICAqXFxuICAgICAqIEBkZXNjcmlwdGlvblxcbiAgICAgKiBnZXQgYW4gZW1wdHkgdmVyc2lvbiBvZiB0aGUgb2JqZWN0IHdpdGggdGhlIHNhbWUgcHJvdG90eXBlIGl0IGhhc1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gYnVpbGQgYSBjbGVhbiBjbG9uZSBmcm9tXFxuICAgICAqIEBwYXJhbSByZWFsbSB0aGUgcmVhbG0gdGhlIG9iamVjdCByZXNpZGVzIGluXFxuICAgICAqIEByZXR1cm5zIHRoZSBlbXB0eSBjbG9uZWQgb2JqZWN0XFxuICAgICAqL1xcbiAgICB2YXIgZ2V0Q2xlYW5DbG9uZSA9IGZ1bmN0aW9uIChvYmplY3QsIHJlYWxtKSB7XFxuICAgICAgICB2YXIgcHJvdG90eXBlID0gb2JqZWN0Ll9fcHJvdG9fXyB8fCBnZXRQcm90b3R5cGVPZiQxKG9iamVjdCk7XFxuICAgICAgICBpZiAoIXByb3RvdHlwZSkge1xcbiAgICAgICAgICAgIHJldHVybiBjcmVhdGUobnVsbCk7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBwcm90b3R5cGUuY29uc3RydWN0b3I7XFxuICAgICAgICBpZiAoQ29uc3RydWN0b3IgPT09IHJlYWxtLk9iamVjdCkge1xcbiAgICAgICAgICAgIHJldHVybiBwcm90b3R5cGUgPT09IHJlYWxtLk9iamVjdC5wcm90b3R5cGUgPyB7fSA6IGNyZWF0ZShwcm90b3R5cGUpO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKH50b1N0cmluZ0Z1bmN0aW9uLmNhbGwoQ29uc3RydWN0b3IpLmluZGV4T2YoJ1tuYXRpdmUgY29kZV0nKSkge1xcbiAgICAgICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBuZXcgQ29uc3RydWN0b3IoKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgY2F0Y2ggKF9hKSB7IH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjcmVhdGUocHJvdG90eXBlKTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEBmdW5jdGlvbiBnZXRPYmplY3RDbG9uZUxvb3NlXFxuICAgICAqXFxuICAgICAqIEBkZXNjcmlwdGlvblxcbiAgICAgKiBnZXQgYSBjb3B5IG9mIHRoZSBvYmplY3QgYmFzZWQgb24gbG9vc2UgcnVsZXMsIG1lYW5pbmcgYWxsIGVudW1lcmFibGUga2V5c1xcbiAgICAgKiBhbmQgc3ltYm9scyBhcmUgY29waWVkLCBidXQgcHJvcGVydHkgZGVzY3JpcHRvcnMgYXJlIG5vdCBjb25zaWRlcmVkXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSBvYmplY3QgdGhlIG9iamVjdCB0byBjbG9uZVxcbiAgICAgKiBAcGFyYW0gcmVhbG0gdGhlIHJlYWxtIHRoZSBvYmplY3QgcmVzaWRlcyBpblxcbiAgICAgKiBAcGFyYW0gaGFuZGxlQ29weSB0aGUgZnVuY3Rpb24gdGhhdCBoYW5kbGVzIGNvcHlpbmcgdGhlIG9iamVjdFxcbiAgICAgKiBAcmV0dXJucyB0aGUgY29waWVkIG9iamVjdFxcbiAgICAgKi9cXG4gICAgdmFyIGdldE9iamVjdENsb25lTG9vc2UgPSBmdW5jdGlvbiAob2JqZWN0LCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpIHtcXG4gICAgICAgIHZhciBjbG9uZSA9IGdldENsZWFuQ2xvbmUob2JqZWN0LCByZWFsbSk7XFxuICAgICAgICAvLyBzZXQgaW4gdGhlIGNhY2hlIGltbWVkaWF0ZWx5IHRvIGJlIGFibGUgdG8gcmV1c2UgdGhlIG9iamVjdCByZWN1cnNpdmVseVxcbiAgICAgICAgY2FjaGUuc2V0KG9iamVjdCwgY2xvbmUpO1xcbiAgICAgICAgZm9yICh2YXIga2V5IGluIG9iamVjdCkge1xcbiAgICAgICAgICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKG9iamVjdCwga2V5KSkge1xcbiAgICAgICAgICAgICAgICBjbG9uZVtrZXldID0gaGFuZGxlQ29weShvYmplY3Rba2V5XSwgY2FjaGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChTWU1CT0xfUFJPUEVSVElFUykge1xcbiAgICAgICAgICAgIHZhciBzeW1ib2xzID0gZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XFxuICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGhfMSA9IHN5bWJvbHMubGVuZ3RoLCBzeW1ib2wgPSB2b2lkIDA7IGluZGV4IDwgbGVuZ3RoXzE7ICsraW5kZXgpIHtcXG4gICAgICAgICAgICAgICAgc3ltYm9sID0gc3ltYm9sc1tpbmRleF07XFxuICAgICAgICAgICAgICAgIGlmIChwcm9wZXJ0eUlzRW51bWVyYWJsZS5jYWxsKG9iamVjdCwgc3ltYm9sKSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVbc3ltYm9sXSA9IGhhbmRsZUNvcHkob2JqZWN0W3N5bWJvbF0sIGNhY2hlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjbG9uZTtcXG4gICAgfTtcXG4gICAgLyoqXFxuICAgICAqIEBmdW5jdGlvbiBnZXRPYmplY3RDbG9uZVN0cmljdFxcbiAgICAgKlxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogZ2V0IGEgY29weSBvZiB0aGUgb2JqZWN0IGJhc2VkIG9uIHN0cmljdCBydWxlcywgbWVhbmluZyBhbGwga2V5cyBhbmQgc3ltYm9sc1xcbiAgICAgKiBhcmUgY29waWVkIGJhc2VkIG9uIHRoZSBvcmlnaW5hbCBwcm9wZXJ0eSBkZXNjcmlwdG9yc1xcbiAgICAgKlxcbiAgICAgKiBAcGFyYW0gb2JqZWN0IHRoZSBvYmplY3QgdG8gY2xvbmVcXG4gICAgICogQHBhcmFtIHJlYWxtIHRoZSByZWFsbSB0aGUgb2JqZWN0IHJlc2lkZXMgaW5cXG4gICAgICogQHBhcmFtIGhhbmRsZUNvcHkgdGhlIGZ1bmN0aW9uIHRoYXQgaGFuZGxlcyBjb3B5aW5nIHRoZSBvYmplY3RcXG4gICAgICogQHJldHVybnMgdGhlIGNvcGllZCBvYmplY3RcXG4gICAgICovXFxuICAgIHZhciBnZXRPYmplY3RDbG9uZVN0cmljdCA9IGZ1bmN0aW9uIChvYmplY3QsIHJlYWxtLCBoYW5kbGVDb3B5LCBjYWNoZSkge1xcbiAgICAgICAgdmFyIGNsb25lID0gZ2V0Q2xlYW5DbG9uZShvYmplY3QsIHJlYWxtKTtcXG4gICAgICAgIC8vIHNldCBpbiB0aGUgY2FjaGUgaW1tZWRpYXRlbHkgdG8gYmUgYWJsZSB0byByZXVzZSB0aGUgb2JqZWN0IHJlY3Vyc2l2ZWx5XFxuICAgICAgICBjYWNoZS5zZXQob2JqZWN0LCBjbG9uZSk7XFxuICAgICAgICB2YXIgcHJvcGVydGllcyA9IFNZTUJPTF9QUk9QRVJUSUVTXFxuICAgICAgICAgICAgPyBnZXRPd25Qcm9wZXJ0eU5hbWVzKG9iamVjdCkuY29uY2F0KGdldE93blByb3BlcnR5U3ltYm9scyhvYmplY3QpKVxcbiAgICAgICAgICAgIDogZ2V0T3duUHJvcGVydHlOYW1lcyhvYmplY3QpO1xcbiAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGhfMiA9IHByb3BlcnRpZXMubGVuZ3RoLCBwcm9wZXJ0eSA9IHZvaWQgMCwgZGVzY3JpcHRvciA9IHZvaWQgMDsgaW5kZXggPCBsZW5ndGhfMjsgKytpbmRleCkge1xcbiAgICAgICAgICAgIHByb3BlcnR5ID0gcHJvcGVydGllc1tpbmRleF07XFxuICAgICAgICAgICAgaWYgKHByb3BlcnR5ICE9PSAnY2FsbGVlJyAmJiBwcm9wZXJ0eSAhPT0gJ2NhbGxlcicpIHtcXG4gICAgICAgICAgICAgICAgZGVzY3JpcHRvciA9IGdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmplY3QsIHByb3BlcnR5KTtcXG4gICAgICAgICAgICAgICAgaWYgKGRlc2NyaXB0b3IpIHtcXG4gICAgICAgICAgICAgICAgICAgIC8vIE9ubHkgY2xvbmUgdGhlIHZhbHVlIGlmIGFjdHVhbGx5IGEgdmFsdWUsIG5vdCBhIGdldHRlciAvIHNldHRlci5cXG4gICAgICAgICAgICAgICAgICAgIGlmICghZGVzY3JpcHRvci5nZXQgJiYgIWRlc2NyaXB0b3Iuc2V0KSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgZGVzY3JpcHRvci52YWx1ZSA9IGhhbmRsZUNvcHkob2JqZWN0W3Byb3BlcnR5XSwgY2FjaGUpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICAgICAgICAgICAgICBkZWZpbmVQcm9wZXJ0eShjbG9uZSwgcHJvcGVydHksIGRlc2NyaXB0b3IpO1xcbiAgICAgICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAgICAgY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gVGVlIGFib3ZlIGNhbiBmYWlsIG9uIG5vZGUgaW4gZWRnZSBjYXNlcywgc28gZmFsbCBiYWNrIHRvIHRoZSBsb29zZSBhc3NpZ25tZW50LlxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IGRlc2NyaXB0b3IudmFsdWU7XFxuICAgICAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICAvLyBJbiBleHRyYSBlZGdlIGNhc2VzIHdoZXJlIHRoZSBwcm9wZXJ0eSBkZXNjcmlwdG9yIGNhbm5vdCBiZSByZXRyaXZlZCwgZmFsbCBiYWNrIHRvXFxuICAgICAgICAgICAgICAgICAgICAvLyB0aGUgbG9vc2UgYXNzaWdubWVudC5cXG4gICAgICAgICAgICAgICAgICAgIGNsb25lW3Byb3BlcnR5XSA9IGhhbmRsZUNvcHkob2JqZWN0W3Byb3BlcnR5XSwgY2FjaGUpO1xcbiAgICAgICAgICAgICAgICB9XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGNsb25lO1xcbiAgICB9O1xcbiAgICAvKipcXG4gICAgICogQGZ1bmN0aW9uIGdldFJlZ0V4cEZsYWdzXFxuICAgICAqXFxuICAgICAqIEBkZXNjcmlwdGlvblxcbiAgICAgKiBnZXQgdGhlIGZsYWdzIHRvIGFwcGx5IHRvIHRoZSBjb3BpZWQgcmVnZXhwXFxuICAgICAqXFxuICAgICAqIEBwYXJhbSByZWdFeHAgdGhlIHJlZ2V4cCB0byBnZXQgdGhlIGZsYWdzIG9mXFxuICAgICAqIEByZXR1cm5zIHRoZSBmbGFncyBmb3IgdGhlIHJlZ2V4cFxcbiAgICAgKi9cXG4gICAgdmFyIGdldFJlZ0V4cEZsYWdzID0gZnVuY3Rpb24gKHJlZ0V4cCkge1xcbiAgICAgICAgdmFyIGZsYWdzID0gJyc7XFxuICAgICAgICBpZiAocmVnRXhwLmdsb2JhbCkge1xcbiAgICAgICAgICAgIGZsYWdzICs9ICdnJztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZWdFeHAuaWdub3JlQ2FzZSkge1xcbiAgICAgICAgICAgIGZsYWdzICs9ICdpJztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChyZWdFeHAubXVsdGlsaW5lKSB7XFxuICAgICAgICAgICAgZmxhZ3MgKz0gJ20nO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlZ0V4cC51bmljb2RlKSB7XFxuICAgICAgICAgICAgZmxhZ3MgKz0gJ3UnO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHJlZ0V4cC5zdGlja3kpIHtcXG4gICAgICAgICAgICBmbGFncyArPSAneSc7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gZmxhZ3M7XFxuICAgIH07XFxuXFxuICAgIC8vIHV0aWxzXFxuICAgIHZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcXG4gICAgdmFyIGdldFByb3RvdHlwZU9mID0gT2JqZWN0LmdldFByb3RvdHlwZU9mO1xcbiAgICB2YXIgR0xPQkFMX1RISVMgPSAoZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHR5cGVvZiBnbG9iYWxUaGlzICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHJldHVybiBnbG9iYWxUaGlzO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiBzZWxmICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHJldHVybiBzZWxmO1xcbiAgICAgICAgfVxcbiAgICAgICAgaWYgKHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHdpbmRvdztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmICh0eXBlb2YgX193ZWJwYWNrX3JlcXVpcmVfXy5nICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIHJldHVybiBfX3dlYnBhY2tfcmVxdWlyZV9fLmc7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoY29uc29sZSAmJiBjb25zb2xlLmVycm9yKSB7XFxuICAgICAgICAgICAgY29uc29sZS5lcnJvcignVW5hYmxlIHRvIGxvY2F0ZSBnbG9iYWwgb2JqZWN0LCByZXR1cm5pbmcgXFxcInRoaXNcXFwiLicpO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRoaXM7XFxuICAgIH0pKCk7XFxuICAgIC8qKlxcbiAgICAgKiBAZnVuY3Rpb24gY29weVxcbiAgICAgKlxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogY29weSBhbiB2YWx1ZSBkZWVwbHkgYXMgbXVjaCBhcyBwb3NzaWJsZVxcbiAgICAgKlxcbiAgICAgKiBJZiBgc3RyaWN0YCBpcyBhcHBsaWVkLCB0aGVuIGFsbCBwcm9wZXJ0aWVzIChpbmNsdWRpbmcgbm9uLWVudW1lcmFibGUgb25lcylcXG4gICAgICogYXJlIGNvcGllZCB3aXRoIHRoZWlyIG9yaWdpbmFsIHByb3BlcnR5IGRlc2NyaXB0b3JzIG9uIGJvdGggb2JqZWN0cyBhbmQgYXJyYXlzLlxcbiAgICAgKlxcbiAgICAgKiBUaGUgdmFsdWUgaXMgY29tcGFyZWQgdG8gdGhlIGdsb2JhbCBjb25zdHJ1Y3RvcnMgaW4gdGhlIGByZWFsbWAgcHJvdmlkZWQsXFxuICAgICAqIGFuZCB0aGUgbmF0aXZlIGNvbnN0cnVjdG9yIGlzIGFsd2F5cyB1c2VkIHRvIGVuc3VyZSB0aGF0IGV4dGVuc2lvbnMgb2YgbmF0aXZlXFxuICAgICAqIG9iamVjdHMgKGFsbG93cyBpbiBFUzIwMTUrKSBhcmUgbWFpbnRhaW5lZC5cXG4gICAgICpcXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjb3B5XFxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgZm9yIGNvcHlpbmcgd2l0aFxcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMuaXNTdHJpY3RdIHNob3VsZCB0aGUgY29weSBiZSBzdHJpY3RcXG4gICAgICogQHBhcmFtIFtvcHRpb25zLnJlYWxtXSB0aGUgcmVhbG0gKHRoaXMpIHZhbHVlIHRoZSB2YWx1ZSBpcyBjb3BpZWQgZnJvbVxcbiAgICAgKiBAcmV0dXJucyB0aGUgY29waWVkIHZhbHVlXFxuICAgICAqL1xcbiAgICBmdW5jdGlvbiBjb3B5KHZhbHVlLCBvcHRpb25zKSB7XFxuICAgICAgICAvLyBtYW51YWxseSBjb2FsZXNjZWQgaW5zdGVhZCBvZiBkZWZhdWx0IHBhcmFtZXRlcnMgZm9yIHBlcmZvcm1hbmNlXFxuICAgICAgICB2YXIgaXNTdHJpY3QgPSAhIShvcHRpb25zICYmIG9wdGlvbnMuaXNTdHJpY3QpO1xcbiAgICAgICAgdmFyIHJlYWxtID0gKG9wdGlvbnMgJiYgb3B0aW9ucy5yZWFsbSkgfHwgR0xPQkFMX1RISVM7XFxuICAgICAgICB2YXIgZ2V0T2JqZWN0Q2xvbmUgPSBpc1N0cmljdCA/IGdldE9iamVjdENsb25lU3RyaWN0IDogZ2V0T2JqZWN0Q2xvbmVMb29zZTtcXG4gICAgICAgIC8qKlxcbiAgICAgICAgICogQGZ1bmN0aW9uIGhhbmRsZUNvcHlcXG4gICAgICAgICAqXFxuICAgICAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICAgICAqIGNvcHkgdGhlIHZhbHVlIHJlY3Vyc2l2ZWx5IGJhc2VkIG9uIGl0cyB0eXBlXFxuICAgICAgICAgKlxcbiAgICAgICAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjb3B5XFxuICAgICAgICAgKiBAcmV0dXJucyB0aGUgY29waWVkIHZhbHVlXFxuICAgICAgICAgKi9cXG4gICAgICAgIHZhciBoYW5kbGVDb3B5ID0gZnVuY3Rpb24gKHZhbHVlLCBjYWNoZSkge1xcbiAgICAgICAgICAgIGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIGlmIChjYWNoZS5oYXModmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjYWNoZS5nZXQodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgcHJvdG90eXBlID0gdmFsdWUuX19wcm90b19fIHx8IGdldFByb3RvdHlwZU9mKHZhbHVlKTtcXG4gICAgICAgICAgICB2YXIgQ29uc3RydWN0b3IgPSBwcm90b3R5cGUgJiYgcHJvdG90eXBlLmNvbnN0cnVjdG9yO1xcbiAgICAgICAgICAgIC8vIHBsYWluIG9iamVjdHNcXG4gICAgICAgICAgICBpZiAoIUNvbnN0cnVjdG9yIHx8IENvbnN0cnVjdG9yID09PSByZWFsbS5PYmplY3QpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIGdldE9iamVjdENsb25lKHZhbHVlLCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB2YXIgY2xvbmU7XFxuICAgICAgICAgICAgLy8gYXJyYXlzXFxuICAgICAgICAgICAgaWYgKGlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICAgICAgICAgIC8vIGlmIHN0cmljdCwgaW5jbHVkZSBub24tc3RhbmRhcmQgcHJvcGVydGllc1xcbiAgICAgICAgICAgICAgICBpZiAoaXNTdHJpY3QpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBnZXRPYmplY3RDbG9uZVN0cmljdCh2YWx1ZSwgcmVhbG0sIGhhbmRsZUNvcHksIGNhY2hlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBjbG9uZSA9IG5ldyBDb25zdHJ1Y3RvcigpO1xcbiAgICAgICAgICAgICAgICBjYWNoZS5zZXQodmFsdWUsIGNsb25lKTtcXG4gICAgICAgICAgICAgICAgZm9yICh2YXIgaW5kZXggPSAwLCBsZW5ndGhfMSA9IHZhbHVlLmxlbmd0aDsgaW5kZXggPCBsZW5ndGhfMTsgKytpbmRleCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2xvbmVbaW5kZXhdID0gaGFuZGxlQ29weSh2YWx1ZVtpbmRleF0sIGNhY2hlKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIGRhdGVzXFxuICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVhbG0uRGF0ZSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gbmV3IENvbnN0cnVjdG9yKHZhbHVlLmdldFRpbWUoKSk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIHJlZ2V4cHNcXG4gICAgICAgICAgICBpZiAodmFsdWUgaW5zdGFuY2VvZiByZWFsbS5SZWdFeHApIHtcXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBuZXcgQ29uc3RydWN0b3IodmFsdWUuc291cmNlLCB2YWx1ZS5mbGFncyB8fCBnZXRSZWdFeHBGbGFncyh2YWx1ZSkpO1xcbiAgICAgICAgICAgICAgICBjbG9uZS5sYXN0SW5kZXggPSB2YWx1ZS5sYXN0SW5kZXg7XFxuICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gbWFwc1xcbiAgICAgICAgICAgIGlmIChyZWFsbS5NYXAgJiYgdmFsdWUgaW5zdGFuY2VvZiByZWFsbS5NYXApIHtcXG4gICAgICAgICAgICAgICAgY2xvbmUgPSBuZXcgQ29uc3RydWN0b3IoKTtcXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHZhbHVlLCBjbG9uZSk7XFxuICAgICAgICAgICAgICAgIHZhbHVlLmZvckVhY2goZnVuY3Rpb24gKHZhbHVlLCBrZXkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNsb25lLnNldChrZXksIGhhbmRsZUNvcHkodmFsdWUsIGNhY2hlKSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIHNldHNcXG4gICAgICAgICAgICBpZiAocmVhbG0uU2V0ICYmIHZhbHVlIGluc3RhbmNlb2YgcmVhbG0uU2V0KSB7XFxuICAgICAgICAgICAgICAgIGNsb25lID0gbmV3IENvbnN0cnVjdG9yKCk7XFxuICAgICAgICAgICAgICAgIGNhY2hlLnNldCh2YWx1ZSwgY2xvbmUpO1xcbiAgICAgICAgICAgICAgICB2YWx1ZS5mb3JFYWNoKGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICAgICAgY2xvbmUuYWRkKGhhbmRsZUNvcHkodmFsdWUsIGNhY2hlKSk7XFxuICAgICAgICAgICAgICAgIH0pO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIGJsb2JzXFxuICAgICAgICAgICAgaWYgKHJlYWxtLkJsb2IgJiYgdmFsdWUgaW5zdGFuY2VvZiByZWFsbS5CbG9iKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiB2YWx1ZS5zbGljZSgwLCB2YWx1ZS5zaXplLCB2YWx1ZS50eXBlKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgLy8gYnVmZmVycyAobm9kZS1vbmx5KVxcbiAgICAgICAgICAgIGlmIChyZWFsbS5CdWZmZXIgJiYgcmVhbG0uQnVmZmVyLmlzQnVmZmVyKHZhbHVlKSkge1xcbiAgICAgICAgICAgICAgICBjbG9uZSA9IHJlYWxtLkJ1ZmZlci5hbGxvY1Vuc2FmZVxcbiAgICAgICAgICAgICAgICAgICAgPyByZWFsbS5CdWZmZXIuYWxsb2NVbnNhZmUodmFsdWUubGVuZ3RoKVxcbiAgICAgICAgICAgICAgICAgICAgOiBuZXcgQ29uc3RydWN0b3IodmFsdWUubGVuZ3RoKTtcXG4gICAgICAgICAgICAgICAgY2FjaGUuc2V0KHZhbHVlLCBjbG9uZSk7XFxuICAgICAgICAgICAgICAgIHZhbHVlLmNvcHkoY2xvbmUpO1xcbiAgICAgICAgICAgICAgICByZXR1cm4gY2xvbmU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIGFycmF5YnVmZmVycyAvIGRhdGF2aWV3c1xcbiAgICAgICAgICAgIGlmIChyZWFsbS5BcnJheUJ1ZmZlcikge1xcbiAgICAgICAgICAgICAgICAvLyBkYXRhdmlld3NcXG4gICAgICAgICAgICAgICAgaWYgKHJlYWxtLkFycmF5QnVmZmVyLmlzVmlldyh2YWx1ZSkpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gbmV3IENvbnN0cnVjdG9yKHZhbHVlLmJ1ZmZlci5zbGljZSgwKSk7XFxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQodmFsdWUsIGNsb25lKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICAvLyBhcnJheWJ1ZmZlcnNcXG4gICAgICAgICAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgcmVhbG0uQXJyYXlCdWZmZXIpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNsb25lID0gdmFsdWUuc2xpY2UoMCk7XFxuICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXQodmFsdWUsIGNsb25lKTtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBjbG9uZTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAvLyBpZiB0aGUgdmFsdWUgY2Fubm90IC8gc2hvdWxkIG5vdCBiZSBjbG9uZWQsIGRvbid0XFxuICAgICAgICAgICAgaWYgKFxcbiAgICAgICAgICAgIC8vIHByb21pc2UtbGlrZVxcbiAgICAgICAgICAgIHR5cGVvZiB2YWx1ZS50aGVuID09PSAnZnVuY3Rpb24nIHx8XFxuICAgICAgICAgICAgICAgIC8vIGVycm9yc1xcbiAgICAgICAgICAgICAgICB2YWx1ZSBpbnN0YW5jZW9mIEVycm9yIHx8XFxuICAgICAgICAgICAgICAgIC8vIHdlYWttYXBzXFxuICAgICAgICAgICAgICAgIChyZWFsbS5XZWFrTWFwICYmIHZhbHVlIGluc3RhbmNlb2YgcmVhbG0uV2Vha01hcCkgfHxcXG4gICAgICAgICAgICAgICAgLy8gd2Vha3NldHNcXG4gICAgICAgICAgICAgICAgKHJlYWxtLldlYWtTZXQgJiYgdmFsdWUgaW5zdGFuY2VvZiByZWFsbS5XZWFrU2V0KSkge1xcbiAgICAgICAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIC8vIGFzc3VtZSBhbnl0aGluZyBsZWZ0IGlzIGEgY3VzdG9tIGNvbnN0cnVjdG9yXFxuICAgICAgICAgICAgcmV0dXJuIGdldE9iamVjdENsb25lKHZhbHVlLCByZWFsbSwgaGFuZGxlQ29weSwgY2FjaGUpO1xcbiAgICAgICAgfTtcXG4gICAgICAgIHJldHVybiBoYW5kbGVDb3B5KHZhbHVlLCBjcmVhdGVDYWNoZSgpKTtcXG4gICAgfVxcbiAgICAvLyBBZGRpbmcgcmVmZXJlbmNlIHRvIGFsbG93IHVzYWdlIGluIENvbW1vbkpTIGxpYnJhcmllcyBjb21waWxlZCB1c2luZyBUU0MsIHdoaWNoXFxuICAgIC8vIGV4cGVjdHMgdGhlcmUgdG8gYmUgYSBkZWZhdWx0IHByb3BlcnR5IG9uIHRoZSBleHBvcnRlZCB2YWx1ZS4gU2VlXFxuICAgIC8vIFsjMzddKGh0dHBzOi8vZ2l0aHViLmNvbS9wbGFudHRoZWlkZWEvZmFzdC1jb3B5L2lzc3Vlcy8zNykgZm9yIGRldGFpbHMuXFxuICAgIGNvcHkuZGVmYXVsdCA9IGNvcHk7XFxuICAgIC8qKlxcbiAgICAgKiBAZnVuY3Rpb24gc3RyaWN0Q29weVxcbiAgICAgKlxcbiAgICAgKiBAZGVzY3JpcHRpb25cXG4gICAgICogY29weSB0aGUgdmFsdWUgd2l0aCBgc3RyaWN0YCBvcHRpb24gcHJlLWFwcGxpZWRcXG4gICAgICpcXG4gICAgICogQHBhcmFtIHZhbHVlIHRoZSB2YWx1ZSB0byBjb3B5XFxuICAgICAqIEBwYXJhbSBbb3B0aW9uc10gdGhlIG9wdGlvbnMgZm9yIGNvcHlpbmcgd2l0aFxcbiAgICAgKiBAcGFyYW0gW29wdGlvbnMucmVhbG1dIHRoZSByZWFsbSAodGhpcykgdmFsdWUgdGhlIHZhbHVlIGlzIGNvcGllZCBmcm9tXFxuICAgICAqIEByZXR1cm5zIHRoZSBjb3BpZWQgdmFsdWVcXG4gICAgICovXFxuICAgIGNvcHkuc3RyaWN0ID0gZnVuY3Rpb24gc3RyaWN0Q29weSh2YWx1ZSwgb3B0aW9ucykge1xcbiAgICAgICAgcmV0dXJuIGNvcHkodmFsdWUsIHtcXG4gICAgICAgICAgICBpc1N0cmljdDogdHJ1ZSxcXG4gICAgICAgICAgICByZWFsbTogb3B0aW9ucyA/IG9wdGlvbnMucmVhbG0gOiB2b2lkIDAsXFxuICAgICAgICB9KTtcXG4gICAgfTtcXG5cXG4gICAgcmV0dXJuIGNvcHk7XFxuXFxufSkpO1xcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWZhc3QtY29weS5qcy5tYXBcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9mYXN0LWNvcHkvZGlzdC9mYXN0LWNvcHkuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbXBsZW1lbnRhdGlvbi5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbi8qIGVzbGludCBuby1pbnZhbGlkLXRoaXM6IDEgKi9cXG5cXG52YXIgRVJST1JfTUVTU0FHRSA9ICdGdW5jdGlvbi5wcm90b3R5cGUuYmluZCBjYWxsZWQgb24gaW5jb21wYXRpYmxlICc7XFxudmFyIHNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xcbnZhciB0b1N0ciA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XFxudmFyIGZ1bmNUeXBlID0gJ1tvYmplY3QgRnVuY3Rpb25dJztcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGJpbmQodGhhdCkge1xcbiAgICB2YXIgdGFyZ2V0ID0gdGhpcztcXG4gICAgaWYgKHR5cGVvZiB0YXJnZXQgIT09ICdmdW5jdGlvbicgfHwgdG9TdHIuY2FsbCh0YXJnZXQpICE9PSBmdW5jVHlwZSkge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihFUlJPUl9NRVNTQUdFICsgdGFyZ2V0KTtcXG4gICAgfVxcbiAgICB2YXIgYXJncyA9IHNsaWNlLmNhbGwoYXJndW1lbnRzLCAxKTtcXG5cXG4gICAgdmFyIGJvdW5kO1xcbiAgICB2YXIgYmluZGVyID0gZnVuY3Rpb24gKCkge1xcbiAgICAgICAgaWYgKHRoaXMgaW5zdGFuY2VvZiBib3VuZCkge1xcbiAgICAgICAgICAgIHZhciByZXN1bHQgPSB0YXJnZXQuYXBwbHkoXFxuICAgICAgICAgICAgICAgIHRoaXMsXFxuICAgICAgICAgICAgICAgIGFyZ3MuY29uY2F0KHNsaWNlLmNhbGwoYXJndW1lbnRzKSlcXG4gICAgICAgICAgICApO1xcbiAgICAgICAgICAgIGlmIChPYmplY3QocmVzdWx0KSA9PT0gcmVzdWx0KSB7XFxuICAgICAgICAgICAgICAgIHJldHVybiByZXN1bHQ7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIHJldHVybiB0aGlzO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gdGFyZ2V0LmFwcGx5KFxcbiAgICAgICAgICAgICAgICB0aGF0LFxcbiAgICAgICAgICAgICAgICBhcmdzLmNvbmNhdChzbGljZS5jYWxsKGFyZ3VtZW50cykpXFxuICAgICAgICAgICAgKTtcXG4gICAgICAgIH1cXG4gICAgfTtcXG5cXG4gICAgdmFyIGJvdW5kTGVuZ3RoID0gTWF0aC5tYXgoMCwgdGFyZ2V0Lmxlbmd0aCAtIGFyZ3MubGVuZ3RoKTtcXG4gICAgdmFyIGJvdW5kQXJncyA9IFtdO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGJvdW5kTGVuZ3RoOyBpKyspIHtcXG4gICAgICAgIGJvdW5kQXJncy5wdXNoKCckJyArIGkpO1xcbiAgICB9XFxuXFxuICAgIGJvdW5kID0gRnVuY3Rpb24oJ2JpbmRlcicsICdyZXR1cm4gZnVuY3Rpb24gKCcgKyBib3VuZEFyZ3Muam9pbignLCcpICsgJyl7IHJldHVybiBiaW5kZXIuYXBwbHkodGhpcyxhcmd1bWVudHMpOyB9JykoYmluZGVyKTtcXG5cXG4gICAgaWYgKHRhcmdldC5wcm90b3R5cGUpIHtcXG4gICAgICAgIHZhciBFbXB0eSA9IGZ1bmN0aW9uIEVtcHR5KCkge307XFxuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSB0YXJnZXQucHJvdG90eXBlO1xcbiAgICAgICAgYm91bmQucHJvdG90eXBlID0gbmV3IEVtcHR5KCk7XFxuICAgICAgICBFbXB0eS5wcm90b3R5cGUgPSBudWxsO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBib3VuZDtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGltcGxlbWVudGF0aW9uID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9pbXBsZW1lbnRhdGlvbiAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW1wbGVtZW50YXRpb24uanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IEZ1bmN0aW9uLnByb3RvdHlwZS5iaW5kIHx8IGltcGxlbWVudGF0aW9uO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIHVuZGVmaW5lZDtcXG5cXG52YXIgJFN5bnRheEVycm9yID0gU3ludGF4RXJyb3I7XFxudmFyICRGdW5jdGlvbiA9IEZ1bmN0aW9uO1xcbnZhciAkVHlwZUVycm9yID0gVHlwZUVycm9yO1xcblxcbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBjb25zaXN0ZW50LXJldHVyblxcbnZhciBnZXRFdmFsbGVkQ29uc3RydWN0b3IgPSBmdW5jdGlvbiAoZXhwcmVzc2lvblN5bnRheCkge1xcblxcdHRyeSB7XFxuXFx0XFx0cmV0dXJuICRGdW5jdGlvbignXFxcInVzZSBzdHJpY3RcXFwiOyByZXR1cm4gKCcgKyBleHByZXNzaW9uU3ludGF4ICsgJykuY29uc3RydWN0b3I7JykoKTtcXG5cXHR9IGNhdGNoIChlKSB7fVxcbn07XFxuXFxudmFyICRnT1BEID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcjtcXG5pZiAoJGdPUEQpIHtcXG5cXHR0cnkge1xcblxcdFxcdCRnT1BEKHt9LCAnJyk7XFxuXFx0fSBjYXRjaCAoZSkge1xcblxcdFxcdCRnT1BEID0gbnVsbDsgLy8gdGhpcyBpcyBJRSA4LCB3aGljaCBoYXMgYSBicm9rZW4gZ09QRFxcblxcdH1cXG59XFxuXFxudmFyIHRocm93VHlwZUVycm9yID0gZnVuY3Rpb24gKCkge1xcblxcdHRocm93IG5ldyAkVHlwZUVycm9yKCk7XFxufTtcXG52YXIgVGhyb3dUeXBlRXJyb3IgPSAkZ09QRFxcblxcdD8gKGZ1bmN0aW9uICgpIHtcXG5cXHRcXHR0cnkge1xcblxcdFxcdFxcdC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bnVzZWQtZXhwcmVzc2lvbnMsIG5vLWNhbGxlciwgbm8tcmVzdHJpY3RlZC1wcm9wZXJ0aWVzXFxuXFx0XFx0XFx0YXJndW1lbnRzLmNhbGxlZTsgLy8gSUUgOCBkb2VzIG5vdCB0aHJvdyBoZXJlXFxuXFx0XFx0XFx0cmV0dXJuIHRocm93VHlwZUVycm9yO1xcblxcdFxcdH0gY2F0Y2ggKGNhbGxlZVRocm93cykge1xcblxcdFxcdFxcdHRyeSB7XFxuXFx0XFx0XFx0XFx0Ly8gSUUgOCB0aHJvd3Mgb24gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihhcmd1bWVudHMsICcnKVxcblxcdFxcdFxcdFxcdHJldHVybiAkZ09QRChhcmd1bWVudHMsICdjYWxsZWUnKS5nZXQ7XFxuXFx0XFx0XFx0fSBjYXRjaCAoZ09QRHRocm93cykge1xcblxcdFxcdFxcdFxcdHJldHVybiB0aHJvd1R5cGVFcnJvcjtcXG5cXHRcXHRcXHR9XFxuXFx0XFx0fVxcblxcdH0oKSlcXG5cXHQ6IHRocm93VHlwZUVycm9yO1xcblxcbnZhciBoYXNTeW1ib2xzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaGFzLXN5bWJvbHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qc1xcXCIpKCk7XFxuXFxudmFyIGdldFByb3RvID0gT2JqZWN0LmdldFByb3RvdHlwZU9mIHx8IGZ1bmN0aW9uICh4KSB7IHJldHVybiB4Ll9fcHJvdG9fXzsgfTsgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1wcm90b1xcblxcbnZhciBuZWVkc0V2YWwgPSB7fTtcXG5cXG52YXIgVHlwZWRBcnJheSA9IHR5cGVvZiBVaW50OEFycmF5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IGdldFByb3RvKFVpbnQ4QXJyYXkpO1xcblxcbnZhciBJTlRSSU5TSUNTID0ge1xcblxcdCclQWdncmVnYXRlRXJyb3IlJzogdHlwZW9mIEFnZ3JlZ2F0ZUVycm9yID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEFnZ3JlZ2F0ZUVycm9yLFxcblxcdCclQXJyYXklJzogQXJyYXksXFxuXFx0JyVBcnJheUJ1ZmZlciUnOiB0eXBlb2YgQXJyYXlCdWZmZXIgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXJyYXlCdWZmZXIsXFxuXFx0JyVBcnJheUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpIDogdW5kZWZpbmVkLFxcblxcdCclQXN5bmNGcm9tU3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IHVuZGVmaW5lZCxcXG5cXHQnJUFzeW5jRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxcblxcdCclQXN5bmNHZW5lcmF0b3IlJzogbmVlZHNFdmFsLFxcblxcdCclQXN5bmNHZW5lcmF0b3JGdW5jdGlvbiUnOiBuZWVkc0V2YWwsXFxuXFx0JyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJSc6IG5lZWRzRXZhbCxcXG5cXHQnJUF0b21pY3MlJzogdHlwZW9mIEF0b21pY3MgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogQXRvbWljcyxcXG5cXHQnJUJpZ0ludCUnOiB0eXBlb2YgQmlnSW50ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEJpZ0ludCxcXG5cXHQnJUJvb2xlYW4lJzogQm9vbGVhbixcXG5cXHQnJURhdGFWaWV3JSc6IHR5cGVvZiBEYXRhVmlldyA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBEYXRhVmlldyxcXG5cXHQnJURhdGUlJzogRGF0ZSxcXG5cXHQnJWRlY29kZVVSSSUnOiBkZWNvZGVVUkksXFxuXFx0JyVkZWNvZGVVUklDb21wb25lbnQlJzogZGVjb2RlVVJJQ29tcG9uZW50LFxcblxcdCclZW5jb2RlVVJJJSc6IGVuY29kZVVSSSxcXG5cXHQnJWVuY29kZVVSSUNvbXBvbmVudCUnOiBlbmNvZGVVUklDb21wb25lbnQsXFxuXFx0JyVFcnJvciUnOiBFcnJvcixcXG5cXHQnJWV2YWwlJzogZXZhbCwgLy8gZXNsaW50LWRpc2FibGUtbGluZSBuby1ldmFsXFxuXFx0JyVFdmFsRXJyb3IlJzogRXZhbEVycm9yLFxcblxcdCclRmxvYXQzMkFycmF5JSc6IHR5cGVvZiBGbG9hdDMyQXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQzMkFycmF5LFxcblxcdCclRmxvYXQ2NEFycmF5JSc6IHR5cGVvZiBGbG9hdDY0QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogRmxvYXQ2NEFycmF5LFxcblxcdCclRmluYWxpemF0aW9uUmVnaXN0cnklJzogdHlwZW9mIEZpbmFsaXphdGlvblJlZ2lzdHJ5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IEZpbmFsaXphdGlvblJlZ2lzdHJ5LFxcblxcdCclRnVuY3Rpb24lJzogJEZ1bmN0aW9uLFxcblxcdCclR2VuZXJhdG9yRnVuY3Rpb24lJzogbmVlZHNFdmFsLFxcblxcdCclSW50OEFycmF5JSc6IHR5cGVvZiBJbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogSW50OEFycmF5LFxcblxcdCclSW50MTZBcnJheSUnOiB0eXBlb2YgSW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQxNkFycmF5LFxcblxcdCclSW50MzJBcnJheSUnOiB0eXBlb2YgSW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBJbnQzMkFycmF5LFxcblxcdCclaXNGaW5pdGUlJzogaXNGaW5pdGUsXFxuXFx0JyVpc05hTiUnOiBpc05hTixcXG5cXHQnJUl0ZXJhdG9yUHJvdG90eXBlJSc6IGhhc1N5bWJvbHMgPyBnZXRQcm90byhnZXRQcm90byhbXVtTeW1ib2wuaXRlcmF0b3JdKCkpKSA6IHVuZGVmaW5lZCxcXG5cXHQnJUpTT04lJzogdHlwZW9mIEpTT04gPT09ICdvYmplY3QnID8gSlNPTiA6IHVuZGVmaW5lZCxcXG5cXHQnJU1hcCUnOiB0eXBlb2YgTWFwID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IE1hcCxcXG5cXHQnJU1hcEl0ZXJhdG9yUHJvdG90eXBlJSc6IHR5cGVvZiBNYXAgPT09ICd1bmRlZmluZWQnIHx8ICFoYXNTeW1ib2xzID8gdW5kZWZpbmVkIDogZ2V0UHJvdG8obmV3IE1hcCgpW1N5bWJvbC5pdGVyYXRvcl0oKSksXFxuXFx0JyVNYXRoJSc6IE1hdGgsXFxuXFx0JyVOdW1iZXIlJzogTnVtYmVyLFxcblxcdCclT2JqZWN0JSc6IE9iamVjdCxcXG5cXHQnJXBhcnNlRmxvYXQlJzogcGFyc2VGbG9hdCxcXG5cXHQnJXBhcnNlSW50JSc6IHBhcnNlSW50LFxcblxcdCclUHJvbWlzZSUnOiB0eXBlb2YgUHJvbWlzZSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBQcm9taXNlLFxcblxcdCclUHJveHklJzogdHlwZW9mIFByb3h5ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFByb3h5LFxcblxcdCclUmFuZ2VFcnJvciUnOiBSYW5nZUVycm9yLFxcblxcdCclUmVmZXJlbmNlRXJyb3IlJzogUmVmZXJlbmNlRXJyb3IsXFxuXFx0JyVSZWZsZWN0JSc6IHR5cGVvZiBSZWZsZWN0ID09PSAndW5kZWZpbmVkJyA/IHVuZGVmaW5lZCA6IFJlZmxlY3QsXFxuXFx0JyVSZWdFeHAlJzogUmVnRXhwLFxcblxcdCclU2V0JSc6IHR5cGVvZiBTZXQgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogU2V0LFxcblxcdCclU2V0SXRlcmF0b3JQcm90b3R5cGUlJzogdHlwZW9mIFNldCA9PT0gJ3VuZGVmaW5lZCcgfHwgIWhhc1N5bWJvbHMgPyB1bmRlZmluZWQgOiBnZXRQcm90byhuZXcgU2V0KClbU3ltYm9sLml0ZXJhdG9yXSgpKSxcXG5cXHQnJVNoYXJlZEFycmF5QnVmZmVyJSc6IHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBTaGFyZWRBcnJheUJ1ZmZlcixcXG5cXHQnJVN0cmluZyUnOiBTdHJpbmcsXFxuXFx0JyVTdHJpbmdJdGVyYXRvclByb3RvdHlwZSUnOiBoYXNTeW1ib2xzID8gZ2V0UHJvdG8oJydbU3ltYm9sLml0ZXJhdG9yXSgpKSA6IHVuZGVmaW5lZCxcXG5cXHQnJVN5bWJvbCUnOiBoYXNTeW1ib2xzID8gU3ltYm9sIDogdW5kZWZpbmVkLFxcblxcdCclU3ludGF4RXJyb3IlJzogJFN5bnRheEVycm9yLFxcblxcdCclVGhyb3dUeXBlRXJyb3IlJzogVGhyb3dUeXBlRXJyb3IsXFxuXFx0JyVUeXBlZEFycmF5JSc6IFR5cGVkQXJyYXksXFxuXFx0JyVUeXBlRXJyb3IlJzogJFR5cGVFcnJvcixcXG5cXHQnJVVpbnQ4QXJyYXklJzogdHlwZW9mIFVpbnQ4QXJyYXkgPT09ICd1bmRlZmluZWQnID8gdW5kZWZpbmVkIDogVWludDhBcnJheSxcXG5cXHQnJVVpbnQ4Q2xhbXBlZEFycmF5JSc6IHR5cGVvZiBVaW50OENsYW1wZWRBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50OENsYW1wZWRBcnJheSxcXG5cXHQnJVVpbnQxNkFycmF5JSc6IHR5cGVvZiBVaW50MTZBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MTZBcnJheSxcXG5cXHQnJVVpbnQzMkFycmF5JSc6IHR5cGVvZiBVaW50MzJBcnJheSA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBVaW50MzJBcnJheSxcXG5cXHQnJVVSSUVycm9yJSc6IFVSSUVycm9yLFxcblxcdCclV2Vha01hcCUnOiB0eXBlb2YgV2Vha01hcCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrTWFwLFxcblxcdCclV2Vha1JlZiUnOiB0eXBlb2YgV2Vha1JlZiA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrUmVmLFxcblxcdCclV2Vha1NldCUnOiB0eXBlb2YgV2Vha1NldCA9PT0gJ3VuZGVmaW5lZCcgPyB1bmRlZmluZWQgOiBXZWFrU2V0XFxufTtcXG5cXG52YXIgZG9FdmFsID0gZnVuY3Rpb24gZG9FdmFsKG5hbWUpIHtcXG5cXHR2YXIgdmFsdWU7XFxuXFx0aWYgKG5hbWUgPT09ICclQXN5bmNGdW5jdGlvbiUnKSB7XFxuXFx0XFx0dmFsdWUgPSBnZXRFdmFsbGVkQ29uc3RydWN0b3IoJ2FzeW5jIGZ1bmN0aW9uICgpIHt9Jyk7XFxuXFx0fSBlbHNlIGlmIChuYW1lID09PSAnJUdlbmVyYXRvckZ1bmN0aW9uJScpIHtcXG5cXHRcXHR2YWx1ZSA9IGdldEV2YWxsZWRDb25zdHJ1Y3RvcignZnVuY3Rpb24qICgpIHt9Jyk7XFxuXFx0fSBlbHNlIGlmIChuYW1lID09PSAnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJykge1xcblxcdFxcdHZhbHVlID0gZ2V0RXZhbGxlZENvbnN0cnVjdG9yKCdhc3luYyBmdW5jdGlvbiogKCkge30nKTtcXG5cXHR9IGVsc2UgaWYgKG5hbWUgPT09ICclQXN5bmNHZW5lcmF0b3IlJykge1xcblxcdFxcdHZhciBmbiA9IGRvRXZhbCgnJUFzeW5jR2VuZXJhdG9yRnVuY3Rpb24lJyk7XFxuXFx0XFx0aWYgKGZuKSB7XFxuXFx0XFx0XFx0dmFsdWUgPSBmbi5wcm90b3R5cGU7XFxuXFx0XFx0fVxcblxcdH0gZWxzZSBpZiAobmFtZSA9PT0gJyVBc3luY0l0ZXJhdG9yUHJvdG90eXBlJScpIHtcXG5cXHRcXHR2YXIgZ2VuID0gZG9FdmFsKCclQXN5bmNHZW5lcmF0b3IlJyk7XFxuXFx0XFx0aWYgKGdlbikge1xcblxcdFxcdFxcdHZhbHVlID0gZ2V0UHJvdG8oZ2VuLnByb3RvdHlwZSk7XFxuXFx0XFx0fVxcblxcdH1cXG5cXG5cXHRJTlRSSU5TSUNTW25hbWVdID0gdmFsdWU7XFxuXFxuXFx0cmV0dXJuIHZhbHVlO1xcbn07XFxuXFxudmFyIExFR0FDWV9BTElBU0VTID0ge1xcblxcdCclQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJUFycmF5UHJvdG90eXBlJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJ10sXFxuXFx0JyVBcnJheVByb3RvX2VudHJpZXMlJzogWydBcnJheScsICdwcm90b3R5cGUnLCAnZW50cmllcyddLFxcblxcdCclQXJyYXlQcm90b19mb3JFYWNoJSc6IFsnQXJyYXknLCAncHJvdG90eXBlJywgJ2ZvckVhY2gnXSxcXG5cXHQnJUFycmF5UHJvdG9fa2V5cyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICdrZXlzJ10sXFxuXFx0JyVBcnJheVByb3RvX3ZhbHVlcyUnOiBbJ0FycmF5JywgJ3Byb3RvdHlwZScsICd2YWx1ZXMnXSxcXG5cXHQnJUFzeW5jRnVuY3Rpb25Qcm90b3R5cGUlJzogWydBc3luY0Z1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxcblxcdCclQXN5bmNHZW5lcmF0b3IlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZSddLFxcblxcdCclQXN5bmNHZW5lcmF0b3JQcm90b3R5cGUlJzogWydBc3luY0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcXG5cXHQnJUJvb2xlYW5Qcm90b3R5cGUlJzogWydCb29sZWFuJywgJ3Byb3RvdHlwZSddLFxcblxcdCclRGF0YVZpZXdQcm90b3R5cGUlJzogWydEYXRhVmlldycsICdwcm90b3R5cGUnXSxcXG5cXHQnJURhdGVQcm90b3R5cGUlJzogWydEYXRlJywgJ3Byb3RvdHlwZSddLFxcblxcdCclRXJyb3JQcm90b3R5cGUlJzogWydFcnJvcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJUV2YWxFcnJvclByb3RvdHlwZSUnOiBbJ0V2YWxFcnJvcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJUZsb2F0MzJBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0MzJBcnJheScsICdwcm90b3R5cGUnXSxcXG5cXHQnJUZsb2F0NjRBcnJheVByb3RvdHlwZSUnOiBbJ0Zsb2F0NjRBcnJheScsICdwcm90b3R5cGUnXSxcXG5cXHQnJUZ1bmN0aW9uUHJvdG90eXBlJSc6IFsnRnVuY3Rpb24nLCAncHJvdG90eXBlJ10sXFxuXFx0JyVHZW5lcmF0b3IlJzogWydHZW5lcmF0b3JGdW5jdGlvbicsICdwcm90b3R5cGUnXSxcXG5cXHQnJUdlbmVyYXRvclByb3RvdHlwZSUnOiBbJ0dlbmVyYXRvckZ1bmN0aW9uJywgJ3Byb3RvdHlwZScsICdwcm90b3R5cGUnXSxcXG5cXHQnJUludDhBcnJheVByb3RvdHlwZSUnOiBbJ0ludDhBcnJheScsICdwcm90b3R5cGUnXSxcXG5cXHQnJUludDE2QXJyYXlQcm90b3R5cGUlJzogWydJbnQxNkFycmF5JywgJ3Byb3RvdHlwZSddLFxcblxcdCclSW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ0ludDMyQXJyYXknLCAncHJvdG90eXBlJ10sXFxuXFx0JyVKU09OUGFyc2UlJzogWydKU09OJywgJ3BhcnNlJ10sXFxuXFx0JyVKU09OU3RyaW5naWZ5JSc6IFsnSlNPTicsICdzdHJpbmdpZnknXSxcXG5cXHQnJU1hcFByb3RvdHlwZSUnOiBbJ01hcCcsICdwcm90b3R5cGUnXSxcXG5cXHQnJU51bWJlclByb3RvdHlwZSUnOiBbJ051bWJlcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJU9iamVjdFByb3RvdHlwZSUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnXSxcXG5cXHQnJU9ialByb3RvX3RvU3RyaW5nJSc6IFsnT2JqZWN0JywgJ3Byb3RvdHlwZScsICd0b1N0cmluZyddLFxcblxcdCclT2JqUHJvdG9fdmFsdWVPZiUnOiBbJ09iamVjdCcsICdwcm90b3R5cGUnLCAndmFsdWVPZiddLFxcblxcdCclUHJvbWlzZVByb3RvdHlwZSUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJ10sXFxuXFx0JyVQcm9taXNlUHJvdG9fdGhlbiUnOiBbJ1Byb21pc2UnLCAncHJvdG90eXBlJywgJ3RoZW4nXSxcXG5cXHQnJVByb21pc2VfYWxsJSc6IFsnUHJvbWlzZScsICdhbGwnXSxcXG5cXHQnJVByb21pc2VfcmVqZWN0JSc6IFsnUHJvbWlzZScsICdyZWplY3QnXSxcXG5cXHQnJVByb21pc2VfcmVzb2x2ZSUnOiBbJ1Byb21pc2UnLCAncmVzb2x2ZSddLFxcblxcdCclUmFuZ2VFcnJvclByb3RvdHlwZSUnOiBbJ1JhbmdlRXJyb3InLCAncHJvdG90eXBlJ10sXFxuXFx0JyVSZWZlcmVuY2VFcnJvclByb3RvdHlwZSUnOiBbJ1JlZmVyZW5jZUVycm9yJywgJ3Byb3RvdHlwZSddLFxcblxcdCclUmVnRXhwUHJvdG90eXBlJSc6IFsnUmVnRXhwJywgJ3Byb3RvdHlwZSddLFxcblxcdCclU2V0UHJvdG90eXBlJSc6IFsnU2V0JywgJ3Byb3RvdHlwZSddLFxcblxcdCclU2hhcmVkQXJyYXlCdWZmZXJQcm90b3R5cGUlJzogWydTaGFyZWRBcnJheUJ1ZmZlcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJVN0cmluZ1Byb3RvdHlwZSUnOiBbJ1N0cmluZycsICdwcm90b3R5cGUnXSxcXG5cXHQnJVN5bWJvbFByb3RvdHlwZSUnOiBbJ1N5bWJvbCcsICdwcm90b3R5cGUnXSxcXG5cXHQnJVN5bnRheEVycm9yUHJvdG90eXBlJSc6IFsnU3ludGF4RXJyb3InLCAncHJvdG90eXBlJ10sXFxuXFx0JyVUeXBlZEFycmF5UHJvdG90eXBlJSc6IFsnVHlwZWRBcnJheScsICdwcm90b3R5cGUnXSxcXG5cXHQnJVR5cGVFcnJvclByb3RvdHlwZSUnOiBbJ1R5cGVFcnJvcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJVVpbnQ4QXJyYXlQcm90b3R5cGUlJzogWydVaW50OEFycmF5JywgJ3Byb3RvdHlwZSddLFxcblxcdCclVWludDhDbGFtcGVkQXJyYXlQcm90b3R5cGUlJzogWydVaW50OENsYW1wZWRBcnJheScsICdwcm90b3R5cGUnXSxcXG5cXHQnJVVpbnQxNkFycmF5UHJvdG90eXBlJSc6IFsnVWludDE2QXJyYXknLCAncHJvdG90eXBlJ10sXFxuXFx0JyVVaW50MzJBcnJheVByb3RvdHlwZSUnOiBbJ1VpbnQzMkFycmF5JywgJ3Byb3RvdHlwZSddLFxcblxcdCclVVJJRXJyb3JQcm90b3R5cGUlJzogWydVUklFcnJvcicsICdwcm90b3R5cGUnXSxcXG5cXHQnJVdlYWtNYXBQcm90b3R5cGUlJzogWydXZWFrTWFwJywgJ3Byb3RvdHlwZSddLFxcblxcdCclV2Vha1NldFByb3RvdHlwZSUnOiBbJ1dlYWtTZXQnLCAncHJvdG90eXBlJ11cXG59O1xcblxcbnZhciBiaW5kID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgZnVuY3Rpb24tYmluZCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2Z1bmN0aW9uLWJpbmQvaW5kZXguanNcXFwiKTtcXG52YXIgaGFzT3duID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgaGFzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qc1xcXCIpO1xcbnZhciAkY29uY2F0ID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIEFycmF5LnByb3RvdHlwZS5jb25jYXQpO1xcbnZhciAkc3BsaWNlQXBwbHkgPSBiaW5kLmNhbGwoRnVuY3Rpb24uYXBwbHksIEFycmF5LnByb3RvdHlwZS5zcGxpY2UpO1xcbnZhciAkcmVwbGFjZSA9IGJpbmQuY2FsbChGdW5jdGlvbi5jYWxsLCBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2UpO1xcbnZhciAkc3RyU2xpY2UgPSBiaW5kLmNhbGwoRnVuY3Rpb24uY2FsbCwgU3RyaW5nLnByb3RvdHlwZS5zbGljZSk7XFxudmFyICRleGVjID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIFJlZ0V4cC5wcm90b3R5cGUuZXhlYyk7XFxuXFxuLyogYWRhcHRlZCBmcm9tIGh0dHBzOi8vZ2l0aHViLmNvbS9sb2Rhc2gvbG9kYXNoL2Jsb2IvNC4xNy4xNS9kaXN0L2xvZGFzaC5qcyNMNjczNS1MNjc0NCAqL1xcbnZhciByZVByb3BOYW1lID0gL1teJS5bXFxcXF1dK3xcXFxcWyg/OigtP1xcXFxkKyg/OlxcXFwuXFxcXGQrKT8pfChbXFxcIiddKSgoPzooPyFcXFxcMilbXlxcXFxcXFxcXXxcXFxcXFxcXC4pKj8pXFxcXDIpXFxcXF18KD89KD86XFxcXC58XFxcXFtcXFxcXSkoPzpcXFxcLnxcXFxcW1xcXFxdfCUkKSkvZztcXG52YXIgcmVFc2NhcGVDaGFyID0gL1xcXFxcXFxcKFxcXFxcXFxcKT8vZzsgLyoqIFVzZWQgdG8gbWF0Y2ggYmFja3NsYXNoZXMgaW4gcHJvcGVydHkgcGF0aHMuICovXFxudmFyIHN0cmluZ1RvUGF0aCA9IGZ1bmN0aW9uIHN0cmluZ1RvUGF0aChzdHJpbmcpIHtcXG5cXHR2YXIgZmlyc3QgPSAkc3RyU2xpY2Uoc3RyaW5nLCAwLCAxKTtcXG5cXHR2YXIgbGFzdCA9ICRzdHJTbGljZShzdHJpbmcsIC0xKTtcXG5cXHRpZiAoZmlyc3QgPT09ICclJyAmJiBsYXN0ICE9PSAnJScpIHtcXG5cXHRcXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdpbnZhbGlkIGludHJpbnNpYyBzeW50YXgsIGV4cGVjdGVkIGNsb3NpbmcgYCVgJyk7XFxuXFx0fSBlbHNlIGlmIChsYXN0ID09PSAnJScgJiYgZmlyc3QgIT09ICclJykge1xcblxcdFxcdHRocm93IG5ldyAkU3ludGF4RXJyb3IoJ2ludmFsaWQgaW50cmluc2ljIHN5bnRheCwgZXhwZWN0ZWQgb3BlbmluZyBgJWAnKTtcXG5cXHR9XFxuXFx0dmFyIHJlc3VsdCA9IFtdO1xcblxcdCRyZXBsYWNlKHN0cmluZywgcmVQcm9wTmFtZSwgZnVuY3Rpb24gKG1hdGNoLCBudW1iZXIsIHF1b3RlLCBzdWJTdHJpbmcpIHtcXG5cXHRcXHRyZXN1bHRbcmVzdWx0Lmxlbmd0aF0gPSBxdW90ZSA/ICRyZXBsYWNlKHN1YlN0cmluZywgcmVFc2NhcGVDaGFyLCAnJDEnKSA6IG51bWJlciB8fCBtYXRjaDtcXG5cXHR9KTtcXG5cXHRyZXR1cm4gcmVzdWx0O1xcbn07XFxuLyogZW5kIGFkYXB0YXRpb24gKi9cXG5cXG52YXIgZ2V0QmFzZUludHJpbnNpYyA9IGZ1bmN0aW9uIGdldEJhc2VJbnRyaW5zaWMobmFtZSwgYWxsb3dNaXNzaW5nKSB7XFxuXFx0dmFyIGludHJpbnNpY05hbWUgPSBuYW1lO1xcblxcdHZhciBhbGlhcztcXG5cXHRpZiAoaGFzT3duKExFR0FDWV9BTElBU0VTLCBpbnRyaW5zaWNOYW1lKSkge1xcblxcdFxcdGFsaWFzID0gTEVHQUNZX0FMSUFTRVNbaW50cmluc2ljTmFtZV07XFxuXFx0XFx0aW50cmluc2ljTmFtZSA9ICclJyArIGFsaWFzWzBdICsgJyUnO1xcblxcdH1cXG5cXG5cXHRpZiAoaGFzT3duKElOVFJJTlNJQ1MsIGludHJpbnNpY05hbWUpKSB7XFxuXFx0XFx0dmFyIHZhbHVlID0gSU5UUklOU0lDU1tpbnRyaW5zaWNOYW1lXTtcXG5cXHRcXHRpZiAodmFsdWUgPT09IG5lZWRzRXZhbCkge1xcblxcdFxcdFxcdHZhbHVlID0gZG9FdmFsKGludHJpbnNpY05hbWUpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAodHlwZW9mIHZhbHVlID09PSAndW5kZWZpbmVkJyAmJiAhYWxsb3dNaXNzaW5nKSB7XFxuXFx0XFx0XFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ2ludHJpbnNpYyAnICsgbmFtZSArICcgZXhpc3RzLCBidXQgaXMgbm90IGF2YWlsYWJsZS4gUGxlYXNlIGZpbGUgYW4gaXNzdWUhJyk7XFxuXFx0XFx0fVxcblxcblxcdFxcdHJldHVybiB7XFxuXFx0XFx0XFx0YWxpYXM6IGFsaWFzLFxcblxcdFxcdFxcdG5hbWU6IGludHJpbnNpY05hbWUsXFxuXFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0fTtcXG5cXHR9XFxuXFxuXFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcignaW50cmluc2ljICcgKyBuYW1lICsgJyBkb2VzIG5vdCBleGlzdCEnKTtcXG59O1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gR2V0SW50cmluc2ljKG5hbWUsIGFsbG93TWlzc2luZykge1xcblxcdGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycgfHwgbmFtZS5sZW5ndGggPT09IDApIHtcXG5cXHRcXHR0aHJvdyBuZXcgJFR5cGVFcnJvcignaW50cmluc2ljIG5hbWUgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcXG5cXHR9XFxuXFx0aWYgKGFyZ3VtZW50cy5sZW5ndGggPiAxICYmIHR5cGVvZiBhbGxvd01pc3NpbmcgIT09ICdib29sZWFuJykge1xcblxcdFxcdHRocm93IG5ldyAkVHlwZUVycm9yKCdcXFwiYWxsb3dNaXNzaW5nXFxcIiBhcmd1bWVudCBtdXN0IGJlIGEgYm9vbGVhbicpO1xcblxcdH1cXG5cXG5cXHRpZiAoJGV4ZWMoL14lP1teJV0qJT8kLywgbmFtZSkgPT09IG51bGwpIHtcXG5cXHRcXHR0aHJvdyBuZXcgJFN5bnRheEVycm9yKCdgJWAgbWF5IG5vdCBiZSBwcmVzZW50IGFueXdoZXJlIGJ1dCBhdCB0aGUgYmVnaW5uaW5nIGFuZCBlbmQgb2YgdGhlIGludHJpbnNpYyBuYW1lJyk7XFxuXFx0fVxcblxcdHZhciBwYXJ0cyA9IHN0cmluZ1RvUGF0aChuYW1lKTtcXG5cXHR2YXIgaW50cmluc2ljQmFzZU5hbWUgPSBwYXJ0cy5sZW5ndGggPiAwID8gcGFydHNbMF0gOiAnJztcXG5cXG5cXHR2YXIgaW50cmluc2ljID0gZ2V0QmFzZUludHJpbnNpYygnJScgKyBpbnRyaW5zaWNCYXNlTmFtZSArICclJywgYWxsb3dNaXNzaW5nKTtcXG5cXHR2YXIgaW50cmluc2ljUmVhbE5hbWUgPSBpbnRyaW5zaWMubmFtZTtcXG5cXHR2YXIgdmFsdWUgPSBpbnRyaW5zaWMudmFsdWU7XFxuXFx0dmFyIHNraXBGdXJ0aGVyQ2FjaGluZyA9IGZhbHNlO1xcblxcblxcdHZhciBhbGlhcyA9IGludHJpbnNpYy5hbGlhcztcXG5cXHRpZiAoYWxpYXMpIHtcXG5cXHRcXHRpbnRyaW5zaWNCYXNlTmFtZSA9IGFsaWFzWzBdO1xcblxcdFxcdCRzcGxpY2VBcHBseShwYXJ0cywgJGNvbmNhdChbMCwgMV0sIGFsaWFzKSk7XFxuXFx0fVxcblxcblxcdGZvciAodmFyIGkgPSAxLCBpc093biA9IHRydWU7IGkgPCBwYXJ0cy5sZW5ndGg7IGkgKz0gMSkge1xcblxcdFxcdHZhciBwYXJ0ID0gcGFydHNbaV07XFxuXFx0XFx0dmFyIGZpcnN0ID0gJHN0clNsaWNlKHBhcnQsIDAsIDEpO1xcblxcdFxcdHZhciBsYXN0ID0gJHN0clNsaWNlKHBhcnQsIC0xKTtcXG5cXHRcXHRpZiAoXFxuXFx0XFx0XFx0KFxcblxcdFxcdFxcdFxcdChmaXJzdCA9PT0gJ1xcXCInIHx8IGZpcnN0ID09PSBcXFwiJ1xcXCIgfHwgZmlyc3QgPT09ICdgJylcXG5cXHRcXHRcXHRcXHR8fCAobGFzdCA9PT0gJ1xcXCInIHx8IGxhc3QgPT09IFxcXCInXFxcIiB8fCBsYXN0ID09PSAnYCcpXFxuXFx0XFx0XFx0KVxcblxcdFxcdFxcdCYmIGZpcnN0ICE9PSBsYXN0XFxuXFx0XFx0KSB7XFxuXFx0XFx0XFx0dGhyb3cgbmV3ICRTeW50YXhFcnJvcigncHJvcGVydHkgbmFtZXMgd2l0aCBxdW90ZXMgbXVzdCBoYXZlIG1hdGNoaW5nIHF1b3RlcycpO1xcblxcdFxcdH1cXG5cXHRcXHRpZiAocGFydCA9PT0gJ2NvbnN0cnVjdG9yJyB8fCAhaXNPd24pIHtcXG5cXHRcXHRcXHRza2lwRnVydGhlckNhY2hpbmcgPSB0cnVlO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRpbnRyaW5zaWNCYXNlTmFtZSArPSAnLicgKyBwYXJ0O1xcblxcdFxcdGludHJpbnNpY1JlYWxOYW1lID0gJyUnICsgaW50cmluc2ljQmFzZU5hbWUgKyAnJSc7XFxuXFxuXFx0XFx0aWYgKGhhc093bihJTlRSSU5TSUNTLCBpbnRyaW5zaWNSZWFsTmFtZSkpIHtcXG5cXHRcXHRcXHR2YWx1ZSA9IElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdO1xcblxcdFxcdH0gZWxzZSBpZiAodmFsdWUgIT0gbnVsbCkge1xcblxcdFxcdFxcdGlmICghKHBhcnQgaW4gdmFsdWUpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCFhbGxvd01pc3NpbmcpIHtcXG5cXHRcXHRcXHRcXHRcXHR0aHJvdyBuZXcgJFR5cGVFcnJvcignYmFzZSBpbnRyaW5zaWMgZm9yICcgKyBuYW1lICsgJyBleGlzdHMsIGJ1dCB0aGUgcHJvcGVydHkgaXMgbm90IGF2YWlsYWJsZS4nKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0cmV0dXJuIHZvaWQgdW5kZWZpbmVkO1xcblxcdFxcdFxcdH1cXG5cXHRcXHRcXHRpZiAoJGdPUEQgJiYgKGkgKyAxKSA+PSBwYXJ0cy5sZW5ndGgpIHtcXG5cXHRcXHRcXHRcXHR2YXIgZGVzYyA9ICRnT1BEKHZhbHVlLCBwYXJ0KTtcXG5cXHRcXHRcXHRcXHRpc093biA9ICEhZGVzYztcXG5cXG5cXHRcXHRcXHRcXHQvLyBCeSBjb252ZW50aW9uLCB3aGVuIGEgZGF0YSBwcm9wZXJ0eSBpcyBjb252ZXJ0ZWQgdG8gYW4gYWNjZXNzb3JcXG5cXHRcXHRcXHRcXHQvLyBwcm9wZXJ0eSB0byBlbXVsYXRlIGEgZGF0YSBwcm9wZXJ0eSB0aGF0IGRvZXMgbm90IHN1ZmZlciBmcm9tXFxuXFx0XFx0XFx0XFx0Ly8gdGhlIG92ZXJyaWRlIG1pc3Rha2UsIHRoYXQgYWNjZXNzb3IncyBnZXR0ZXIgaXMgbWFya2VkIHdpdGhcXG5cXHRcXHRcXHRcXHQvLyBhbiBgb3JpZ2luYWxWYWx1ZWAgcHJvcGVydHkuIEhlcmUsIHdoZW4gd2UgZGV0ZWN0IHRoaXMsIHdlXFxuXFx0XFx0XFx0XFx0Ly8gdXBob2xkIHRoZSBpbGx1c2lvbiBieSBwcmV0ZW5kaW5nIHRvIHNlZSB0aGF0IG9yaWdpbmFsIGRhdGFcXG5cXHRcXHRcXHRcXHQvLyBwcm9wZXJ0eSwgaS5lLiwgcmV0dXJuaW5nIHRoZSB2YWx1ZSByYXRoZXIgdGhhbiB0aGUgZ2V0dGVyXFxuXFx0XFx0XFx0XFx0Ly8gaXRzZWxmLlxcblxcdFxcdFxcdFxcdGlmIChpc093biAmJiAnZ2V0JyBpbiBkZXNjICYmICEoJ29yaWdpbmFsVmFsdWUnIGluIGRlc2MuZ2V0KSkge1xcblxcdFxcdFxcdFxcdFxcdHZhbHVlID0gZGVzYy5nZXQ7XFxuXFx0XFx0XFx0XFx0fSBlbHNlIHtcXG5cXHRcXHRcXHRcXHRcXHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlzT3duID0gaGFzT3duKHZhbHVlLCBwYXJ0KTtcXG5cXHRcXHRcXHRcXHR2YWx1ZSA9IHZhbHVlW3BhcnRdO1xcblxcdFxcdFxcdH1cXG5cXG5cXHRcXHRcXHRpZiAoaXNPd24gJiYgIXNraXBGdXJ0aGVyQ2FjaGluZykge1xcblxcdFxcdFxcdFxcdElOVFJJTlNJQ1NbaW50cmluc2ljUmVhbE5hbWVdID0gdmFsdWU7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9XFxuXFx0cmV0dXJuIHZhbHVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvZ2V0LWludHJpbnNpYy9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9oYXMtc3ltYm9scy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIG9yaWdTeW1ib2wgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyAmJiBTeW1ib2w7XFxudmFyIGhhc1N5bWJvbFNoYW0gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NoYW1zICovIFxcXCIuLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanNcXFwiKTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIGhhc05hdGl2ZVN5bWJvbHMoKSB7XFxuXFx0aWYgKHR5cGVvZiBvcmlnU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxcblxcdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxcblxcdGlmICh0eXBlb2Ygb3JpZ1N5bWJvbCgnZm9vJykgIT09ICdzeW1ib2wnKSB7IHJldHVybiBmYWxzZTsgfVxcblxcdGlmICh0eXBlb2YgU3ltYm9sKCdiYXInKSAhPT0gJ3N5bWJvbCcpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuXFx0cmV0dXJuIGhhc1N5bWJvbFNoYW0oKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2hhcy1zeW1ib2xzL3NoYW1zLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuLyogZXNsaW50IGNvbXBsZXhpdHk6IFsyLCAxOF0sIG1heC1zdGF0ZW1lbnRzOiBbMiwgMzNdICovXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBoYXNTeW1ib2xzKCkge1xcblxcdGlmICh0eXBlb2YgU3ltYm9sICE9PSAnZnVuY3Rpb24nIHx8IHR5cGVvZiBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzICE9PSAnZnVuY3Rpb24nKSB7IHJldHVybiBmYWxzZTsgfVxcblxcdGlmICh0eXBlb2YgU3ltYm9sLml0ZXJhdG9yID09PSAnc3ltYm9sJykgeyByZXR1cm4gdHJ1ZTsgfVxcblxcblxcdHZhciBvYmogPSB7fTtcXG5cXHR2YXIgc3ltID0gU3ltYm9sKCd0ZXN0Jyk7XFxuXFx0dmFyIHN5bU9iaiA9IE9iamVjdChzeW0pO1xcblxcdGlmICh0eXBlb2Ygc3ltID09PSAnc3RyaW5nJykgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG5cXHRpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKHN5bSkgIT09ICdbb2JqZWN0IFN5bWJvbF0nKSB7IHJldHVybiBmYWxzZTsgfVxcblxcdGlmIChPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltT2JqKSAhPT0gJ1tvYmplY3QgU3ltYm9sXScpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuXFx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL2xqaGFyYi9vYmplY3QuYXNzaWduL2lzc3Vlcy8xN1xcblxcdC8vIGlmIChzeW0gaW5zdGFuY2VvZiBTeW1ib2wpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFx0Ly8gdGVtcCBkaXNhYmxlZCBwZXIgaHR0cHM6Ly9naXRodWIuY29tL1dlYlJlZmxlY3Rpb24vZ2V0LW93bi1wcm9wZXJ0eS1zeW1ib2xzL2lzc3Vlcy80XFxuXFx0Ly8gaWYgKCEoc3ltT2JqIGluc3RhbmNlb2YgU3ltYm9sKSkgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG5cXHQvLyBpZiAodHlwZW9mIFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgIT09ICdmdW5jdGlvbicpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFx0Ly8gaWYgKFN0cmluZyhzeW0pICE9PSBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwoc3ltKSkgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG5cXHR2YXIgc3ltVmFsID0gNDI7XFxuXFx0b2JqW3N5bV0gPSBzeW1WYWw7XFxuXFx0Zm9yIChzeW0gaW4gb2JqKSB7IHJldHVybiBmYWxzZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby11bnJlYWNoYWJsZS1sb29wXFxuXFx0aWYgKHR5cGVvZiBPYmplY3Qua2V5cyA9PT0gJ2Z1bmN0aW9uJyAmJiBPYmplY3Qua2V5cyhvYmopLmxlbmd0aCAhPT0gMCkgeyByZXR1cm4gZmFsc2U7IH1cXG5cXG5cXHRpZiAodHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzID09PSAnZnVuY3Rpb24nICYmIE9iamVjdC5nZXRPd25Qcm9wZXJ0eU5hbWVzKG9iaikubGVuZ3RoICE9PSAwKSB7IHJldHVybiBmYWxzZTsgfVxcblxcblxcdHZhciBzeW1zID0gT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scyhvYmopO1xcblxcdGlmIChzeW1zLmxlbmd0aCAhPT0gMSB8fCBzeW1zWzBdICE9PSBzeW0pIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFxuXFx0aWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW0pKSB7IHJldHVybiBmYWxzZTsgfVxcblxcblxcdGlmICh0eXBlb2YgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciA9PT0gJ2Z1bmN0aW9uJykge1xcblxcdFxcdHZhciBkZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihvYmosIHN5bSk7XFxuXFx0XFx0aWYgKGRlc2NyaXB0b3IudmFsdWUgIT09IHN5bVZhbCB8fCBkZXNjcmlwdG9yLmVudW1lcmFibGUgIT09IHRydWUpIHsgcmV0dXJuIGZhbHNlOyB9XFxuXFx0fVxcblxcblxcdHJldHVybiB0cnVlO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvaGFzLXN5bWJvbHMvc2hhbXMuanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvaGFzL3NyYy9pbmRleC5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIGJpbmQgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBmdW5jdGlvbi1iaW5kICovIFxcXCIuLi9ub2RlX21vZHVsZXMvZnVuY3Rpb24tYmluZC9pbmRleC5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0gYmluZC5jYWxsKEZ1bmN0aW9uLmNhbGwsIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkpO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2hhcy9zcmMvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvanNvbi1zdHJpbmdpZnktc2FmZS9zdHJpbmdpZnkuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9qc29uLXN0cmluZ2lmeS1zYWZlL3N0cmluZ2lmeS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgZXhwb3J0cykgPT4ge1xuXG5ldmFsKFwiZXhwb3J0cyA9IG1vZHVsZS5leHBvcnRzID0gc3RyaW5naWZ5XFxuZXhwb3J0cy5nZXRTZXJpYWxpemUgPSBzZXJpYWxpemVyXFxuXFxuZnVuY3Rpb24gc3RyaW5naWZ5KG9iaiwgcmVwbGFjZXIsIHNwYWNlcywgY3ljbGVSZXBsYWNlcikge1xcbiAgcmV0dXJuIEpTT04uc3RyaW5naWZ5KG9iaiwgc2VyaWFsaXplcihyZXBsYWNlciwgY3ljbGVSZXBsYWNlciksIHNwYWNlcylcXG59XFxuXFxuZnVuY3Rpb24gc2VyaWFsaXplcihyZXBsYWNlciwgY3ljbGVSZXBsYWNlcikge1xcbiAgdmFyIHN0YWNrID0gW10sIGtleXMgPSBbXVxcblxcbiAgaWYgKGN5Y2xlUmVwbGFjZXIgPT0gbnVsbCkgY3ljbGVSZXBsYWNlciA9IGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgaWYgKHN0YWNrWzBdID09PSB2YWx1ZSkgcmV0dXJuIFxcXCJbQ2lyY3VsYXIgfl1cXFwiXFxuICAgIHJldHVybiBcXFwiW0NpcmN1bGFyIH4uXFxcIiArIGtleXMuc2xpY2UoMCwgc3RhY2suaW5kZXhPZih2YWx1ZSkpLmpvaW4oXFxcIi5cXFwiKSArIFxcXCJdXFxcIlxcbiAgfVxcblxcbiAgcmV0dXJuIGZ1bmN0aW9uKGtleSwgdmFsdWUpIHtcXG4gICAgaWYgKHN0YWNrLmxlbmd0aCA+IDApIHtcXG4gICAgICB2YXIgdGhpc1BvcyA9IHN0YWNrLmluZGV4T2YodGhpcylcXG4gICAgICB+dGhpc1BvcyA/IHN0YWNrLnNwbGljZSh0aGlzUG9zICsgMSkgOiBzdGFjay5wdXNoKHRoaXMpXFxuICAgICAgfnRoaXNQb3MgPyBrZXlzLnNwbGljZSh0aGlzUG9zLCBJbmZpbml0eSwga2V5KSA6IGtleXMucHVzaChrZXkpXFxuICAgICAgaWYgKH5zdGFjay5pbmRleE9mKHZhbHVlKSkgdmFsdWUgPSBjeWNsZVJlcGxhY2VyLmNhbGwodGhpcywga2V5LCB2YWx1ZSlcXG4gICAgfVxcbiAgICBlbHNlIHN0YWNrLnB1c2godmFsdWUpXFxuXFxuICAgIHJldHVybiByZXBsYWNlciA9PSBudWxsID8gdmFsdWUgOiByZXBsYWNlci5jYWxsKHRoaXMsIGtleSwgdmFsdWUpXFxuICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2pzb24tc3RyaW5naWZ5LXNhZmUvc3RyaW5naWZ5LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc3BsYWlub2JqZWN0L2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvbG9kYXNoLmlzcGxhaW5vYmplY3QvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuZXZhbChcIi8qKlxcbiAqIGxvZGFzaCAoQ3VzdG9tIEJ1aWxkKSA8aHR0cHM6Ly9sb2Rhc2guY29tLz5cXG4gKiBCdWlsZDogYGxvZGFzaCBtb2R1bGFyaXplIGV4cG9ydHM9XFxcIm5wbVxcXCIgLW8gLi9gXFxuICogQ29weXJpZ2h0IGpRdWVyeSBGb3VuZGF0aW9uIGFuZCBvdGhlciBjb250cmlidXRvcnMgPGh0dHBzOi8vanF1ZXJ5Lm9yZy8+XFxuICogUmVsZWFzZWQgdW5kZXIgTUlUIGxpY2Vuc2UgPGh0dHBzOi8vbG9kYXNoLmNvbS9saWNlbnNlPlxcbiAqIEJhc2VkIG9uIFVuZGVyc2NvcmUuanMgMS44LjMgPGh0dHA6Ly91bmRlcnNjb3JlanMub3JnL0xJQ0VOU0U+XFxuICogQ29weXJpZ2h0IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICovXFxuXFxuLyoqIGBPYmplY3QjdG9TdHJpbmdgIHJlc3VsdCByZWZlcmVuY2VzLiAqL1xcbnZhciBvYmplY3RUYWcgPSAnW29iamVjdCBPYmplY3RdJztcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBhIGhvc3Qgb2JqZWN0IGluIElFIDwgOS5cXG4gKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgYSBob3N0IG9iamVjdCwgZWxzZSBgZmFsc2VgLlxcbiAqL1xcbmZ1bmN0aW9uIGlzSG9zdE9iamVjdCh2YWx1ZSkge1xcbiAgLy8gTWFueSBob3N0IG9iamVjdHMgYXJlIGBPYmplY3RgIG9iamVjdHMgdGhhdCBjYW4gY29lcmNlIHRvIHN0cmluZ3NcXG4gIC8vIGRlc3BpdGUgaGF2aW5nIGltcHJvcGVybHkgZGVmaW5lZCBgdG9TdHJpbmdgIG1ldGhvZHMuXFxuICB2YXIgcmVzdWx0ID0gZmFsc2U7XFxuICBpZiAodmFsdWUgIT0gbnVsbCAmJiB0eXBlb2YgdmFsdWUudG9TdHJpbmcgIT0gJ2Z1bmN0aW9uJykge1xcbiAgICB0cnkge1xcbiAgICAgIHJlc3VsdCA9ICEhKHZhbHVlICsgJycpO1xcbiAgICB9IGNhdGNoIChlKSB7fVxcbiAgfVxcbiAgcmV0dXJuIHJlc3VsdDtcXG59XFxuXFxuLyoqXFxuICogQ3JlYXRlcyBhIHVuYXJ5IGZ1bmN0aW9uIHRoYXQgaW52b2tlcyBgZnVuY2Agd2l0aCBpdHMgYXJndW1lbnQgdHJhbnNmb3JtZWQuXFxuICpcXG4gKiBAcHJpdmF0ZVxcbiAqIEBwYXJhbSB7RnVuY3Rpb259IGZ1bmMgVGhlIGZ1bmN0aW9uIHRvIHdyYXAuXFxuICogQHBhcmFtIHtGdW5jdGlvbn0gdHJhbnNmb3JtIFRoZSBhcmd1bWVudCB0cmFuc2Zvcm0uXFxuICogQHJldHVybnMge0Z1bmN0aW9ufSBSZXR1cm5zIHRoZSBuZXcgZnVuY3Rpb24uXFxuICovXFxuZnVuY3Rpb24gb3ZlckFyZyhmdW5jLCB0cmFuc2Zvcm0pIHtcXG4gIHJldHVybiBmdW5jdGlvbihhcmcpIHtcXG4gICAgcmV0dXJuIGZ1bmModHJhbnNmb3JtKGFyZykpO1xcbiAgfTtcXG59XFxuXFxuLyoqIFVzZWQgZm9yIGJ1aWx0LWluIG1ldGhvZCByZWZlcmVuY2VzLiAqL1xcbnZhciBmdW5jUHJvdG8gPSBGdW5jdGlvbi5wcm90b3R5cGUsXFxuICAgIG9iamVjdFByb3RvID0gT2JqZWN0LnByb3RvdHlwZTtcXG5cXG4vKiogVXNlZCB0byByZXNvbHZlIHRoZSBkZWNvbXBpbGVkIHNvdXJjZSBvZiBmdW5jdGlvbnMuICovXFxudmFyIGZ1bmNUb1N0cmluZyA9IGZ1bmNQcm90by50b1N0cmluZztcXG5cXG4vKiogVXNlZCB0byBjaGVjayBvYmplY3RzIGZvciBvd24gcHJvcGVydGllcy4gKi9cXG52YXIgaGFzT3duUHJvcGVydHkgPSBvYmplY3RQcm90by5oYXNPd25Qcm9wZXJ0eTtcXG5cXG4vKiogVXNlZCB0byBpbmZlciB0aGUgYE9iamVjdGAgY29uc3RydWN0b3IuICovXFxudmFyIG9iamVjdEN0b3JTdHJpbmcgPSBmdW5jVG9TdHJpbmcuY2FsbChPYmplY3QpO1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGVcXG4gKiBbYHRvU3RyaW5nVGFnYF0oaHR0cDovL2VjbWEtaW50ZXJuYXRpb25hbC5vcmcvZWNtYS0yNjIvNy4wLyNzZWMtb2JqZWN0LnByb3RvdHlwZS50b3N0cmluZylcXG4gKiBvZiB2YWx1ZXMuXFxuICovXFxudmFyIG9iamVjdFRvU3RyaW5nID0gb2JqZWN0UHJvdG8udG9TdHJpbmc7XFxuXFxuLyoqIEJ1aWx0LWluIHZhbHVlIHJlZmVyZW5jZXMuICovXFxudmFyIGdldFByb3RvdHlwZSA9IG92ZXJBcmcoT2JqZWN0LmdldFByb3RvdHlwZU9mLCBPYmplY3QpO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLiBBIHZhbHVlIGlzIG9iamVjdC1saWtlIGlmIGl0J3Mgbm90IGBudWxsYFxcbiAqIGFuZCBoYXMgYSBgdHlwZW9mYCByZXN1bHQgb2YgXFxcIm9iamVjdFxcXCIuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgNC4wLjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIG9iamVjdC1saWtlLCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKHt9KTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0TGlrZShbMSwgMiwgM10pO1xcbiAqIC8vID0+IHRydWVcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKF8ubm9vcCk7XFxuICogLy8gPT4gZmFsc2VcXG4gKlxcbiAqIF8uaXNPYmplY3RMaWtlKG51bGwpO1xcbiAqIC8vID0+IGZhbHNlXFxuICovXFxuZnVuY3Rpb24gaXNPYmplY3RMaWtlKHZhbHVlKSB7XFxuICByZXR1cm4gISF2YWx1ZSAmJiB0eXBlb2YgdmFsdWUgPT0gJ29iamVjdCc7XFxufVxcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCB0aGF0IGlzLCBhbiBvYmplY3QgY3JlYXRlZCBieSB0aGVcXG4gKiBgT2JqZWN0YCBjb25zdHJ1Y3RvciBvciBvbmUgd2l0aCBhIGBbW1Byb3RvdHlwZV1dYCBvZiBgbnVsbGAuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAc2luY2UgMC44LjBcXG4gKiBAY2F0ZWdvcnkgTGFuZ1xcbiAqIEBwYXJhbSB7Kn0gdmFsdWUgVGhlIHZhbHVlIHRvIGNoZWNrLlxcbiAqIEByZXR1cm5zIHtib29sZWFufSBSZXR1cm5zIGB0cnVlYCBpZiBgdmFsdWVgIGlzIGEgcGxhaW4gb2JqZWN0LCBlbHNlIGBmYWxzZWAuXFxuICogQGV4YW1wbGVcXG4gKlxcbiAqIGZ1bmN0aW9uIEZvbygpIHtcXG4gKiAgIHRoaXMuYSA9IDE7XFxuICogfVxcbiAqXFxuICogXy5pc1BsYWluT2JqZWN0KG5ldyBGb28pO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzUGxhaW5PYmplY3QoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqXFxuICogXy5pc1BsYWluT2JqZWN0KHsgJ3gnOiAwLCAneSc6IDAgfSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc1BsYWluT2JqZWN0KE9iamVjdC5jcmVhdGUobnVsbCkpO1xcbiAqIC8vID0+IHRydWVcXG4gKi9cXG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KHZhbHVlKSB7XFxuICBpZiAoIWlzT2JqZWN0TGlrZSh2YWx1ZSkgfHxcXG4gICAgICBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSAhPSBvYmplY3RUYWcgfHwgaXNIb3N0T2JqZWN0KHZhbHVlKSkge1xcbiAgICByZXR1cm4gZmFsc2U7XFxuICB9XFxuICB2YXIgcHJvdG8gPSBnZXRQcm90b3R5cGUodmFsdWUpO1xcbiAgaWYgKHByb3RvID09PSBudWxsKSB7XFxuICAgIHJldHVybiB0cnVlO1xcbiAgfVxcbiAgdmFyIEN0b3IgPSBoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3RvLCAnY29uc3RydWN0b3InKSAmJiBwcm90by5jb25zdHJ1Y3RvcjtcXG4gIHJldHVybiAodHlwZW9mIEN0b3IgPT0gJ2Z1bmN0aW9uJyAmJlxcbiAgICBDdG9yIGluc3RhbmNlb2YgQ3RvciAmJiBmdW5jVG9TdHJpbmcuY2FsbChDdG9yKSA9PSBvYmplY3RDdG9yU3RyaW5nKTtcXG59XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBpc1BsYWluT2JqZWN0O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc3BsYWlub2JqZWN0L2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc3N0cmluZy9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9sb2Rhc2guaXNzdHJpbmcvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlKSA9PiB7XG5cbmV2YWwoXCIvKipcXG4gKiBsb2Rhc2ggNC4wLjEgKEN1c3RvbSBCdWlsZCkgPGh0dHBzOi8vbG9kYXNoLmNvbS8+XFxuICogQnVpbGQ6IGBsb2Rhc2ggbW9kdWxhcml6ZSBleHBvcnRzPVxcXCJucG1cXFwiIC1vIC4vYFxcbiAqIENvcHlyaWdodCAyMDEyLTIwMTYgVGhlIERvam8gRm91bmRhdGlvbiA8aHR0cDovL2Rvam9mb3VuZGF0aW9uLm9yZy8+XFxuICogQmFzZWQgb24gVW5kZXJzY29yZS5qcyAxLjguMyA8aHR0cDovL3VuZGVyc2NvcmVqcy5vcmcvTElDRU5TRT5cXG4gKiBDb3B5cmlnaHQgMjAwOS0yMDE2IEplcmVteSBBc2hrZW5hcywgRG9jdW1lbnRDbG91ZCBhbmQgSW52ZXN0aWdhdGl2ZSBSZXBvcnRlcnMgJiBFZGl0b3JzXFxuICogQXZhaWxhYmxlIHVuZGVyIE1JVCBsaWNlbnNlIDxodHRwczovL2xvZGFzaC5jb20vbGljZW5zZT5cXG4gKi9cXG5cXG4vKiogYE9iamVjdCN0b1N0cmluZ2AgcmVzdWx0IHJlZmVyZW5jZXMuICovXFxudmFyIHN0cmluZ1RhZyA9ICdbb2JqZWN0IFN0cmluZ10nO1xcblxcbi8qKiBVc2VkIGZvciBidWlsdC1pbiBtZXRob2QgcmVmZXJlbmNlcy4gKi9cXG52YXIgb2JqZWN0UHJvdG8gPSBPYmplY3QucHJvdG90eXBlO1xcblxcbi8qKlxcbiAqIFVzZWQgdG8gcmVzb2x2ZSB0aGUgW2B0b1N0cmluZ1RhZ2BdKGh0dHA6Ly9lY21hLWludGVybmF0aW9uYWwub3JnL2VjbWEtMjYyLzYuMC8jc2VjLW9iamVjdC5wcm90b3R5cGUudG9zdHJpbmcpXFxuICogb2YgdmFsdWVzLlxcbiAqL1xcbnZhciBvYmplY3RUb1N0cmluZyA9IG9iamVjdFByb3RvLnRvU3RyaW5nO1xcblxcbi8qKlxcbiAqIENoZWNrcyBpZiBgdmFsdWVgIGlzIGNsYXNzaWZpZWQgYXMgYW4gYEFycmF5YCBvYmplY3QuXFxuICpcXG4gKiBAc3RhdGljXFxuICogQG1lbWJlck9mIF9cXG4gKiBAdHlwZSBGdW5jdGlvblxcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc0FycmF5KFsxLCAyLCAzXSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc0FycmF5KGRvY3VtZW50LmJvZHkuY2hpbGRyZW4pO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzQXJyYXkoJ2FiYycpO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzQXJyYXkoXy5ub29wKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbnZhciBpc0FycmF5ID0gQXJyYXkuaXNBcnJheTtcXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZS4gQSB2YWx1ZSBpcyBvYmplY3QtbGlrZSBpZiBpdCdzIG5vdCBgbnVsbGBcXG4gKiBhbmQgaGFzIGEgYHR5cGVvZmAgcmVzdWx0IG9mIFxcXCJvYmplY3RcXFwiLlxcbiAqXFxuICogQHN0YXRpY1xcbiAqIEBtZW1iZXJPZiBfXFxuICogQGNhdGVnb3J5IExhbmdcXG4gKiBAcGFyYW0geyp9IHZhbHVlIFRoZSB2YWx1ZSB0byBjaGVjay5cXG4gKiBAcmV0dXJucyB7Ym9vbGVhbn0gUmV0dXJucyBgdHJ1ZWAgaWYgYHZhbHVlYCBpcyBvYmplY3QtbGlrZSwgZWxzZSBgZmFsc2VgLlxcbiAqIEBleGFtcGxlXFxuICpcXG4gKiBfLmlzT2JqZWN0TGlrZSh7fSk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc09iamVjdExpa2UoWzEsIDIsIDNdKTtcXG4gKiAvLyA9PiB0cnVlXFxuICpcXG4gKiBfLmlzT2JqZWN0TGlrZShfLm5vb3ApO1xcbiAqIC8vID0+IGZhbHNlXFxuICpcXG4gKiBfLmlzT2JqZWN0TGlrZShudWxsKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzT2JqZWN0TGlrZSh2YWx1ZSkge1xcbiAgcmV0dXJuICEhdmFsdWUgJiYgdHlwZW9mIHZhbHVlID09ICdvYmplY3QnO1xcbn1cXG5cXG4vKipcXG4gKiBDaGVja3MgaWYgYHZhbHVlYCBpcyBjbGFzc2lmaWVkIGFzIGEgYFN0cmluZ2AgcHJpbWl0aXZlIG9yIG9iamVjdC5cXG4gKlxcbiAqIEBzdGF0aWNcXG4gKiBAbWVtYmVyT2YgX1xcbiAqIEBjYXRlZ29yeSBMYW5nXFxuICogQHBhcmFtIHsqfSB2YWx1ZSBUaGUgdmFsdWUgdG8gY2hlY2suXFxuICogQHJldHVybnMge2Jvb2xlYW59IFJldHVybnMgYHRydWVgIGlmIGB2YWx1ZWAgaXMgY29ycmVjdGx5IGNsYXNzaWZpZWQsIGVsc2UgYGZhbHNlYC5cXG4gKiBAZXhhbXBsZVxcbiAqXFxuICogXy5pc1N0cmluZygnYWJjJyk7XFxuICogLy8gPT4gdHJ1ZVxcbiAqXFxuICogXy5pc1N0cmluZygxKTtcXG4gKiAvLyA9PiBmYWxzZVxcbiAqL1xcbmZ1bmN0aW9uIGlzU3RyaW5nKHZhbHVlKSB7XFxuICByZXR1cm4gdHlwZW9mIHZhbHVlID09ICdzdHJpbmcnIHx8XFxuICAgICghaXNBcnJheSh2YWx1ZSkgJiYgaXNPYmplY3RMaWtlKHZhbHVlKSAmJiBvYmplY3RUb1N0cmluZy5jYWxsKHZhbHVlKSA9PSBzdHJpbmdUYWcpO1xcbn1cXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGlzU3RyaW5nO1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL2xvZGFzaC5pc3N0cmluZy9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL29iamVjdC1pbnNwZWN0L2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuZXZhbChcInZhciBoYXNNYXAgPSB0eXBlb2YgTWFwID09PSAnZnVuY3Rpb24nICYmIE1hcC5wcm90b3R5cGU7XFxudmFyIG1hcFNpemVEZXNjcmlwdG9yID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvciAmJiBoYXNNYXAgPyBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKE1hcC5wcm90b3R5cGUsICdzaXplJykgOiBudWxsO1xcbnZhciBtYXBTaXplID0gaGFzTWFwICYmIG1hcFNpemVEZXNjcmlwdG9yICYmIHR5cGVvZiBtYXBTaXplRGVzY3JpcHRvci5nZXQgPT09ICdmdW5jdGlvbicgPyBtYXBTaXplRGVzY3JpcHRvci5nZXQgOiBudWxsO1xcbnZhciBtYXBGb3JFYWNoID0gaGFzTWFwICYmIE1hcC5wcm90b3R5cGUuZm9yRWFjaDtcXG52YXIgaGFzU2V0ID0gdHlwZW9mIFNldCA9PT0gJ2Z1bmN0aW9uJyAmJiBTZXQucHJvdG90eXBlO1xcbnZhciBzZXRTaXplRGVzY3JpcHRvciA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3IgJiYgaGFzU2V0ID8gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihTZXQucHJvdG90eXBlLCAnc2l6ZScpIDogbnVsbDtcXG52YXIgc2V0U2l6ZSA9IGhhc1NldCAmJiBzZXRTaXplRGVzY3JpcHRvciAmJiB0eXBlb2Ygc2V0U2l6ZURlc2NyaXB0b3IuZ2V0ID09PSAnZnVuY3Rpb24nID8gc2V0U2l6ZURlc2NyaXB0b3IuZ2V0IDogbnVsbDtcXG52YXIgc2V0Rm9yRWFjaCA9IGhhc1NldCAmJiBTZXQucHJvdG90eXBlLmZvckVhY2g7XFxudmFyIGhhc1dlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyAmJiBXZWFrTWFwLnByb3RvdHlwZTtcXG52YXIgd2Vha01hcEhhcyA9IGhhc1dlYWtNYXAgPyBXZWFrTWFwLnByb3RvdHlwZS5oYXMgOiBudWxsO1xcbnZhciBoYXNXZWFrU2V0ID0gdHlwZW9mIFdlYWtTZXQgPT09ICdmdW5jdGlvbicgJiYgV2Vha1NldC5wcm90b3R5cGU7XFxudmFyIHdlYWtTZXRIYXMgPSBoYXNXZWFrU2V0ID8gV2Vha1NldC5wcm90b3R5cGUuaGFzIDogbnVsbDtcXG52YXIgaGFzV2Vha1JlZiA9IHR5cGVvZiBXZWFrUmVmID09PSAnZnVuY3Rpb24nICYmIFdlYWtSZWYucHJvdG90eXBlO1xcbnZhciB3ZWFrUmVmRGVyZWYgPSBoYXNXZWFrUmVmID8gV2Vha1JlZi5wcm90b3R5cGUuZGVyZWYgOiBudWxsO1xcbnZhciBib29sZWFuVmFsdWVPZiA9IEJvb2xlYW4ucHJvdG90eXBlLnZhbHVlT2Y7XFxudmFyIG9iamVjdFRvU3RyaW5nID0gT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZztcXG52YXIgZnVuY3Rpb25Ub1N0cmluZyA9IEZ1bmN0aW9uLnByb3RvdHlwZS50b1N0cmluZztcXG52YXIgJG1hdGNoID0gU3RyaW5nLnByb3RvdHlwZS5tYXRjaDtcXG52YXIgJHNsaWNlID0gU3RyaW5nLnByb3RvdHlwZS5zbGljZTtcXG52YXIgJHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XFxudmFyICR0b1VwcGVyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9VcHBlckNhc2U7XFxudmFyICR0b0xvd2VyQ2FzZSA9IFN0cmluZy5wcm90b3R5cGUudG9Mb3dlckNhc2U7XFxudmFyICR0ZXN0ID0gUmVnRXhwLnByb3RvdHlwZS50ZXN0O1xcbnZhciAkY29uY2F0ID0gQXJyYXkucHJvdG90eXBlLmNvbmNhdDtcXG52YXIgJGpvaW4gPSBBcnJheS5wcm90b3R5cGUuam9pbjtcXG52YXIgJGFyclNsaWNlID0gQXJyYXkucHJvdG90eXBlLnNsaWNlO1xcbnZhciAkZmxvb3IgPSBNYXRoLmZsb29yO1xcbnZhciBiaWdJbnRWYWx1ZU9mID0gdHlwZW9mIEJpZ0ludCA9PT0gJ2Z1bmN0aW9uJyA/IEJpZ0ludC5wcm90b3R5cGUudmFsdWVPZiA6IG51bGw7XFxudmFyIGdPUFMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzO1xcbnZhciBzeW1Ub1N0cmluZyA9IHR5cGVvZiBTeW1ib2wgPT09ICdmdW5jdGlvbicgJiYgdHlwZW9mIFN5bWJvbC5pdGVyYXRvciA9PT0gJ3N5bWJvbCcgPyBTeW1ib2wucHJvdG90eXBlLnRvU3RyaW5nIDogbnVsbDtcXG52YXIgaGFzU2hhbW1lZFN5bWJvbHMgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIHR5cGVvZiBTeW1ib2wuaXRlcmF0b3IgPT09ICdvYmplY3QnO1xcbi8vIGllLCBgaGFzLXRvc3RyaW5ndGFnL3NoYW1zXFxudmFyIHRvU3RyaW5nVGFnID0gdHlwZW9mIFN5bWJvbCA9PT0gJ2Z1bmN0aW9uJyAmJiBTeW1ib2wudG9TdHJpbmdUYWcgJiYgKHR5cGVvZiBTeW1ib2wudG9TdHJpbmdUYWcgPT09IGhhc1NoYW1tZWRTeW1ib2xzID8gJ29iamVjdCcgOiAnc3ltYm9sJylcXG4gICAgPyBTeW1ib2wudG9TdHJpbmdUYWdcXG4gICAgOiBudWxsO1xcbnZhciBpc0VudW1lcmFibGUgPSBPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlO1xcblxcbnZhciBnUE8gPSAodHlwZW9mIFJlZmxlY3QgPT09ICdmdW5jdGlvbicgPyBSZWZsZWN0LmdldFByb3RvdHlwZU9mIDogT2JqZWN0LmdldFByb3RvdHlwZU9mKSB8fCAoXFxuICAgIFtdLl9fcHJvdG9fXyA9PT0gQXJyYXkucHJvdG90eXBlIC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cXG4gICAgICAgID8gZnVuY3Rpb24gKE8pIHtcXG4gICAgICAgICAgICByZXR1cm4gTy5fX3Byb3RvX187IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcHJvdG9cXG4gICAgICAgIH1cXG4gICAgICAgIDogbnVsbFxcbik7XFxuXFxuZnVuY3Rpb24gYWRkTnVtZXJpY1NlcGFyYXRvcihudW0sIHN0cikge1xcbiAgICBpZiAoXFxuICAgICAgICBudW0gPT09IEluZmluaXR5XFxuICAgICAgICB8fCBudW0gPT09IC1JbmZpbml0eVxcbiAgICAgICAgfHwgbnVtICE9PSBudW1cXG4gICAgICAgIHx8IChudW0gJiYgbnVtID4gLTEwMDAgJiYgbnVtIDwgMTAwMClcXG4gICAgICAgIHx8ICR0ZXN0LmNhbGwoL2UvLCBzdHIpXFxuICAgICkge1xcbiAgICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcbiAgICB2YXIgc2VwUmVnZXggPSAvWzAtOV0oPz0oPzpbMC05XXszfSkrKD8hWzAtOV0pKS9nO1xcbiAgICBpZiAodHlwZW9mIG51bSA9PT0gJ251bWJlcicpIHtcXG4gICAgICAgIHZhciBpbnQgPSBudW0gPCAwID8gLSRmbG9vcigtbnVtKSA6ICRmbG9vcihudW0pOyAvLyB0cnVuYyhudW0pXFxuICAgICAgICBpZiAoaW50ICE9PSBudW0pIHtcXG4gICAgICAgICAgICB2YXIgaW50U3RyID0gU3RyaW5nKGludCk7XFxuICAgICAgICAgICAgdmFyIGRlYyA9ICRzbGljZS5jYWxsKHN0ciwgaW50U3RyLmxlbmd0aCArIDEpO1xcbiAgICAgICAgICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKGludFN0ciwgc2VwUmVnZXgsICckJl8nKSArICcuJyArICRyZXBsYWNlLmNhbGwoJHJlcGxhY2UuY2FsbChkZWMsIC8oWzAtOV17M30pL2csICckJl8nKSwgL18kLywgJycpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKHN0ciwgc2VwUmVnZXgsICckJl8nKTtcXG59XFxuXFxudmFyIHV0aWxJbnNwZWN0ID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlsLmluc3BlY3QgKi8gXFxcIj9kOTFjXFxcIik7XFxudmFyIGluc3BlY3RDdXN0b20gPSB1dGlsSW5zcGVjdC5jdXN0b207XFxudmFyIGluc3BlY3RTeW1ib2wgPSBpc1N5bWJvbChpbnNwZWN0Q3VzdG9tKSA/IGluc3BlY3RDdXN0b20gOiBudWxsO1xcblxcbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24gaW5zcGVjdF8ob2JqLCBvcHRpb25zLCBkZXB0aCwgc2Vlbikge1xcbiAgICB2YXIgb3B0cyA9IG9wdGlvbnMgfHwge307XFxuXFxuICAgIGlmIChoYXMob3B0cywgJ3F1b3RlU3R5bGUnKSAmJiAob3B0cy5xdW90ZVN0eWxlICE9PSAnc2luZ2xlJyAmJiBvcHRzLnF1b3RlU3R5bGUgIT09ICdkb3VibGUnKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFxcXCJxdW90ZVN0eWxlXFxcIiBtdXN0IGJlIFxcXCJzaW5nbGVcXFwiIG9yIFxcXCJkb3VibGVcXFwiJyk7XFxuICAgIH1cXG4gICAgaWYgKFxcbiAgICAgICAgaGFzKG9wdHMsICdtYXhTdHJpbmdMZW5ndGgnKSAmJiAodHlwZW9mIG9wdHMubWF4U3RyaW5nTGVuZ3RoID09PSAnbnVtYmVyJ1xcbiAgICAgICAgICAgID8gb3B0cy5tYXhTdHJpbmdMZW5ndGggPCAwICYmIG9wdHMubWF4U3RyaW5nTGVuZ3RoICE9PSBJbmZpbml0eVxcbiAgICAgICAgICAgIDogb3B0cy5tYXhTdHJpbmdMZW5ndGggIT09IG51bGxcXG4gICAgICAgIClcXG4gICAgKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdvcHRpb24gXFxcIm1heFN0cmluZ0xlbmd0aFxcXCIsIGlmIHByb3ZpZGVkLCBtdXN0IGJlIGEgcG9zaXRpdmUgaW50ZWdlciwgSW5maW5pdHksIG9yIGBudWxsYCcpO1xcbiAgICB9XFxuICAgIHZhciBjdXN0b21JbnNwZWN0ID0gaGFzKG9wdHMsICdjdXN0b21JbnNwZWN0JykgPyBvcHRzLmN1c3RvbUluc3BlY3QgOiB0cnVlO1xcbiAgICBpZiAodHlwZW9mIGN1c3RvbUluc3BlY3QgIT09ICdib29sZWFuJyAmJiBjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFxcXCJjdXN0b21JbnNwZWN0XFxcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgLCBgZmFsc2VgLCBvciBgXFxcXCdzeW1ib2xcXFxcJ2AnKTtcXG4gICAgfVxcblxcbiAgICBpZiAoXFxuICAgICAgICBoYXMob3B0cywgJ2luZGVudCcpXFxuICAgICAgICAmJiBvcHRzLmluZGVudCAhPT0gbnVsbFxcbiAgICAgICAgJiYgb3B0cy5pbmRlbnQgIT09ICdcXFxcdCdcXG4gICAgICAgICYmICEocGFyc2VJbnQob3B0cy5pbmRlbnQsIDEwKSA9PT0gb3B0cy5pbmRlbnQgJiYgb3B0cy5pbmRlbnQgPiAwKVxcbiAgICApIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ29wdGlvbiBcXFwiaW5kZW50XFxcIiBtdXN0IGJlIFxcXCJcXFxcXFxcXHRcXFwiLCBhbiBpbnRlZ2VyID4gMCwgb3IgYG51bGxgJyk7XFxuICAgIH1cXG4gICAgaWYgKGhhcyhvcHRzLCAnbnVtZXJpY1NlcGFyYXRvcicpICYmIHR5cGVvZiBvcHRzLm51bWVyaWNTZXBhcmF0b3IgIT09ICdib29sZWFuJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignb3B0aW9uIFxcXCJudW1lcmljU2VwYXJhdG9yXFxcIiwgaWYgcHJvdmlkZWQsIG11c3QgYmUgYHRydWVgIG9yIGBmYWxzZWAnKTtcXG4gICAgfVxcbiAgICB2YXIgbnVtZXJpY1NlcGFyYXRvciA9IG9wdHMubnVtZXJpY1NlcGFyYXRvcjtcXG5cXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICByZXR1cm4gJ3VuZGVmaW5lZCc7XFxuICAgIH1cXG4gICAgaWYgKG9iaiA9PT0gbnVsbCkge1xcbiAgICAgICAgcmV0dXJuICdudWxsJztcXG4gICAgfVxcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgICByZXR1cm4gb2JqID8gJ3RydWUnIDogJ2ZhbHNlJztcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3N0cmluZycpIHtcXG4gICAgICAgIHJldHVybiBpbnNwZWN0U3RyaW5nKG9iaiwgb3B0cyk7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdudW1iZXInKSB7XFxuICAgICAgICBpZiAob2JqID09PSAwKSB7XFxuICAgICAgICAgICAgcmV0dXJuIEluZmluaXR5IC8gb2JqID4gMCA/ICcwJyA6ICctMCc7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgc3RyID0gU3RyaW5nKG9iaik7XFxuICAgICAgICByZXR1cm4gbnVtZXJpY1NlcGFyYXRvciA/IGFkZE51bWVyaWNTZXBhcmF0b3Iob2JqLCBzdHIpIDogc3RyO1xcbiAgICB9XFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnYmlnaW50Jykge1xcbiAgICAgICAgdmFyIGJpZ0ludFN0ciA9IFN0cmluZyhvYmopICsgJ24nO1xcbiAgICAgICAgcmV0dXJuIG51bWVyaWNTZXBhcmF0b3IgPyBhZGROdW1lcmljU2VwYXJhdG9yKG9iaiwgYmlnSW50U3RyKSA6IGJpZ0ludFN0cjtcXG4gICAgfVxcblxcbiAgICB2YXIgbWF4RGVwdGggPSB0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ3VuZGVmaW5lZCcgPyA1IDogb3B0cy5kZXB0aDtcXG4gICAgaWYgKHR5cGVvZiBkZXB0aCA9PT0gJ3VuZGVmaW5lZCcpIHsgZGVwdGggPSAwOyB9XFxuICAgIGlmIChkZXB0aCA+PSBtYXhEZXB0aCAmJiBtYXhEZXB0aCA+IDAgJiYgdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBpc0FycmF5KG9iaikgPyAnW0FycmF5XScgOiAnW09iamVjdF0nO1xcbiAgICB9XFxuXFxuICAgIHZhciBpbmRlbnQgPSBnZXRJbmRlbnQob3B0cywgZGVwdGgpO1xcblxcbiAgICBpZiAodHlwZW9mIHNlZW4gPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICBzZWVuID0gW107XFxuICAgIH0gZWxzZSBpZiAoaW5kZXhPZihzZWVuLCBvYmopID49IDApIHtcXG4gICAgICAgIHJldHVybiAnW0NpcmN1bGFyXSc7XFxuICAgIH1cXG5cXG4gICAgZnVuY3Rpb24gaW5zcGVjdCh2YWx1ZSwgZnJvbSwgbm9JbmRlbnQpIHtcXG4gICAgICAgIGlmIChmcm9tKSB7XFxuICAgICAgICAgICAgc2VlbiA9ICRhcnJTbGljZS5jYWxsKHNlZW4pO1xcbiAgICAgICAgICAgIHNlZW4ucHVzaChmcm9tKTtcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChub0luZGVudCkge1xcbiAgICAgICAgICAgIHZhciBuZXdPcHRzID0ge1xcbiAgICAgICAgICAgICAgICBkZXB0aDogb3B0cy5kZXB0aFxcbiAgICAgICAgICAgIH07XFxuICAgICAgICAgICAgaWYgKGhhcyhvcHRzLCAncXVvdGVTdHlsZScpKSB7XFxuICAgICAgICAgICAgICAgIG5ld09wdHMucXVvdGVTdHlsZSA9IG9wdHMucXVvdGVTdHlsZTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBuZXdPcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGluc3BlY3RfKHZhbHVlLCBvcHRzLCBkZXB0aCArIDEsIHNlZW4pO1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygb2JqID09PSAnZnVuY3Rpb24nICYmICFpc1JlZ0V4cChvYmopKSB7IC8vIGluIG9sZGVyIGVuZ2luZXMsIHJlZ2V4ZXMgYXJlIGNhbGxhYmxlXFxuICAgICAgICB2YXIgbmFtZSA9IG5hbWVPZihvYmopO1xcbiAgICAgICAgdmFyIGtleXMgPSBhcnJPYmpLZXlzKG9iaiwgaW5zcGVjdCk7XFxuICAgICAgICByZXR1cm4gJ1tGdW5jdGlvbicgKyAobmFtZSA/ICc6ICcgKyBuYW1lIDogJyAoYW5vbnltb3VzKScpICsgJ10nICsgKGtleXMubGVuZ3RoID4gMCA/ICcgeyAnICsgJGpvaW4uY2FsbChrZXlzLCAnLCAnKSArICcgfScgOiAnJyk7XFxuICAgIH1cXG4gICAgaWYgKGlzU3ltYm9sKG9iaikpIHtcXG4gICAgICAgIHZhciBzeW1TdHJpbmcgPSBoYXNTaGFtbWVkU3ltYm9scyA/ICRyZXBsYWNlLmNhbGwoU3RyaW5nKG9iaiksIC9eKFN5bWJvbFxcXFwoLipcXFxcKSlfW14pXSokLywgJyQxJykgOiBzeW1Ub1N0cmluZy5jYWxsKG9iaik7XFxuICAgICAgICByZXR1cm4gdHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgIWhhc1NoYW1tZWRTeW1ib2xzID8gbWFya0JveGVkKHN5bVN0cmluZykgOiBzeW1TdHJpbmc7XFxuICAgIH1cXG4gICAgaWYgKGlzRWxlbWVudChvYmopKSB7XFxuICAgICAgICB2YXIgcyA9ICc8JyArICR0b0xvd2VyQ2FzZS5jYWxsKFN0cmluZyhvYmoubm9kZU5hbWUpKTtcXG4gICAgICAgIHZhciBhdHRycyA9IG9iai5hdHRyaWJ1dGVzIHx8IFtdO1xcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBhdHRycy5sZW5ndGg7IGkrKykge1xcbiAgICAgICAgICAgIHMgKz0gJyAnICsgYXR0cnNbaV0ubmFtZSArICc9JyArIHdyYXBRdW90ZXMocXVvdGUoYXR0cnNbaV0udmFsdWUpLCAnZG91YmxlJywgb3B0cyk7XFxuICAgICAgICB9XFxuICAgICAgICBzICs9ICc+JztcXG4gICAgICAgIGlmIChvYmouY2hpbGROb2RlcyAmJiBvYmouY2hpbGROb2Rlcy5sZW5ndGgpIHsgcyArPSAnLi4uJzsgfVxcbiAgICAgICAgcyArPSAnPC8nICsgJHRvTG93ZXJDYXNlLmNhbGwoU3RyaW5nKG9iai5ub2RlTmFtZSkpICsgJz4nO1xcbiAgICAgICAgcmV0dXJuIHM7XFxuICAgIH1cXG4gICAgaWYgKGlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgaWYgKG9iai5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbXSc7IH1cXG4gICAgICAgIHZhciB4cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcXG4gICAgICAgIGlmIChpbmRlbnQgJiYgIXNpbmdsZUxpbmVWYWx1ZXMoeHMpKSB7XFxuICAgICAgICAgICAgcmV0dXJuICdbJyArIGluZGVudGVkSm9pbih4cywgaW5kZW50KSArICddJztcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiAnWyAnICsgJGpvaW4uY2FsbCh4cywgJywgJykgKyAnIF0nO1xcbiAgICB9XFxuICAgIGlmIChpc0Vycm9yKG9iaikpIHtcXG4gICAgICAgIHZhciBwYXJ0cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcXG4gICAgICAgIGlmICghKCdjYXVzZScgaW4gRXJyb3IucHJvdG90eXBlKSAmJiAnY2F1c2UnIGluIG9iaiAmJiAhaXNFbnVtZXJhYmxlLmNhbGwob2JqLCAnY2F1c2UnKSkge1xcbiAgICAgICAgICAgIHJldHVybiAneyBbJyArIFN0cmluZyhvYmopICsgJ10gJyArICRqb2luLmNhbGwoJGNvbmNhdC5jYWxsKCdbY2F1c2VdOiAnICsgaW5zcGVjdChvYmouY2F1c2UpLCBwYXJ0cyksICcsICcpICsgJyB9JztcXG4gICAgICAgIH1cXG4gICAgICAgIGlmIChwYXJ0cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICdbJyArIFN0cmluZyhvYmopICsgJ10nOyB9XFxuICAgICAgICByZXR1cm4gJ3sgWycgKyBTdHJpbmcob2JqKSArICddICcgKyAkam9pbi5jYWxsKHBhcnRzLCAnLCAnKSArICcgfSc7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIGN1c3RvbUluc3BlY3QpIHtcXG4gICAgICAgIGlmIChpbnNwZWN0U3ltYm9sICYmIHR5cGVvZiBvYmpbaW5zcGVjdFN5bWJvbF0gPT09ICdmdW5jdGlvbicgJiYgdXRpbEluc3BlY3QpIHtcXG4gICAgICAgICAgICByZXR1cm4gdXRpbEluc3BlY3Qob2JqLCB7IGRlcHRoOiBtYXhEZXB0aCAtIGRlcHRoIH0pO1xcbiAgICAgICAgfSBlbHNlIGlmIChjdXN0b21JbnNwZWN0ICE9PSAnc3ltYm9sJyAmJiB0eXBlb2Ygb2JqLmluc3BlY3QgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgICAgICByZXR1cm4gb2JqLmluc3BlY3QoKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBpZiAoaXNNYXAob2JqKSkge1xcbiAgICAgICAgdmFyIG1hcFBhcnRzID0gW107XFxuICAgICAgICBpZiAobWFwRm9yRWFjaCkge1xcbiAgICAgICAgICAgIG1hcEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSwga2V5KSB7XFxuICAgICAgICAgICAgICAgIG1hcFBhcnRzLnB1c2goaW5zcGVjdChrZXksIG9iaiwgdHJ1ZSkgKyAnID0+ICcgKyBpbnNwZWN0KHZhbHVlLCBvYmopKTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBjb2xsZWN0aW9uT2YoJ01hcCcsIG1hcFNpemUuY2FsbChvYmopLCBtYXBQYXJ0cywgaW5kZW50KTtcXG4gICAgfVxcbiAgICBpZiAoaXNTZXQob2JqKSkge1xcbiAgICAgICAgdmFyIHNldFBhcnRzID0gW107XFxuICAgICAgICBpZiAoc2V0Rm9yRWFjaCkge1xcbiAgICAgICAgICAgIHNldEZvckVhY2guY2FsbChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgICAgICBzZXRQYXJ0cy5wdXNoKGluc3BlY3QodmFsdWUsIG9iaikpO1xcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGNvbGxlY3Rpb25PZignU2V0Jywgc2V0U2l6ZS5jYWxsKG9iaiksIHNldFBhcnRzLCBpbmRlbnQpO1xcbiAgICB9XFxuICAgIGlmIChpc1dlYWtNYXAob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIHdlYWtDb2xsZWN0aW9uT2YoJ1dlYWtNYXAnKTtcXG4gICAgfVxcbiAgICBpZiAoaXNXZWFrU2V0KG9iaikpIHtcXG4gICAgICAgIHJldHVybiB3ZWFrQ29sbGVjdGlvbk9mKCdXZWFrU2V0Jyk7XFxuICAgIH1cXG4gICAgaWYgKGlzV2Vha1JlZihvYmopKSB7XFxuICAgICAgICByZXR1cm4gd2Vha0NvbGxlY3Rpb25PZignV2Vha1JlZicpO1xcbiAgICB9XFxuICAgIGlmIChpc051bWJlcihvYmopKSB7XFxuICAgICAgICByZXR1cm4gbWFya0JveGVkKGluc3BlY3QoTnVtYmVyKG9iaikpKTtcXG4gICAgfVxcbiAgICBpZiAoaXNCaWdJbnQob2JqKSkge1xcbiAgICAgICAgcmV0dXJuIG1hcmtCb3hlZChpbnNwZWN0KGJpZ0ludFZhbHVlT2YuY2FsbChvYmopKSk7XFxuICAgIH1cXG4gICAgaWYgKGlzQm9vbGVhbihvYmopKSB7XFxuICAgICAgICByZXR1cm4gbWFya0JveGVkKGJvb2xlYW5WYWx1ZU9mLmNhbGwob2JqKSk7XFxuICAgIH1cXG4gICAgaWYgKGlzU3RyaW5nKG9iaikpIHtcXG4gICAgICAgIHJldHVybiBtYXJrQm94ZWQoaW5zcGVjdChTdHJpbmcob2JqKSkpO1xcbiAgICB9XFxuICAgIGlmICghaXNEYXRlKG9iaikgJiYgIWlzUmVnRXhwKG9iaikpIHtcXG4gICAgICAgIHZhciB5cyA9IGFyck9iaktleXMob2JqLCBpbnNwZWN0KTtcXG4gICAgICAgIHZhciBpc1BsYWluT2JqZWN0ID0gZ1BPID8gZ1BPKG9iaikgPT09IE9iamVjdC5wcm90b3R5cGUgOiBvYmogaW5zdGFuY2VvZiBPYmplY3QgfHwgb2JqLmNvbnN0cnVjdG9yID09PSBPYmplY3Q7XFxuICAgICAgICB2YXIgcHJvdG9UYWcgPSBvYmogaW5zdGFuY2VvZiBPYmplY3QgPyAnJyA6ICdudWxsIHByb3RvdHlwZSc7XFxuICAgICAgICB2YXIgc3RyaW5nVGFnID0gIWlzUGxhaW5PYmplY3QgJiYgdG9TdHJpbmdUYWcgJiYgT2JqZWN0KG9iaikgPT09IG9iaiAmJiB0b1N0cmluZ1RhZyBpbiBvYmogPyAkc2xpY2UuY2FsbCh0b1N0cihvYmopLCA4LCAtMSkgOiBwcm90b1RhZyA/ICdPYmplY3QnIDogJyc7XFxuICAgICAgICB2YXIgY29uc3RydWN0b3JUYWcgPSBpc1BsYWluT2JqZWN0IHx8IHR5cGVvZiBvYmouY29uc3RydWN0b3IgIT09ICdmdW5jdGlvbicgPyAnJyA6IG9iai5jb25zdHJ1Y3Rvci5uYW1lID8gb2JqLmNvbnN0cnVjdG9yLm5hbWUgKyAnICcgOiAnJztcXG4gICAgICAgIHZhciB0YWcgPSBjb25zdHJ1Y3RvclRhZyArIChzdHJpbmdUYWcgfHwgcHJvdG9UYWcgPyAnWycgKyAkam9pbi5jYWxsKCRjb25jYXQuY2FsbChbXSwgc3RyaW5nVGFnIHx8IFtdLCBwcm90b1RhZyB8fCBbXSksICc6ICcpICsgJ10gJyA6ICcnKTtcXG4gICAgICAgIGlmICh5cy5sZW5ndGggPT09IDApIHsgcmV0dXJuIHRhZyArICd7fSc7IH1cXG4gICAgICAgIGlmIChpbmRlbnQpIHtcXG4gICAgICAgICAgICByZXR1cm4gdGFnICsgJ3snICsgaW5kZW50ZWRKb2luKHlzLCBpbmRlbnQpICsgJ30nO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHRhZyArICd7ICcgKyAkam9pbi5jYWxsKHlzLCAnLCAnKSArICcgfSc7XFxuICAgIH1cXG4gICAgcmV0dXJuIFN0cmluZyhvYmopO1xcbn07XFxuXFxuZnVuY3Rpb24gd3JhcFF1b3RlcyhzLCBkZWZhdWx0U3R5bGUsIG9wdHMpIHtcXG4gICAgdmFyIHF1b3RlQ2hhciA9IChvcHRzLnF1b3RlU3R5bGUgfHwgZGVmYXVsdFN0eWxlKSA9PT0gJ2RvdWJsZScgPyAnXFxcIicgOiBcXFwiJ1xcXCI7XFxuICAgIHJldHVybiBxdW90ZUNoYXIgKyBzICsgcXVvdGVDaGFyO1xcbn1cXG5cXG5mdW5jdGlvbiBxdW90ZShzKSB7XFxuICAgIHJldHVybiAkcmVwbGFjZS5jYWxsKFN0cmluZyhzKSwgL1xcXCIvZywgJyZxdW90OycpO1xcbn1cXG5cXG5mdW5jdGlvbiBpc0FycmF5KG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQXJyYXldJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cXG5mdW5jdGlvbiBpc0RhdGUob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBEYXRlXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XFxuZnVuY3Rpb24gaXNSZWdFeHAob2JqKSB7IHJldHVybiB0b1N0cihvYmopID09PSAnW29iamVjdCBSZWdFeHBdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cXG5mdW5jdGlvbiBpc0Vycm9yKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgRXJyb3JdJyAmJiAoIXRvU3RyaW5nVGFnIHx8ICEodHlwZW9mIG9iaiA9PT0gJ29iamVjdCcgJiYgdG9TdHJpbmdUYWcgaW4gb2JqKSk7IH1cXG5mdW5jdGlvbiBpc1N0cmluZyhvYmopIHsgcmV0dXJuIHRvU3RyKG9iaikgPT09ICdbb2JqZWN0IFN0cmluZ10nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxcbmZ1bmN0aW9uIGlzTnVtYmVyKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgTnVtYmVyXScgJiYgKCF0b1N0cmluZ1RhZyB8fCAhKHR5cGVvZiBvYmogPT09ICdvYmplY3QnICYmIHRvU3RyaW5nVGFnIGluIG9iaikpOyB9XFxuZnVuY3Rpb24gaXNCb29sZWFuKG9iaikgeyByZXR1cm4gdG9TdHIob2JqKSA9PT0gJ1tvYmplY3QgQm9vbGVhbl0nICYmICghdG9TdHJpbmdUYWcgfHwgISh0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiB0b1N0cmluZ1RhZyBpbiBvYmopKTsgfVxcblxcbi8vIFN5bWJvbCBhbmQgQmlnSW50IGRvIGhhdmUgU3ltYm9sLnRvU3RyaW5nVGFnIGJ5IHNwZWMsIHNvIHRoYXQgY2FuJ3QgYmUgdXNlZCB0byBlbGltaW5hdGUgZmFsc2UgcG9zaXRpdmVzXFxuZnVuY3Rpb24gaXNTeW1ib2wob2JqKSB7XFxuICAgIGlmIChoYXNTaGFtbWVkU3ltYm9scykge1xcbiAgICAgICAgcmV0dXJuIG9iaiAmJiB0eXBlb2Ygb2JqID09PSAnb2JqZWN0JyAmJiBvYmogaW5zdGFuY2VvZiBTeW1ib2w7XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBvYmogPT09ICdzeW1ib2wnKSB7XFxuICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgfVxcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0JyB8fCAhc3ltVG9TdHJpbmcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgc3ltVG9TdHJpbmcuY2FsbChvYmopO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaXNCaWdJbnQob2JqKSB7XFxuICAgIGlmICghb2JqIHx8IHR5cGVvZiBvYmogIT09ICdvYmplY3QnIHx8ICFiaWdJbnRWYWx1ZU9mKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIGJpZ0ludFZhbHVlT2YuY2FsbChvYmopO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxudmFyIGhhc093biA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkgfHwgZnVuY3Rpb24gKGtleSkgeyByZXR1cm4ga2V5IGluIHRoaXM7IH07XFxuZnVuY3Rpb24gaGFzKG9iaiwga2V5KSB7XFxuICAgIHJldHVybiBoYXNPd24uY2FsbChvYmosIGtleSk7XFxufVxcblxcbmZ1bmN0aW9uIHRvU3RyKG9iaikge1xcbiAgICByZXR1cm4gb2JqZWN0VG9TdHJpbmcuY2FsbChvYmopO1xcbn1cXG5cXG5mdW5jdGlvbiBuYW1lT2YoZikge1xcbiAgICBpZiAoZi5uYW1lKSB7IHJldHVybiBmLm5hbWU7IH1cXG4gICAgdmFyIG0gPSAkbWF0Y2guY2FsbChmdW5jdGlvblRvU3RyaW5nLmNhbGwoZiksIC9eZnVuY3Rpb25cXFxccyooW1xcXFx3JF0rKS8pO1xcbiAgICBpZiAobSkgeyByZXR1cm4gbVsxXTsgfVxcbiAgICByZXR1cm4gbnVsbDtcXG59XFxuXFxuZnVuY3Rpb24gaW5kZXhPZih4cywgeCkge1xcbiAgICBpZiAoeHMuaW5kZXhPZikgeyByZXR1cm4geHMuaW5kZXhPZih4KTsgfVxcbiAgICBmb3IgKHZhciBpID0gMCwgbCA9IHhzLmxlbmd0aDsgaSA8IGw7IGkrKykge1xcbiAgICAgICAgaWYgKHhzW2ldID09PSB4KSB7IHJldHVybiBpOyB9XFxuICAgIH1cXG4gICAgcmV0dXJuIC0xO1xcbn1cXG5cXG5mdW5jdGlvbiBpc01hcCh4KSB7XFxuICAgIGlmICghbWFwU2l6ZSB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBzZXRTaXplLmNhbGwoeCk7XFxuICAgICAgICB9IGNhdGNoIChzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIE1hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaXNXZWFrTWFwKHgpIHtcXG4gICAgaWYgKCF3ZWFrTWFwSGFzIHx8ICF4IHx8IHR5cGVvZiB4ICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuICAgIHRyeSB7XFxuICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHdlYWtTZXRIYXMuY2FsbCh4LCB3ZWFrU2V0SGFzKTtcXG4gICAgICAgIH0gY2F0Y2ggKHMpIHtcXG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB4IGluc3RhbmNlb2YgV2Vha01hcDsgLy8gY29yZS1qcyB3b3JrYXJvdW5kLCBwcmUtdjIuNS4wXFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaXNXZWFrUmVmKHgpIHtcXG4gICAgaWYgKCF3ZWFrUmVmRGVyZWYgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIHdlYWtSZWZEZXJlZi5jYWxsKHgpO1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH0gY2F0Y2ggKGUpIHt9XFxuICAgIHJldHVybiBmYWxzZTtcXG59XFxuXFxuZnVuY3Rpb24gaXNTZXQoeCkge1xcbiAgICBpZiAoIXNldFNpemUgfHwgIXggfHwgdHlwZW9mIHggIT09ICdvYmplY3QnKSB7XFxuICAgICAgICByZXR1cm4gZmFsc2U7XFxuICAgIH1cXG4gICAgdHJ5IHtcXG4gICAgICAgIHNldFNpemUuY2FsbCh4KTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgbWFwU2l6ZS5jYWxsKHgpO1xcbiAgICAgICAgfSBjYXRjaCAobSkge1xcbiAgICAgICAgICAgIHJldHVybiB0cnVlO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIHggaW5zdGFuY2VvZiBTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxcbiAgICB9IGNhdGNoIChlKSB7fVxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIGlzV2Vha1NldCh4KSB7XFxuICAgIGlmICghd2Vha1NldEhhcyB8fCAheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgfVxcbiAgICB0cnkge1xcbiAgICAgICAgd2Vha1NldEhhcy5jYWxsKHgsIHdlYWtTZXRIYXMpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICB3ZWFrTWFwSGFzLmNhbGwoeCwgd2Vha01hcEhhcyk7XFxuICAgICAgICB9IGNhdGNoIChzKSB7XFxuICAgICAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4geCBpbnN0YW5jZW9mIFdlYWtTZXQ7IC8vIGNvcmUtanMgd29ya2Fyb3VuZCwgcHJlLXYyLjUuMFxcbiAgICB9IGNhdGNoIChlKSB7fVxcbiAgICByZXR1cm4gZmFsc2U7XFxufVxcblxcbmZ1bmN0aW9uIGlzRWxlbWVudCh4KSB7XFxuICAgIGlmICgheCB8fCB0eXBlb2YgeCAhPT0gJ29iamVjdCcpIHsgcmV0dXJuIGZhbHNlOyB9XFxuICAgIGlmICh0eXBlb2YgSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIHggaW5zdGFuY2VvZiBIVE1MRWxlbWVudCkge1xcbiAgICAgICAgcmV0dXJuIHRydWU7XFxuICAgIH1cXG4gICAgcmV0dXJuIHR5cGVvZiB4Lm5vZGVOYW1lID09PSAnc3RyaW5nJyAmJiB0eXBlb2YgeC5nZXRBdHRyaWJ1dGUgPT09ICdmdW5jdGlvbic7XFxufVxcblxcbmZ1bmN0aW9uIGluc3BlY3RTdHJpbmcoc3RyLCBvcHRzKSB7XFxuICAgIGlmIChzdHIubGVuZ3RoID4gb3B0cy5tYXhTdHJpbmdMZW5ndGgpIHtcXG4gICAgICAgIHZhciByZW1haW5pbmcgPSBzdHIubGVuZ3RoIC0gb3B0cy5tYXhTdHJpbmdMZW5ndGg7XFxuICAgICAgICB2YXIgdHJhaWxlciA9ICcuLi4gJyArIHJlbWFpbmluZyArICcgbW9yZSBjaGFyYWN0ZXInICsgKHJlbWFpbmluZyA+IDEgPyAncycgOiAnJyk7XFxuICAgICAgICByZXR1cm4gaW5zcGVjdFN0cmluZygkc2xpY2UuY2FsbChzdHIsIDAsIG9wdHMubWF4U3RyaW5nTGVuZ3RoKSwgb3B0cykgKyB0cmFpbGVyO1xcbiAgICB9XFxuICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby1jb250cm9sLXJlZ2V4XFxuICAgIHZhciBzID0gJHJlcGxhY2UuY2FsbCgkcmVwbGFjZS5jYWxsKHN0ciwgLyhbJ1xcXFxcXFxcXSkvZywgJ1xcXFxcXFxcJDEnKSwgL1tcXFxceDAwLVxcXFx4MWZdL2csIGxvd2J5dGUpO1xcbiAgICByZXR1cm4gd3JhcFF1b3RlcyhzLCAnc2luZ2xlJywgb3B0cyk7XFxufVxcblxcbmZ1bmN0aW9uIGxvd2J5dGUoYykge1xcbiAgICB2YXIgbiA9IGMuY2hhckNvZGVBdCgwKTtcXG4gICAgdmFyIHggPSB7XFxuICAgICAgICA4OiAnYicsXFxuICAgICAgICA5OiAndCcsXFxuICAgICAgICAxMDogJ24nLFxcbiAgICAgICAgMTI6ICdmJyxcXG4gICAgICAgIDEzOiAncidcXG4gICAgfVtuXTtcXG4gICAgaWYgKHgpIHsgcmV0dXJuICdcXFxcXFxcXCcgKyB4OyB9XFxuICAgIHJldHVybiAnXFxcXFxcXFx4JyArIChuIDwgMHgxMCA/ICcwJyA6ICcnKSArICR0b1VwcGVyQ2FzZS5jYWxsKG4udG9TdHJpbmcoMTYpKTtcXG59XFxuXFxuZnVuY3Rpb24gbWFya0JveGVkKHN0cikge1xcbiAgICByZXR1cm4gJ09iamVjdCgnICsgc3RyICsgJyknO1xcbn1cXG5cXG5mdW5jdGlvbiB3ZWFrQ29sbGVjdGlvbk9mKHR5cGUpIHtcXG4gICAgcmV0dXJuIHR5cGUgKyAnIHsgPyB9JztcXG59XFxuXFxuZnVuY3Rpb24gY29sbGVjdGlvbk9mKHR5cGUsIHNpemUsIGVudHJpZXMsIGluZGVudCkge1xcbiAgICB2YXIgam9pbmVkRW50cmllcyA9IGluZGVudCA/IGluZGVudGVkSm9pbihlbnRyaWVzLCBpbmRlbnQpIDogJGpvaW4uY2FsbChlbnRyaWVzLCAnLCAnKTtcXG4gICAgcmV0dXJuIHR5cGUgKyAnICgnICsgc2l6ZSArICcpIHsnICsgam9pbmVkRW50cmllcyArICd9JztcXG59XFxuXFxuZnVuY3Rpb24gc2luZ2xlTGluZVZhbHVlcyh4cykge1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHhzLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICBpZiAoaW5kZXhPZih4c1tpXSwgJ1xcXFxuJykgPj0gMCkge1xcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICByZXR1cm4gdHJ1ZTtcXG59XFxuXFxuZnVuY3Rpb24gZ2V0SW5kZW50KG9wdHMsIGRlcHRoKSB7XFxuICAgIHZhciBiYXNlSW5kZW50O1xcbiAgICBpZiAob3B0cy5pbmRlbnQgPT09ICdcXFxcdCcpIHtcXG4gICAgICAgIGJhc2VJbmRlbnQgPSAnXFxcXHQnO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBvcHRzLmluZGVudCA9PT0gJ251bWJlcicgJiYgb3B0cy5pbmRlbnQgPiAwKSB7XFxuICAgICAgICBiYXNlSW5kZW50ID0gJGpvaW4uY2FsbChBcnJheShvcHRzLmluZGVudCArIDEpLCAnICcpO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIG51bGw7XFxuICAgIH1cXG4gICAgcmV0dXJuIHtcXG4gICAgICAgIGJhc2U6IGJhc2VJbmRlbnQsXFxuICAgICAgICBwcmV2OiAkam9pbi5jYWxsKEFycmF5KGRlcHRoICsgMSksIGJhc2VJbmRlbnQpXFxuICAgIH07XFxufVxcblxcbmZ1bmN0aW9uIGluZGVudGVkSm9pbih4cywgaW5kZW50KSB7XFxuICAgIGlmICh4cy5sZW5ndGggPT09IDApIHsgcmV0dXJuICcnOyB9XFxuICAgIHZhciBsaW5lSm9pbmVyID0gJ1xcXFxuJyArIGluZGVudC5wcmV2ICsgaW5kZW50LmJhc2U7XFxuICAgIHJldHVybiBsaW5lSm9pbmVyICsgJGpvaW4uY2FsbCh4cywgJywnICsgbGluZUpvaW5lcikgKyAnXFxcXG4nICsgaW5kZW50LnByZXY7XFxufVxcblxcbmZ1bmN0aW9uIGFyck9iaktleXMob2JqLCBpbnNwZWN0KSB7XFxuICAgIHZhciBpc0FyciA9IGlzQXJyYXkob2JqKTtcXG4gICAgdmFyIHhzID0gW107XFxuICAgIGlmIChpc0Fycikge1xcbiAgICAgICAgeHMubGVuZ3RoID0gb2JqLmxlbmd0aDtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgb2JqLmxlbmd0aDsgaSsrKSB7XFxuICAgICAgICAgICAgeHNbaV0gPSBoYXMob2JqLCBpKSA/IGluc3BlY3Qob2JqW2ldLCBvYmopIDogJyc7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgdmFyIHN5bXMgPSB0eXBlb2YgZ09QUyA9PT0gJ2Z1bmN0aW9uJyA/IGdPUFMob2JqKSA6IFtdO1xcbiAgICB2YXIgc3ltTWFwO1xcbiAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMpIHtcXG4gICAgICAgIHN5bU1hcCA9IHt9O1xcbiAgICAgICAgZm9yICh2YXIgayA9IDA7IGsgPCBzeW1zLmxlbmd0aDsgaysrKSB7XFxuICAgICAgICAgICAgc3ltTWFwWyckJyArIHN5bXNba11dID0gc3ltc1trXTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBmb3IgKHZhciBrZXkgaW4gb2JqKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXhcXG4gICAgICAgIGlmICghaGFzKG9iaiwga2V5KSkgeyBjb250aW51ZTsgfSAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxcbiAgICAgICAgaWYgKGlzQXJyICYmIFN0cmluZyhOdW1iZXIoa2V5KSkgPT09IGtleSAmJiBrZXkgPCBvYmoubGVuZ3RoKSB7IGNvbnRpbnVlOyB9IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcmVzdHJpY3RlZC1zeW50YXgsIG5vLWNvbnRpbnVlXFxuICAgICAgICBpZiAoaGFzU2hhbW1lZFN5bWJvbHMgJiYgc3ltTWFwWyckJyArIGtleV0gaW5zdGFuY2VvZiBTeW1ib2wpIHtcXG4gICAgICAgICAgICAvLyB0aGlzIGlzIHRvIHByZXZlbnQgc2hhbW1lZCBTeW1ib2xzLCB3aGljaCBhcmUgc3RvcmVkIGFzIHN0cmluZ3MsIGZyb20gYmVpbmcgaW5jbHVkZWQgaW4gdGhlIHN0cmluZyBrZXkgc2VjdGlvblxcbiAgICAgICAgICAgIGNvbnRpbnVlOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXJlc3RyaWN0ZWQtc3ludGF4LCBuby1jb250aW51ZVxcbiAgICAgICAgfSBlbHNlIGlmICgkdGVzdC5jYWxsKC9bXlxcXFx3JF0vLCBrZXkpKSB7XFxuICAgICAgICAgICAgeHMucHVzaChpbnNwZWN0KGtleSwgb2JqKSArICc6ICcgKyBpbnNwZWN0KG9ialtrZXldLCBvYmopKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgeHMucHVzaChrZXkgKyAnOiAnICsgaW5zcGVjdChvYmpba2V5XSwgb2JqKSk7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKHR5cGVvZiBnT1BTID09PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IHN5bXMubGVuZ3RoOyBqKyspIHtcXG4gICAgICAgICAgICBpZiAoaXNFbnVtZXJhYmxlLmNhbGwob2JqLCBzeW1zW2pdKSkge1xcbiAgICAgICAgICAgICAgICB4cy5wdXNoKCdbJyArIGluc3BlY3Qoc3ltc1tqXSkgKyAnXTogJyArIGluc3BlY3Qob2JqW3N5bXNbal1dLCBvYmopKTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgcmV0dXJuIHhzO1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9vYmplY3QtaW5zcGVjdC9pbmRleC5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9wLXRocm90dGxlL2luZGV4LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9wLXRocm90dGxlL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxuY2xhc3MgQWJvcnRFcnJvciBleHRlbmRzIEVycm9yIHtcXG5cXHRjb25zdHJ1Y3RvcigpIHtcXG5cXHRcXHRzdXBlcignVGhyb3R0bGVkIGZ1bmN0aW9uIGFib3J0ZWQnKTtcXG5cXHRcXHR0aGlzLm5hbWUgPSAnQWJvcnRFcnJvcic7XFxuXFx0fVxcbn1cXG5cXG5jb25zdCBwVGhyb3R0bGUgPSAoe2xpbWl0LCBpbnRlcnZhbCwgc3RyaWN0fSkgPT4ge1xcblxcdGlmICghTnVtYmVyLmlzRmluaXRlKGxpbWl0KSkge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBsaW1pdGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyJyk7XFxuXFx0fVxcblxcblxcdGlmICghTnVtYmVyLmlzRmluaXRlKGludGVydmFsKSkge1xcblxcdFxcdHRocm93IG5ldyBUeXBlRXJyb3IoJ0V4cGVjdGVkIGBpbnRlcnZhbGAgdG8gYmUgYSBmaW5pdGUgbnVtYmVyJyk7XFxuXFx0fVxcblxcblxcdGNvbnN0IHF1ZXVlID0gbmV3IE1hcCgpO1xcblxcblxcdGxldCBjdXJyZW50VGljayA9IDA7XFxuXFx0bGV0IGFjdGl2ZUNvdW50ID0gMDtcXG5cXG5cXHRmdW5jdGlvbiB3aW5kb3dlZERlbGF5KCkge1xcblxcdFxcdGNvbnN0IG5vdyA9IERhdGUubm93KCk7XFxuXFxuXFx0XFx0aWYgKChub3cgLSBjdXJyZW50VGljaykgPiBpbnRlcnZhbCkge1xcblxcdFxcdFxcdGFjdGl2ZUNvdW50ID0gMTtcXG5cXHRcXHRcXHRjdXJyZW50VGljayA9IG5vdztcXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0aWYgKGFjdGl2ZUNvdW50IDwgbGltaXQpIHtcXG5cXHRcXHRcXHRhY3RpdmVDb3VudCsrO1xcblxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0Y3VycmVudFRpY2sgKz0gaW50ZXJ2YWw7XFxuXFx0XFx0XFx0YWN0aXZlQ291bnQgPSAxO1xcblxcdFxcdH1cXG5cXG5cXHRcXHRyZXR1cm4gY3VycmVudFRpY2sgLSBub3c7XFxuXFx0fVxcblxcblxcdGNvbnN0IHN0cmljdFRpY2tzID0gW107XFxuXFxuXFx0ZnVuY3Rpb24gc3RyaWN0RGVsYXkoKSB7XFxuXFx0XFx0Y29uc3Qgbm93ID0gRGF0ZS5ub3coKTtcXG5cXG5cXHRcXHRpZiAoc3RyaWN0VGlja3MubGVuZ3RoIDwgbGltaXQpIHtcXG5cXHRcXHRcXHRzdHJpY3RUaWNrcy5wdXNoKG5vdyk7XFxuXFx0XFx0XFx0cmV0dXJuIDA7XFxuXFx0XFx0fVxcblxcblxcdFxcdGNvbnN0IGVhcmxpZXN0VGltZSA9IHN0cmljdFRpY2tzLnNoaWZ0KCkgKyBpbnRlcnZhbDtcXG5cXG5cXHRcXHRpZiAobm93ID49IGVhcmxpZXN0VGltZSkge1xcblxcdFxcdFxcdHN0cmljdFRpY2tzLnB1c2gobm93KTtcXG5cXHRcXHRcXHRyZXR1cm4gMDtcXG5cXHRcXHR9XFxuXFxuXFx0XFx0c3RyaWN0VGlja3MucHVzaChlYXJsaWVzdFRpbWUpO1xcblxcdFxcdHJldHVybiBlYXJsaWVzdFRpbWUgLSBub3c7XFxuXFx0fVxcblxcblxcdGNvbnN0IGdldERlbGF5ID0gc3RyaWN0ID8gc3RyaWN0RGVsYXkgOiB3aW5kb3dlZERlbGF5O1xcblxcblxcdHJldHVybiBmdW5jdGlvbl8gPT4ge1xcblxcdFxcdGNvbnN0IHRocm90dGxlZCA9IGZ1bmN0aW9uICguLi5hcmdzKSB7XFxuXFx0XFx0XFx0aWYgKCF0aHJvdHRsZWQuaXNFbmFibGVkKSB7XFxuXFx0XFx0XFx0XFx0cmV0dXJuIChhc3luYyAoKSA9PiBmdW5jdGlvbl8uYXBwbHkodGhpcywgYXJncykpKCk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdGxldCB0aW1lb3V0O1xcblxcdFxcdFxcdHJldHVybiBuZXcgUHJvbWlzZSgocmVzb2x2ZSwgcmVqZWN0KSA9PiB7XFxuXFx0XFx0XFx0XFx0Y29uc3QgZXhlY3V0ZSA9ICgpID0+IHtcXG5cXHRcXHRcXHRcXHRcXHRyZXNvbHZlKGZ1bmN0aW9uXy5hcHBseSh0aGlzLCBhcmdzKSk7XFxuXFx0XFx0XFx0XFx0XFx0cXVldWUuZGVsZXRlKHRpbWVvdXQpO1xcblxcdFxcdFxcdFxcdH07XFxuXFxuXFx0XFx0XFx0XFx0dGltZW91dCA9IHNldFRpbWVvdXQoZXhlY3V0ZSwgZ2V0RGVsYXkoKSk7XFxuXFxuXFx0XFx0XFx0XFx0cXVldWUuc2V0KHRpbWVvdXQsIHJlamVjdCk7XFxuXFx0XFx0XFx0fSk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aHJvdHRsZWQuYWJvcnQgPSAoKSA9PiB7XFxuXFx0XFx0XFx0Zm9yIChjb25zdCB0aW1lb3V0IG9mIHF1ZXVlLmtleXMoKSkge1xcblxcdFxcdFxcdFxcdGNsZWFyVGltZW91dCh0aW1lb3V0KTtcXG5cXHRcXHRcXHRcXHRxdWV1ZS5nZXQodGltZW91dCkobmV3IEFib3J0RXJyb3IoKSk7XFxuXFx0XFx0XFx0fVxcblxcblxcdFxcdFxcdHF1ZXVlLmNsZWFyKCk7XFxuXFx0XFx0XFx0c3RyaWN0VGlja3Muc3BsaWNlKDAsIHN0cmljdFRpY2tzLmxlbmd0aCk7XFxuXFx0XFx0fTtcXG5cXG5cXHRcXHR0aHJvdHRsZWQuaXNFbmFibGVkID0gdHJ1ZTtcXG5cXG5cXHRcXHRyZXR1cm4gdGhyb3R0bGVkO1xcblxcdH07XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IHBUaHJvdHRsZTtcXG5tb2R1bGUuZXhwb3J0cy5BYm9ydEVycm9yID0gQWJvcnRFcnJvcjtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9wLXRocm90dGxlL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9mb3JtYXRzLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUpID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIHJlcGxhY2UgPSBTdHJpbmcucHJvdG90eXBlLnJlcGxhY2U7XFxudmFyIHBlcmNlbnRUd2VudGllcyA9IC8lMjAvZztcXG5cXG52YXIgRm9ybWF0ID0ge1xcbiAgICBSRkMxNzM4OiAnUkZDMTczOCcsXFxuICAgIFJGQzM5ODY6ICdSRkMzOTg2J1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgICdkZWZhdWx0JzogRm9ybWF0LlJGQzM5ODYsXFxuICAgIGZvcm1hdHRlcnM6IHtcXG4gICAgICAgIFJGQzE3Mzg6IGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIHJldHVybiByZXBsYWNlLmNhbGwodmFsdWUsIHBlcmNlbnRUd2VudGllcywgJysnKTtcXG4gICAgICAgIH0sXFxuICAgICAgICBSRkMzOTg2OiBmdW5jdGlvbiAodmFsdWUpIHtcXG4gICAgICAgICAgICByZXR1cm4gU3RyaW5nKHZhbHVlKTtcXG4gICAgICAgIH1cXG4gICAgfSxcXG4gICAgUkZDMTczODogRm9ybWF0LlJGQzE3MzgsXFxuICAgIFJGQzM5ODY6IEZvcm1hdC5SRkMzOTg2XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvcXMvbGliL2luZGV4LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciBzdHJpbmdpZnkgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N0cmluZ2lmeSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9zdHJpbmdpZnkuanNcXFwiKTtcXG52YXIgcGFyc2UgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3BhcnNlICovIFxcXCIuLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzXFxcIik7XFxudmFyIGZvcm1hdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zvcm1hdHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qc1xcXCIpO1xcblxcbm1vZHVsZS5leHBvcnRzID0ge1xcbiAgICBmb3JtYXRzOiBmb3JtYXRzLFxcbiAgICBwYXJzZTogcGFyc2UsXFxuICAgIHN0cmluZ2lmeTogc3RyaW5naWZ5XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4uL25vZGVfbW9kdWxlcy9xcy9saWIvaW5kZXguanM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuLi9ub2RlX21vZHVsZXMvcXMvbGliL3BhcnNlLmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzXFxcIik7XFxuXFxudmFyIGhhcyA9IE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHk7XFxudmFyIGlzQXJyYXkgPSBBcnJheS5pc0FycmF5O1xcblxcbnZhciBkZWZhdWx0cyA9IHtcXG4gICAgYWxsb3dEb3RzOiBmYWxzZSxcXG4gICAgYWxsb3dQcm90b3R5cGVzOiBmYWxzZSxcXG4gICAgYWxsb3dTcGFyc2U6IGZhbHNlLFxcbiAgICBhcnJheUxpbWl0OiAyMCxcXG4gICAgY2hhcnNldDogJ3V0Zi04JyxcXG4gICAgY2hhcnNldFNlbnRpbmVsOiBmYWxzZSxcXG4gICAgY29tbWE6IGZhbHNlLFxcbiAgICBkZWNvZGVyOiB1dGlscy5kZWNvZGUsXFxuICAgIGRlbGltaXRlcjogJyYnLFxcbiAgICBkZXB0aDogNSxcXG4gICAgaWdub3JlUXVlcnlQcmVmaXg6IGZhbHNlLFxcbiAgICBpbnRlcnByZXROdW1lcmljRW50aXRpZXM6IGZhbHNlLFxcbiAgICBwYXJhbWV0ZXJMaW1pdDogMTAwMCxcXG4gICAgcGFyc2VBcnJheXM6IHRydWUsXFxuICAgIHBsYWluT2JqZWN0czogZmFsc2UsXFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2VcXG59O1xcblxcbnZhciBpbnRlcnByZXROdW1lcmljRW50aXRpZXMgPSBmdW5jdGlvbiAoc3RyKSB7XFxuICAgIHJldHVybiBzdHIucmVwbGFjZSgvJiMoXFxcXGQrKTsvZywgZnVuY3Rpb24gKCQwLCBudW1iZXJTdHIpIHtcXG4gICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KG51bWJlclN0ciwgMTApKTtcXG4gICAgfSk7XFxufTtcXG5cXG52YXIgcGFyc2VBcnJheVZhbHVlID0gZnVuY3Rpb24gKHZhbCwgb3B0aW9ucykge1xcbiAgICBpZiAodmFsICYmIHR5cGVvZiB2YWwgPT09ICdzdHJpbmcnICYmIG9wdGlvbnMuY29tbWEgJiYgdmFsLmluZGV4T2YoJywnKSA+IC0xKSB7XFxuICAgICAgICByZXR1cm4gdmFsLnNwbGl0KCcsJyk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHZhbDtcXG59O1xcblxcbi8vIFRoaXMgaXMgd2hhdCBicm93c2VycyB3aWxsIHN1Ym1pdCB3aGVuIHRoZSDinJMgY2hhcmFjdGVyIG9jY3VycyBpbiBhblxcbi8vIGFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZCBib2R5IGFuZCB0aGUgZW5jb2Rpbmcgb2YgdGhlIHBhZ2UgY29udGFpbmluZ1xcbi8vIHRoZSBmb3JtIGlzIGlzby04ODU5LTEsIG9yIHdoZW4gdGhlIHN1Ym1pdHRlZCBmb3JtIGhhcyBhbiBhY2NlcHQtY2hhcnNldFxcbi8vIGF0dHJpYnV0ZSBvZiBpc28tODg1OS0xLiBQcmVzdW1hYmx5IGFsc28gd2l0aCBvdGhlciBjaGFyc2V0cyB0aGF0IGRvIG5vdCBjb250YWluXFxuLy8gdGhlIOKckyBjaGFyYWN0ZXIsIHN1Y2ggYXMgdXMtYXNjaWkuXFxudmFyIGlzb1NlbnRpbmVsID0gJ3V0Zjg9JTI2JTIzMTAwMDMlM0InOyAvLyBlbmNvZGVVUklDb21wb25lbnQoJyYjMTAwMDM7JylcXG5cXG4vLyBUaGVzZSBhcmUgdGhlIHBlcmNlbnQtZW5jb2RlZCB1dGYtOCBvY3RldHMgcmVwcmVzZW50aW5nIGEgY2hlY2ttYXJrLCBpbmRpY2F0aW5nIHRoYXQgdGhlIHJlcXVlc3QgYWN0dWFsbHkgaXMgdXRmLTggZW5jb2RlZC5cXG52YXIgY2hhcnNldFNlbnRpbmVsID0gJ3V0Zjg9JUUyJTlDJTkzJzsgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCfinJMnKVxcblxcbnZhciBwYXJzZVZhbHVlcyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdWYWx1ZXMoc3RyLCBvcHRpb25zKSB7XFxuICAgIHZhciBvYmogPSB7fTtcXG4gICAgdmFyIGNsZWFuU3RyID0gb3B0aW9ucy5pZ25vcmVRdWVyeVByZWZpeCA/IHN0ci5yZXBsYWNlKC9eXFxcXD8vLCAnJykgOiBzdHI7XFxuICAgIHZhciBsaW1pdCA9IG9wdGlvbnMucGFyYW1ldGVyTGltaXQgPT09IEluZmluaXR5ID8gdW5kZWZpbmVkIDogb3B0aW9ucy5wYXJhbWV0ZXJMaW1pdDtcXG4gICAgdmFyIHBhcnRzID0gY2xlYW5TdHIuc3BsaXQob3B0aW9ucy5kZWxpbWl0ZXIsIGxpbWl0KTtcXG4gICAgdmFyIHNraXBJbmRleCA9IC0xOyAvLyBLZWVwIHRyYWNrIG9mIHdoZXJlIHRoZSB1dGY4IHNlbnRpbmVsIHdhcyBmb3VuZFxcbiAgICB2YXIgaTtcXG5cXG4gICAgdmFyIGNoYXJzZXQgPSBvcHRpb25zLmNoYXJzZXQ7XFxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgaWYgKHBhcnRzW2ldLmluZGV4T2YoJ3V0Zjg9JykgPT09IDApIHtcXG4gICAgICAgICAgICAgICAgaWYgKHBhcnRzW2ldID09PSBjaGFyc2V0U2VudGluZWwpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNoYXJzZXQgPSAndXRmLTgnO1xcbiAgICAgICAgICAgICAgICB9IGVsc2UgaWYgKHBhcnRzW2ldID09PSBpc29TZW50aW5lbCkge1xcbiAgICAgICAgICAgICAgICAgICAgY2hhcnNldCA9ICdpc28tODg1OS0xJztcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgICAgICBza2lwSW5kZXggPSBpO1xcbiAgICAgICAgICAgICAgICBpID0gcGFydHMubGVuZ3RoOyAvLyBUaGUgZXNsaW50IHNldHRpbmdzIGRvIG5vdCBhbGxvdyBicmVhaztcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgZm9yIChpID0gMDsgaSA8IHBhcnRzLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICBpZiAoaSA9PT0gc2tpcEluZGV4KSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2ldO1xcblxcbiAgICAgICAgdmFyIGJyYWNrZXRFcXVhbHNQb3MgPSBwYXJ0LmluZGV4T2YoJ109Jyk7XFxuICAgICAgICB2YXIgcG9zID0gYnJhY2tldEVxdWFsc1BvcyA9PT0gLTEgPyBwYXJ0LmluZGV4T2YoJz0nKSA6IGJyYWNrZXRFcXVhbHNQb3MgKyAxO1xcblxcbiAgICAgICAgdmFyIGtleSwgdmFsO1xcbiAgICAgICAgaWYgKHBvcyA9PT0gLTEpIHtcXG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ2tleScpO1xcbiAgICAgICAgICAgIHZhbCA9IG9wdGlvbnMuc3RyaWN0TnVsbEhhbmRsaW5nID8gbnVsbCA6ICcnO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBrZXkgPSBvcHRpb25zLmRlY29kZXIocGFydC5zbGljZSgwLCBwb3MpLCBkZWZhdWx0cy5kZWNvZGVyLCBjaGFyc2V0LCAna2V5Jyk7XFxuICAgICAgICAgICAgdmFsID0gdXRpbHMubWF5YmVNYXAoXFxuICAgICAgICAgICAgICAgIHBhcnNlQXJyYXlWYWx1ZShwYXJ0LnNsaWNlKHBvcyArIDEpLCBvcHRpb25zKSxcXG4gICAgICAgICAgICAgICAgZnVuY3Rpb24gKGVuY29kZWRWYWwpIHtcXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBvcHRpb25zLmRlY29kZXIoZW5jb2RlZFZhbCwgZGVmYXVsdHMuZGVjb2RlciwgY2hhcnNldCwgJ3ZhbHVlJyk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICApO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaWYgKHZhbCAmJiBvcHRpb25zLmludGVycHJldE51bWVyaWNFbnRpdGllcyAmJiBjaGFyc2V0ID09PSAnaXNvLTg4NTktMScpIHtcXG4gICAgICAgICAgICB2YWwgPSBpbnRlcnByZXROdW1lcmljRW50aXRpZXModmFsKTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChwYXJ0LmluZGV4T2YoJ1tdPScpID4gLTEpIHtcXG4gICAgICAgICAgICB2YWwgPSBpc0FycmF5KHZhbCkgPyBbdmFsXSA6IHZhbDtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChoYXMuY2FsbChvYmosIGtleSkpIHtcXG4gICAgICAgICAgICBvYmpba2V5XSA9IHV0aWxzLmNvbWJpbmUob2JqW2tleV0sIHZhbCk7XFxuICAgICAgICB9IGVsc2Uge1xcbiAgICAgICAgICAgIG9ialtrZXldID0gdmFsO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBvYmo7XFxufTtcXG5cXG52YXIgcGFyc2VPYmplY3QgPSBmdW5jdGlvbiAoY2hhaW4sIHZhbCwgb3B0aW9ucywgdmFsdWVzUGFyc2VkKSB7XFxuICAgIHZhciBsZWFmID0gdmFsdWVzUGFyc2VkID8gdmFsIDogcGFyc2VBcnJheVZhbHVlKHZhbCwgb3B0aW9ucyk7XFxuXFxuICAgIGZvciAodmFyIGkgPSBjaGFpbi5sZW5ndGggLSAxOyBpID49IDA7IC0taSkge1xcbiAgICAgICAgdmFyIG9iajtcXG4gICAgICAgIHZhciByb290ID0gY2hhaW5baV07XFxuXFxuICAgICAgICBpZiAocm9vdCA9PT0gJ1tdJyAmJiBvcHRpb25zLnBhcnNlQXJyYXlzKSB7XFxuICAgICAgICAgICAgb2JqID0gW10uY29uY2F0KGxlYWYpO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICBvYmogPSBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcXG4gICAgICAgICAgICB2YXIgY2xlYW5Sb290ID0gcm9vdC5jaGFyQXQoMCkgPT09ICdbJyAmJiByb290LmNoYXJBdChyb290Lmxlbmd0aCAtIDEpID09PSAnXScgPyByb290LnNsaWNlKDEsIC0xKSA6IHJvb3Q7XFxuICAgICAgICAgICAgdmFyIGluZGV4ID0gcGFyc2VJbnQoY2xlYW5Sb290LCAxMCk7XFxuICAgICAgICAgICAgaWYgKCFvcHRpb25zLnBhcnNlQXJyYXlzICYmIGNsZWFuUm9vdCA9PT0gJycpIHtcXG4gICAgICAgICAgICAgICAgb2JqID0geyAwOiBsZWFmIH07XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChcXG4gICAgICAgICAgICAgICAgIWlzTmFOKGluZGV4KVxcbiAgICAgICAgICAgICAgICAmJiByb290ICE9PSBjbGVhblJvb3RcXG4gICAgICAgICAgICAgICAgJiYgU3RyaW5nKGluZGV4KSA9PT0gY2xlYW5Sb290XFxuICAgICAgICAgICAgICAgICYmIGluZGV4ID49IDBcXG4gICAgICAgICAgICAgICAgJiYgKG9wdGlvbnMucGFyc2VBcnJheXMgJiYgaW5kZXggPD0gb3B0aW9ucy5hcnJheUxpbWl0KVxcbiAgICAgICAgICAgICkge1xcbiAgICAgICAgICAgICAgICBvYmogPSBbXTtcXG4gICAgICAgICAgICAgICAgb2JqW2luZGV4XSA9IGxlYWY7XFxuICAgICAgICAgICAgfSBlbHNlIGlmIChjbGVhblJvb3QgIT09ICdfX3Byb3RvX18nKSB7XFxuICAgICAgICAgICAgICAgIG9ialtjbGVhblJvb3RdID0gbGVhZjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBsZWFmID0gb2JqO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBsZWFmO1xcbn07XFxuXFxudmFyIHBhcnNlS2V5cyA9IGZ1bmN0aW9uIHBhcnNlUXVlcnlTdHJpbmdLZXlzKGdpdmVuS2V5LCB2YWwsIG9wdGlvbnMsIHZhbHVlc1BhcnNlZCkge1xcbiAgICBpZiAoIWdpdmVuS2V5KSB7XFxuICAgICAgICByZXR1cm47XFxuICAgIH1cXG5cXG4gICAgLy8gVHJhbnNmb3JtIGRvdCBub3RhdGlvbiB0byBicmFja2V0IG5vdGF0aW9uXFxuICAgIHZhciBrZXkgPSBvcHRpb25zLmFsbG93RG90cyA/IGdpdmVuS2V5LnJlcGxhY2UoL1xcXFwuKFteLltdKykvZywgJ1skMV0nKSA6IGdpdmVuS2V5O1xcblxcbiAgICAvLyBUaGUgcmVnZXggY2h1bmtzXFxuXFxuICAgIHZhciBicmFja2V0cyA9IC8oXFxcXFtbXltcXFxcXV0qXSkvO1xcbiAgICB2YXIgY2hpbGQgPSAvKFxcXFxbW15bXFxcXF1dKl0pL2c7XFxuXFxuICAgIC8vIEdldCB0aGUgcGFyZW50XFxuXFxuICAgIHZhciBzZWdtZW50ID0gb3B0aW9ucy5kZXB0aCA+IDAgJiYgYnJhY2tldHMuZXhlYyhrZXkpO1xcbiAgICB2YXIgcGFyZW50ID0gc2VnbWVudCA/IGtleS5zbGljZSgwLCBzZWdtZW50LmluZGV4KSA6IGtleTtcXG5cXG4gICAgLy8gU3Rhc2ggdGhlIHBhcmVudCBpZiBpdCBleGlzdHNcXG5cXG4gICAgdmFyIGtleXMgPSBbXTtcXG4gICAgaWYgKHBhcmVudCkge1xcbiAgICAgICAgLy8gSWYgd2UgYXJlbid0IHVzaW5nIHBsYWluIG9iamVjdHMsIG9wdGlvbmFsbHkgcHJlZml4IGtleXMgdGhhdCB3b3VsZCBvdmVyd3JpdGUgb2JqZWN0IHByb3RvdHlwZSBwcm9wZXJ0aWVzXFxuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHBhcmVudCkpIHtcXG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMuYWxsb3dQcm90b3R5cGVzKSB7XFxuICAgICAgICAgICAgICAgIHJldHVybjtcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuXFxuICAgICAgICBrZXlzLnB1c2gocGFyZW50KTtcXG4gICAgfVxcblxcbiAgICAvLyBMb29wIHRocm91Z2ggY2hpbGRyZW4gYXBwZW5kaW5nIHRvIHRoZSBhcnJheSB1bnRpbCB3ZSBoaXQgZGVwdGhcXG5cXG4gICAgdmFyIGkgPSAwO1xcbiAgICB3aGlsZSAob3B0aW9ucy5kZXB0aCA+IDAgJiYgKHNlZ21lbnQgPSBjaGlsZC5leGVjKGtleSkpICE9PSBudWxsICYmIGkgPCBvcHRpb25zLmRlcHRoKSB7XFxuICAgICAgICBpICs9IDE7XFxuICAgICAgICBpZiAoIW9wdGlvbnMucGxhaW5PYmplY3RzICYmIGhhcy5jYWxsKE9iamVjdC5wcm90b3R5cGUsIHNlZ21lbnRbMV0uc2xpY2UoMSwgLTEpKSkge1xcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgICAgIGtleXMucHVzaChzZWdtZW50WzFdKTtcXG4gICAgfVxcblxcbiAgICAvLyBJZiB0aGVyZSdzIGEgcmVtYWluZGVyLCBqdXN0IGFkZCB3aGF0ZXZlciBpcyBsZWZ0XFxuXFxuICAgIGlmIChzZWdtZW50KSB7XFxuICAgICAgICBrZXlzLnB1c2goJ1snICsga2V5LnNsaWNlKHNlZ21lbnQuaW5kZXgpICsgJ10nKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gcGFyc2VPYmplY3Qoa2V5cywgdmFsLCBvcHRpb25zLCB2YWx1ZXNQYXJzZWQpO1xcbn07XFxuXFxudmFyIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyA9IGZ1bmN0aW9uIG5vcm1hbGl6ZVBhcnNlT3B0aW9ucyhvcHRzKSB7XFxuICAgIGlmICghb3B0cykge1xcbiAgICAgICAgcmV0dXJuIGRlZmF1bHRzO1xcbiAgICB9XFxuXFxuICAgIGlmIChvcHRzLmRlY29kZXIgIT09IG51bGwgJiYgb3B0cy5kZWNvZGVyICE9PSB1bmRlZmluZWQgJiYgdHlwZW9mIG9wdHMuZGVjb2RlciAhPT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRGVjb2RlciBoYXMgdG8gYmUgYSBmdW5jdGlvbi4nKTtcXG4gICAgfVxcblxcbiAgICBpZiAodHlwZW9mIG9wdHMuY2hhcnNldCAhPT0gJ3VuZGVmaW5lZCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAndXRmLTgnICYmIG9wdHMuY2hhcnNldCAhPT0gJ2lzby04ODU5LTEnKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdUaGUgY2hhcnNldCBvcHRpb24gbXVzdCBiZSBlaXRoZXIgdXRmLTgsIGlzby04ODU5LTEsIG9yIHVuZGVmaW5lZCcpO1xcbiAgICB9XFxuICAgIHZhciBjaGFyc2V0ID0gdHlwZW9mIG9wdHMuY2hhcnNldCA9PT0gJ3VuZGVmaW5lZCcgPyBkZWZhdWx0cy5jaGFyc2V0IDogb3B0cy5jaGFyc2V0O1xcblxcbiAgICByZXR1cm4ge1xcbiAgICAgICAgYWxsb3dEb3RzOiB0eXBlb2Ygb3B0cy5hbGxvd0RvdHMgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuYWxsb3dEb3RzIDogISFvcHRzLmFsbG93RG90cyxcXG4gICAgICAgIGFsbG93UHJvdG90eXBlczogdHlwZW9mIG9wdHMuYWxsb3dQcm90b3R5cGVzID09PSAnYm9vbGVhbicgPyBvcHRzLmFsbG93UHJvdG90eXBlcyA6IGRlZmF1bHRzLmFsbG93UHJvdG90eXBlcyxcXG4gICAgICAgIGFsbG93U3BhcnNlOiB0eXBlb2Ygb3B0cy5hbGxvd1NwYXJzZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5hbGxvd1NwYXJzZSA6IGRlZmF1bHRzLmFsbG93U3BhcnNlLFxcbiAgICAgICAgYXJyYXlMaW1pdDogdHlwZW9mIG9wdHMuYXJyYXlMaW1pdCA9PT0gJ251bWJlcicgPyBvcHRzLmFycmF5TGltaXQgOiBkZWZhdWx0cy5hcnJheUxpbWl0LFxcbiAgICAgICAgY2hhcnNldDogY2hhcnNldCxcXG4gICAgICAgIGNoYXJzZXRTZW50aW5lbDogdHlwZW9mIG9wdHMuY2hhcnNldFNlbnRpbmVsID09PSAnYm9vbGVhbicgPyBvcHRzLmNoYXJzZXRTZW50aW5lbCA6IGRlZmF1bHRzLmNoYXJzZXRTZW50aW5lbCxcXG4gICAgICAgIGNvbW1hOiB0eXBlb2Ygb3B0cy5jb21tYSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5jb21tYSA6IGRlZmF1bHRzLmNvbW1hLFxcbiAgICAgICAgZGVjb2RlcjogdHlwZW9mIG9wdHMuZGVjb2RlciA9PT0gJ2Z1bmN0aW9uJyA/IG9wdHMuZGVjb2RlciA6IGRlZmF1bHRzLmRlY29kZXIsXFxuICAgICAgICBkZWxpbWl0ZXI6IHR5cGVvZiBvcHRzLmRlbGltaXRlciA9PT0gJ3N0cmluZycgfHwgdXRpbHMuaXNSZWdFeHAob3B0cy5kZWxpbWl0ZXIpID8gb3B0cy5kZWxpbWl0ZXIgOiBkZWZhdWx0cy5kZWxpbWl0ZXIsXFxuICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8taW1wbGljaXQtY29lcmNpb24sIG5vLWV4dHJhLXBhcmVuc1xcbiAgICAgICAgZGVwdGg6ICh0eXBlb2Ygb3B0cy5kZXB0aCA9PT0gJ251bWJlcicgfHwgb3B0cy5kZXB0aCA9PT0gZmFsc2UpID8gK29wdHMuZGVwdGggOiBkZWZhdWx0cy5kZXB0aCxcXG4gICAgICAgIGlnbm9yZVF1ZXJ5UHJlZml4OiBvcHRzLmlnbm9yZVF1ZXJ5UHJlZml4ID09PSB0cnVlLFxcbiAgICAgICAgaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzOiB0eXBlb2Ygb3B0cy5pbnRlcnByZXROdW1lcmljRW50aXRpZXMgPT09ICdib29sZWFuJyA/IG9wdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzIDogZGVmYXVsdHMuaW50ZXJwcmV0TnVtZXJpY0VudGl0aWVzLFxcbiAgICAgICAgcGFyYW1ldGVyTGltaXQ6IHR5cGVvZiBvcHRzLnBhcmFtZXRlckxpbWl0ID09PSAnbnVtYmVyJyA/IG9wdHMucGFyYW1ldGVyTGltaXQgOiBkZWZhdWx0cy5wYXJhbWV0ZXJMaW1pdCxcXG4gICAgICAgIHBhcnNlQXJyYXlzOiBvcHRzLnBhcnNlQXJyYXlzICE9PSBmYWxzZSxcXG4gICAgICAgIHBsYWluT2JqZWN0czogdHlwZW9mIG9wdHMucGxhaW5PYmplY3RzID09PSAnYm9vbGVhbicgPyBvcHRzLnBsYWluT2JqZWN0cyA6IGRlZmF1bHRzLnBsYWluT2JqZWN0cyxcXG4gICAgICAgIHN0cmljdE51bGxIYW5kbGluZzogdHlwZW9mIG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nID09PSAnYm9vbGVhbicgPyBvcHRzLnN0cmljdE51bGxIYW5kbGluZyA6IGRlZmF1bHRzLnN0cmljdE51bGxIYW5kbGluZ1xcbiAgICB9O1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiAoc3RyLCBvcHRzKSB7XFxuICAgIHZhciBvcHRpb25zID0gbm9ybWFsaXplUGFyc2VPcHRpb25zKG9wdHMpO1xcblxcbiAgICBpZiAoc3RyID09PSAnJyB8fCBzdHIgPT09IG51bGwgfHwgdHlwZW9mIHN0ciA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcXG4gICAgfVxcblxcbiAgICB2YXIgdGVtcE9iaiA9IHR5cGVvZiBzdHIgPT09ICdzdHJpbmcnID8gcGFyc2VWYWx1ZXMoc3RyLCBvcHRpb25zKSA6IHN0cjtcXG4gICAgdmFyIG9iaiA9IG9wdGlvbnMucGxhaW5PYmplY3RzID8gT2JqZWN0LmNyZWF0ZShudWxsKSA6IHt9O1xcblxcbiAgICAvLyBJdGVyYXRlIG92ZXIgdGhlIGtleXMgYW5kIHNldHVwIHRoZSBuZXcgb2JqZWN0XFxuXFxuICAgIHZhciBrZXlzID0gT2JqZWN0LmtleXModGVtcE9iaik7XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwga2V5cy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGtleSA9IGtleXNbaV07XFxuICAgICAgICB2YXIgbmV3T2JqID0gcGFyc2VLZXlzKGtleSwgdGVtcE9ialtrZXldLCBvcHRpb25zLCB0eXBlb2Ygc3RyID09PSAnc3RyaW5nJyk7XFxuICAgICAgICBvYmogPSB1dGlscy5tZXJnZShvYmosIG5ld09iaiwgb3B0aW9ucyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdGlvbnMuYWxsb3dTcGFyc2UgPT09IHRydWUpIHtcXG4gICAgICAgIHJldHVybiBvYmo7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIHV0aWxzLmNvbXBhY3Qob2JqKTtcXG59O1xcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi4vbm9kZV9tb2R1bGVzL3FzL2xpYi9wYXJzZS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9xcy9saWIvc3RyaW5naWZ5LmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChtb2R1bGUsIF9fdW51c2VkX3dlYnBhY2tfZXhwb3J0cywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJcXG5cXG52YXIgZ2V0U2lkZUNoYW5uZWwgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBzaWRlLWNoYW5uZWwgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwvaW5kZXguanNcXFwiKTtcXG52YXIgdXRpbHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzXFxcIik7XFxudmFyIGZvcm1hdHMgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2Zvcm1hdHMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvZm9ybWF0cy5qc1xcXCIpO1xcbnZhciBoYXMgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xcblxcbnZhciBhcnJheVByZWZpeEdlbmVyYXRvcnMgPSB7XFxuICAgIGJyYWNrZXRzOiBmdW5jdGlvbiBicmFja2V0cyhwcmVmaXgpIHtcXG4gICAgICAgIHJldHVybiBwcmVmaXggKyAnW10nO1xcbiAgICB9LFxcbiAgICBjb21tYTogJ2NvbW1hJyxcXG4gICAgaW5kaWNlczogZnVuY3Rpb24gaW5kaWNlcyhwcmVmaXgsIGtleSkge1xcbiAgICAgICAgcmV0dXJuIHByZWZpeCArICdbJyArIGtleSArICddJztcXG4gICAgfSxcXG4gICAgcmVwZWF0OiBmdW5jdGlvbiByZXBlYXQocHJlZml4KSB7XFxuICAgICAgICByZXR1cm4gcHJlZml4O1xcbiAgICB9XFxufTtcXG5cXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XFxudmFyIHNwbGl0ID0gU3RyaW5nLnByb3RvdHlwZS5zcGxpdDtcXG52YXIgcHVzaCA9IEFycmF5LnByb3RvdHlwZS5wdXNoO1xcbnZhciBwdXNoVG9BcnJheSA9IGZ1bmN0aW9uIChhcnIsIHZhbHVlT3JBcnJheSkge1xcbiAgICBwdXNoLmFwcGx5KGFyciwgaXNBcnJheSh2YWx1ZU9yQXJyYXkpID8gdmFsdWVPckFycmF5IDogW3ZhbHVlT3JBcnJheV0pO1xcbn07XFxuXFxudmFyIHRvSVNPID0gRGF0ZS5wcm90b3R5cGUudG9JU09TdHJpbmc7XFxuXFxudmFyIGRlZmF1bHRGb3JtYXQgPSBmb3JtYXRzWydkZWZhdWx0J107XFxudmFyIGRlZmF1bHRzID0ge1xcbiAgICBhZGRRdWVyeVByZWZpeDogZmFsc2UsXFxuICAgIGFsbG93RG90czogZmFsc2UsXFxuICAgIGNoYXJzZXQ6ICd1dGYtOCcsXFxuICAgIGNoYXJzZXRTZW50aW5lbDogZmFsc2UsXFxuICAgIGRlbGltaXRlcjogJyYnLFxcbiAgICBlbmNvZGU6IHRydWUsXFxuICAgIGVuY29kZXI6IHV0aWxzLmVuY29kZSxcXG4gICAgZW5jb2RlVmFsdWVzT25seTogZmFsc2UsXFxuICAgIGZvcm1hdDogZGVmYXVsdEZvcm1hdCxcXG4gICAgZm9ybWF0dGVyOiBmb3JtYXRzLmZvcm1hdHRlcnNbZGVmYXVsdEZvcm1hdF0sXFxuICAgIC8vIGRlcHJlY2F0ZWRcXG4gICAgaW5kaWNlczogZmFsc2UsXFxuICAgIHNlcmlhbGl6ZURhdGU6IGZ1bmN0aW9uIHNlcmlhbGl6ZURhdGUoZGF0ZSkge1xcbiAgICAgICAgcmV0dXJuIHRvSVNPLmNhbGwoZGF0ZSk7XFxuICAgIH0sXFxuICAgIHNraXBOdWxsczogZmFsc2UsXFxuICAgIHN0cmljdE51bGxIYW5kbGluZzogZmFsc2VcXG59O1xcblxcbnZhciBpc05vbk51bGxpc2hQcmltaXRpdmUgPSBmdW5jdGlvbiBpc05vbk51bGxpc2hQcmltaXRpdmUodikge1xcbiAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdzdHJpbmcnXFxuICAgICAgICB8fCB0eXBlb2YgdiA9PT0gJ251bWJlcidcXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnYm9vbGVhbidcXG4gICAgICAgIHx8IHR5cGVvZiB2ID09PSAnc3ltYm9sJ1xcbiAgICAgICAgfHwgdHlwZW9mIHYgPT09ICdiaWdpbnQnO1xcbn07XFxuXFxudmFyIHNlbnRpbmVsID0ge307XFxuXFxudmFyIHN0cmluZ2lmeSA9IGZ1bmN0aW9uIHN0cmluZ2lmeShcXG4gICAgb2JqZWN0LFxcbiAgICBwcmVmaXgsXFxuICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXFxuICAgIGNvbW1hUm91bmRUcmlwLFxcbiAgICBzdHJpY3ROdWxsSGFuZGxpbmcsXFxuICAgIHNraXBOdWxscyxcXG4gICAgZW5jb2RlcixcXG4gICAgZmlsdGVyLFxcbiAgICBzb3J0LFxcbiAgICBhbGxvd0RvdHMsXFxuICAgIHNlcmlhbGl6ZURhdGUsXFxuICAgIGZvcm1hdCxcXG4gICAgZm9ybWF0dGVyLFxcbiAgICBlbmNvZGVWYWx1ZXNPbmx5LFxcbiAgICBjaGFyc2V0LFxcbiAgICBzaWRlQ2hhbm5lbFxcbikge1xcbiAgICB2YXIgb2JqID0gb2JqZWN0O1xcblxcbiAgICB2YXIgdG1wU2MgPSBzaWRlQ2hhbm5lbDtcXG4gICAgdmFyIHN0ZXAgPSAwO1xcbiAgICB2YXIgZmluZEZsYWcgPSBmYWxzZTtcXG4gICAgd2hpbGUgKCh0bXBTYyA9IHRtcFNjLmdldChzZW50aW5lbCkpICE9PSB2b2lkIHVuZGVmaW5lZCAmJiAhZmluZEZsYWcpIHtcXG4gICAgICAgIC8vIFdoZXJlIG9iamVjdCBsYXN0IGFwcGVhcmVkIGluIHRoZSByZWYgdHJlZVxcbiAgICAgICAgdmFyIHBvcyA9IHRtcFNjLmdldChvYmplY3QpO1xcbiAgICAgICAgc3RlcCArPSAxO1xcbiAgICAgICAgaWYgKHR5cGVvZiBwb3MgIT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgaWYgKHBvcyA9PT0gc3RlcCkge1xcbiAgICAgICAgICAgICAgICB0aHJvdyBuZXcgUmFuZ2VFcnJvcignQ3ljbGljIG9iamVjdCB2YWx1ZScpO1xcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIGZpbmRGbGFnID0gdHJ1ZTsgLy8gQnJlYWsgd2hpbGVcXG4gICAgICAgICAgICB9XFxuICAgICAgICB9XFxuICAgICAgICBpZiAodHlwZW9mIHRtcFNjLmdldChzZW50aW5lbCkgPT09ICd1bmRlZmluZWQnKSB7XFxuICAgICAgICAgICAgc3RlcCA9IDA7XFxuICAgICAgICB9XFxuICAgIH1cXG5cXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXIgPT09ICdmdW5jdGlvbicpIHtcXG4gICAgICAgIG9iaiA9IGZpbHRlcihwcmVmaXgsIG9iaik7XFxuICAgIH0gZWxzZSBpZiAob2JqIGluc3RhbmNlb2YgRGF0ZSkge1xcbiAgICAgICAgb2JqID0gc2VyaWFsaXplRGF0ZShvYmopO1xcbiAgICB9IGVsc2UgaWYgKGdlbmVyYXRlQXJyYXlQcmVmaXggPT09ICdjb21tYScgJiYgaXNBcnJheShvYmopKSB7XFxuICAgICAgICBvYmogPSB1dGlscy5tYXliZU1hcChvYmosIGZ1bmN0aW9uICh2YWx1ZSkge1xcbiAgICAgICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIERhdGUpIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHNlcmlhbGl6ZURhdGUodmFsdWUpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gdmFsdWU7XFxuICAgICAgICB9KTtcXG4gICAgfVxcblxcbiAgICBpZiAob2JqID09PSBudWxsKSB7XFxuICAgICAgICBpZiAoc3RyaWN0TnVsbEhhbmRsaW5nKSB7XFxuICAgICAgICAgICAgcmV0dXJuIGVuY29kZXIgJiYgIWVuY29kZVZhbHVlc09ubHkgPyBlbmNvZGVyKHByZWZpeCwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ2tleScsIGZvcm1hdCkgOiBwcmVmaXg7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBvYmogPSAnJztcXG4gICAgfVxcblxcbiAgICBpZiAoaXNOb25OdWxsaXNoUHJpbWl0aXZlKG9iaikgfHwgdXRpbHMuaXNCdWZmZXIob2JqKSkge1xcbiAgICAgICAgaWYgKGVuY29kZXIpIHtcXG4gICAgICAgICAgICB2YXIga2V5VmFsdWUgPSBlbmNvZGVWYWx1ZXNPbmx5ID8gcHJlZml4IDogZW5jb2RlcihwcmVmaXgsIGRlZmF1bHRzLmVuY29kZXIsIGNoYXJzZXQsICdrZXknLCBmb3JtYXQpO1xcbiAgICAgICAgICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGVuY29kZVZhbHVlc09ubHkpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlc0FycmF5ID0gc3BsaXQuY2FsbChTdHJpbmcob2JqKSwgJywnKTtcXG4gICAgICAgICAgICAgICAgdmFyIHZhbHVlc0pvaW5lZCA9ICcnO1xcbiAgICAgICAgICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHZhbHVlc0FycmF5Lmxlbmd0aDsgKytpKSB7XFxuICAgICAgICAgICAgICAgICAgICB2YWx1ZXNKb2luZWQgKz0gKGkgPT09IDAgPyAnJyA6ICcsJykgKyBmb3JtYXR0ZXIoZW5jb2Rlcih2YWx1ZXNBcnJheVtpXSwgZGVmYXVsdHMuZW5jb2RlciwgY2hhcnNldCwgJ3ZhbHVlJywgZm9ybWF0KSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgKGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiB2YWx1ZXNBcnJheS5sZW5ndGggPT09IDEgPyAnW10nIDogJycpICsgJz0nICsgdmFsdWVzSm9pbmVkXTtcXG4gICAgICAgICAgICB9XFxuICAgICAgICAgICAgcmV0dXJuIFtmb3JtYXR0ZXIoa2V5VmFsdWUpICsgJz0nICsgZm9ybWF0dGVyKGVuY29kZXIob2JqLCBkZWZhdWx0cy5lbmNvZGVyLCBjaGFyc2V0LCAndmFsdWUnLCBmb3JtYXQpKV07XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gW2Zvcm1hdHRlcihwcmVmaXgpICsgJz0nICsgZm9ybWF0dGVyKFN0cmluZyhvYmopKV07XFxuICAgIH1cXG5cXG4gICAgdmFyIHZhbHVlcyA9IFtdO1xcblxcbiAgICBpZiAodHlwZW9mIG9iaiA9PT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIHJldHVybiB2YWx1ZXM7XFxuICAgIH1cXG5cXG4gICAgdmFyIG9iaktleXM7XFxuICAgIGlmIChnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIGlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgLy8gd2UgbmVlZCB0byBqb2luIGVsZW1lbnRzIGluXFxuICAgICAgICBvYmpLZXlzID0gW3sgdmFsdWU6IG9iai5sZW5ndGggPiAwID8gb2JqLmpvaW4oJywnKSB8fCBudWxsIDogdm9pZCB1bmRlZmluZWQgfV07XFxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShmaWx0ZXIpKSB7XFxuICAgICAgICBvYmpLZXlzID0gZmlsdGVyO1xcbiAgICB9IGVsc2Uge1xcbiAgICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xcbiAgICAgICAgb2JqS2V5cyA9IHNvcnQgPyBrZXlzLnNvcnQoc29ydCkgOiBrZXlzO1xcbiAgICB9XFxuXFxuICAgIHZhciBhZGp1c3RlZFByZWZpeCA9IGNvbW1hUm91bmRUcmlwICYmIGlzQXJyYXkob2JqKSAmJiBvYmoubGVuZ3RoID09PSAxID8gcHJlZml4ICsgJ1tdJyA6IHByZWZpeDtcXG5cXG4gICAgZm9yICh2YXIgaiA9IDA7IGogPCBvYmpLZXlzLmxlbmd0aDsgKytqKSB7XFxuICAgICAgICB2YXIga2V5ID0gb2JqS2V5c1tqXTtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHR5cGVvZiBrZXkgPT09ICdvYmplY3QnICYmIHR5cGVvZiBrZXkudmFsdWUgIT09ICd1bmRlZmluZWQnID8ga2V5LnZhbHVlIDogb2JqW2tleV07XFxuXFxuICAgICAgICBpZiAoc2tpcE51bGxzICYmIHZhbHVlID09PSBudWxsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICB2YXIga2V5UHJlZml4ID0gaXNBcnJheShvYmopXFxuICAgICAgICAgICAgPyB0eXBlb2YgZ2VuZXJhdGVBcnJheVByZWZpeCA9PT0gJ2Z1bmN0aW9uJyA/IGdlbmVyYXRlQXJyYXlQcmVmaXgoYWRqdXN0ZWRQcmVmaXgsIGtleSkgOiBhZGp1c3RlZFByZWZpeFxcbiAgICAgICAgICAgIDogYWRqdXN0ZWRQcmVmaXggKyAoYWxsb3dEb3RzID8gJy4nICsga2V5IDogJ1snICsga2V5ICsgJ10nKTtcXG5cXG4gICAgICAgIHNpZGVDaGFubmVsLnNldChvYmplY3QsIHN0ZXApO1xcbiAgICAgICAgdmFyIHZhbHVlU2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xcbiAgICAgICAgdmFsdWVTaWRlQ2hhbm5lbC5zZXQoc2VudGluZWwsIHNpZGVDaGFubmVsKTtcXG4gICAgICAgIHB1c2hUb0FycmF5KHZhbHVlcywgc3RyaW5naWZ5KFxcbiAgICAgICAgICAgIHZhbHVlLFxcbiAgICAgICAgICAgIGtleVByZWZpeCxcXG4gICAgICAgICAgICBnZW5lcmF0ZUFycmF5UHJlZml4LFxcbiAgICAgICAgICAgIGNvbW1hUm91bmRUcmlwLFxcbiAgICAgICAgICAgIHN0cmljdE51bGxIYW5kbGluZyxcXG4gICAgICAgICAgICBza2lwTnVsbHMsXFxuICAgICAgICAgICAgZW5jb2RlcixcXG4gICAgICAgICAgICBmaWx0ZXIsXFxuICAgICAgICAgICAgc29ydCxcXG4gICAgICAgICAgICBhbGxvd0RvdHMsXFxuICAgICAgICAgICAgc2VyaWFsaXplRGF0ZSxcXG4gICAgICAgICAgICBmb3JtYXQsXFxuICAgICAgICAgICAgZm9ybWF0dGVyLFxcbiAgICAgICAgICAgIGVuY29kZVZhbHVlc09ubHksXFxuICAgICAgICAgICAgY2hhcnNldCxcXG4gICAgICAgICAgICB2YWx1ZVNpZGVDaGFubmVsXFxuICAgICAgICApKTtcXG4gICAgfVxcblxcbiAgICByZXR1cm4gdmFsdWVzO1xcbn07XFxuXFxudmFyIG5vcm1hbGl6ZVN0cmluZ2lmeU9wdGlvbnMgPSBmdW5jdGlvbiBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpIHtcXG4gICAgaWYgKCFvcHRzKSB7XFxuICAgICAgICByZXR1cm4gZGVmYXVsdHM7XFxuICAgIH1cXG5cXG4gICAgaWYgKG9wdHMuZW5jb2RlciAhPT0gbnVsbCAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAndW5kZWZpbmVkJyAmJiB0eXBlb2Ygb3B0cy5lbmNvZGVyICE9PSAnZnVuY3Rpb24nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFbmNvZGVyIGhhcyB0byBiZSBhIGZ1bmN0aW9uLicpO1xcbiAgICB9XFxuXFxuICAgIHZhciBjaGFyc2V0ID0gb3B0cy5jaGFyc2V0IHx8IGRlZmF1bHRzLmNoYXJzZXQ7XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5jaGFyc2V0ICE9PSAndW5kZWZpbmVkJyAmJiBvcHRzLmNoYXJzZXQgIT09ICd1dGYtOCcgJiYgb3B0cy5jaGFyc2V0ICE9PSAnaXNvLTg4NTktMScpIHtcXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1RoZSBjaGFyc2V0IG9wdGlvbiBtdXN0IGJlIGVpdGhlciB1dGYtOCwgaXNvLTg4NTktMSwgb3IgdW5kZWZpbmVkJyk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGZvcm1hdCA9IGZvcm1hdHNbJ2RlZmF1bHQnXTtcXG4gICAgaWYgKHR5cGVvZiBvcHRzLmZvcm1hdCAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgIGlmICghaGFzLmNhbGwoZm9ybWF0cy5mb3JtYXR0ZXJzLCBvcHRzLmZvcm1hdCkpIHtcXG4gICAgICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIGZvcm1hdCBvcHRpb24gcHJvdmlkZWQuJyk7XFxuICAgICAgICB9XFxuICAgICAgICBmb3JtYXQgPSBvcHRzLmZvcm1hdDtcXG4gICAgfVxcbiAgICB2YXIgZm9ybWF0dGVyID0gZm9ybWF0cy5mb3JtYXR0ZXJzW2Zvcm1hdF07XFxuXFxuICAgIHZhciBmaWx0ZXIgPSBkZWZhdWx0cy5maWx0ZXI7XFxuICAgIGlmICh0eXBlb2Ygb3B0cy5maWx0ZXIgPT09ICdmdW5jdGlvbicgfHwgaXNBcnJheShvcHRzLmZpbHRlcikpIHtcXG4gICAgICAgIGZpbHRlciA9IG9wdHMuZmlsdGVyO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiB7XFxuICAgICAgICBhZGRRdWVyeVByZWZpeDogdHlwZW9mIG9wdHMuYWRkUXVlcnlQcmVmaXggPT09ICdib29sZWFuJyA/IG9wdHMuYWRkUXVlcnlQcmVmaXggOiBkZWZhdWx0cy5hZGRRdWVyeVByZWZpeCxcXG4gICAgICAgIGFsbG93RG90czogdHlwZW9mIG9wdHMuYWxsb3dEb3RzID09PSAndW5kZWZpbmVkJyA/IGRlZmF1bHRzLmFsbG93RG90cyA6ICEhb3B0cy5hbGxvd0RvdHMsXFxuICAgICAgICBjaGFyc2V0OiBjaGFyc2V0LFxcbiAgICAgICAgY2hhcnNldFNlbnRpbmVsOiB0eXBlb2Ygb3B0cy5jaGFyc2V0U2VudGluZWwgPT09ICdib29sZWFuJyA/IG9wdHMuY2hhcnNldFNlbnRpbmVsIDogZGVmYXVsdHMuY2hhcnNldFNlbnRpbmVsLFxcbiAgICAgICAgZGVsaW1pdGVyOiB0eXBlb2Ygb3B0cy5kZWxpbWl0ZXIgPT09ICd1bmRlZmluZWQnID8gZGVmYXVsdHMuZGVsaW1pdGVyIDogb3B0cy5kZWxpbWl0ZXIsXFxuICAgICAgICBlbmNvZGU6IHR5cGVvZiBvcHRzLmVuY29kZSA9PT0gJ2Jvb2xlYW4nID8gb3B0cy5lbmNvZGUgOiBkZWZhdWx0cy5lbmNvZGUsXFxuICAgICAgICBlbmNvZGVyOiB0eXBlb2Ygb3B0cy5lbmNvZGVyID09PSAnZnVuY3Rpb24nID8gb3B0cy5lbmNvZGVyIDogZGVmYXVsdHMuZW5jb2RlcixcXG4gICAgICAgIGVuY29kZVZhbHVlc09ubHk6IHR5cGVvZiBvcHRzLmVuY29kZVZhbHVlc09ubHkgPT09ICdib29sZWFuJyA/IG9wdHMuZW5jb2RlVmFsdWVzT25seSA6IGRlZmF1bHRzLmVuY29kZVZhbHVlc09ubHksXFxuICAgICAgICBmaWx0ZXI6IGZpbHRlcixcXG4gICAgICAgIGZvcm1hdDogZm9ybWF0LFxcbiAgICAgICAgZm9ybWF0dGVyOiBmb3JtYXR0ZXIsXFxuICAgICAgICBzZXJpYWxpemVEYXRlOiB0eXBlb2Ygb3B0cy5zZXJpYWxpemVEYXRlID09PSAnZnVuY3Rpb24nID8gb3B0cy5zZXJpYWxpemVEYXRlIDogZGVmYXVsdHMuc2VyaWFsaXplRGF0ZSxcXG4gICAgICAgIHNraXBOdWxsczogdHlwZW9mIG9wdHMuc2tpcE51bGxzID09PSAnYm9vbGVhbicgPyBvcHRzLnNraXBOdWxscyA6IGRlZmF1bHRzLnNraXBOdWxscyxcXG4gICAgICAgIHNvcnQ6IHR5cGVvZiBvcHRzLnNvcnQgPT09ICdmdW5jdGlvbicgPyBvcHRzLnNvcnQgOiBudWxsLFxcbiAgICAgICAgc3RyaWN0TnVsbEhhbmRsaW5nOiB0eXBlb2Ygb3B0cy5zdHJpY3ROdWxsSGFuZGxpbmcgPT09ICdib29sZWFuJyA/IG9wdHMuc3RyaWN0TnVsbEhhbmRsaW5nIDogZGVmYXVsdHMuc3RyaWN0TnVsbEhhbmRsaW5nXFxuICAgIH07XFxufTtcXG5cXG5tb2R1bGUuZXhwb3J0cyA9IGZ1bmN0aW9uIChvYmplY3QsIG9wdHMpIHtcXG4gICAgdmFyIG9iaiA9IG9iamVjdDtcXG4gICAgdmFyIG9wdGlvbnMgPSBub3JtYWxpemVTdHJpbmdpZnlPcHRpb25zKG9wdHMpO1xcblxcbiAgICB2YXIgb2JqS2V5cztcXG4gICAgdmFyIGZpbHRlcjtcXG5cXG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmZpbHRlciA9PT0gJ2Z1bmN0aW9uJykge1xcbiAgICAgICAgZmlsdGVyID0gb3B0aW9ucy5maWx0ZXI7XFxuICAgICAgICBvYmogPSBmaWx0ZXIoJycsIG9iaik7XFxuICAgIH0gZWxzZSBpZiAoaXNBcnJheShvcHRpb25zLmZpbHRlcikpIHtcXG4gICAgICAgIGZpbHRlciA9IG9wdGlvbnMuZmlsdGVyO1xcbiAgICAgICAgb2JqS2V5cyA9IGZpbHRlcjtcXG4gICAgfVxcblxcbiAgICB2YXIga2V5cyA9IFtdO1xcblxcbiAgICBpZiAodHlwZW9mIG9iaiAhPT0gJ29iamVjdCcgfHwgb2JqID09PSBudWxsKSB7XFxuICAgICAgICByZXR1cm4gJyc7XFxuICAgIH1cXG5cXG4gICAgdmFyIGFycmF5Rm9ybWF0O1xcbiAgICBpZiAob3B0cyAmJiBvcHRzLmFycmF5Rm9ybWF0IGluIGFycmF5UHJlZml4R2VuZXJhdG9ycykge1xcbiAgICAgICAgYXJyYXlGb3JtYXQgPSBvcHRzLmFycmF5Rm9ybWF0O1xcbiAgICB9IGVsc2UgaWYgKG9wdHMgJiYgJ2luZGljZXMnIGluIG9wdHMpIHtcXG4gICAgICAgIGFycmF5Rm9ybWF0ID0gb3B0cy5pbmRpY2VzID8gJ2luZGljZXMnIDogJ3JlcGVhdCc7XFxuICAgIH0gZWxzZSB7XFxuICAgICAgICBhcnJheUZvcm1hdCA9ICdpbmRpY2VzJztcXG4gICAgfVxcblxcbiAgICB2YXIgZ2VuZXJhdGVBcnJheVByZWZpeCA9IGFycmF5UHJlZml4R2VuZXJhdG9yc1thcnJheUZvcm1hdF07XFxuICAgIGlmIChvcHRzICYmICdjb21tYVJvdW5kVHJpcCcgaW4gb3B0cyAmJiB0eXBlb2Ygb3B0cy5jb21tYVJvdW5kVHJpcCAhPT0gJ2Jvb2xlYW4nKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdgY29tbWFSb3VuZFRyaXBgIG11c3QgYmUgYSBib29sZWFuLCBvciBhYnNlbnQnKTtcXG4gICAgfVxcbiAgICB2YXIgY29tbWFSb3VuZFRyaXAgPSBnZW5lcmF0ZUFycmF5UHJlZml4ID09PSAnY29tbWEnICYmIG9wdHMgJiYgb3B0cy5jb21tYVJvdW5kVHJpcDtcXG5cXG4gICAgaWYgKCFvYmpLZXlzKSB7XFxuICAgICAgICBvYmpLZXlzID0gT2JqZWN0LmtleXMob2JqKTtcXG4gICAgfVxcblxcbiAgICBpZiAob3B0aW9ucy5zb3J0KSB7XFxuICAgICAgICBvYmpLZXlzLnNvcnQob3B0aW9ucy5zb3J0KTtcXG4gICAgfVxcblxcbiAgICB2YXIgc2lkZUNoYW5uZWwgPSBnZXRTaWRlQ2hhbm5lbCgpO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IG9iaktleXMubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIHZhciBrZXkgPSBvYmpLZXlzW2ldO1xcblxcbiAgICAgICAgaWYgKG9wdGlvbnMuc2tpcE51bGxzICYmIG9ialtrZXldID09PSBudWxsKSB7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuICAgICAgICBwdXNoVG9BcnJheShrZXlzLCBzdHJpbmdpZnkoXFxuICAgICAgICAgICAgb2JqW2tleV0sXFxuICAgICAgICAgICAga2V5LFxcbiAgICAgICAgICAgIGdlbmVyYXRlQXJyYXlQcmVmaXgsXFxuICAgICAgICAgICAgY29tbWFSb3VuZFRyaXAsXFxuICAgICAgICAgICAgb3B0aW9ucy5zdHJpY3ROdWxsSGFuZGxpbmcsXFxuICAgICAgICAgICAgb3B0aW9ucy5za2lwTnVsbHMsXFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGUgPyBvcHRpb25zLmVuY29kZXIgOiBudWxsLFxcbiAgICAgICAgICAgIG9wdGlvbnMuZmlsdGVyLFxcbiAgICAgICAgICAgIG9wdGlvbnMuc29ydCxcXG4gICAgICAgICAgICBvcHRpb25zLmFsbG93RG90cyxcXG4gICAgICAgICAgICBvcHRpb25zLnNlcmlhbGl6ZURhdGUsXFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXQsXFxuICAgICAgICAgICAgb3B0aW9ucy5mb3JtYXR0ZXIsXFxuICAgICAgICAgICAgb3B0aW9ucy5lbmNvZGVWYWx1ZXNPbmx5LFxcbiAgICAgICAgICAgIG9wdGlvbnMuY2hhcnNldCxcXG4gICAgICAgICAgICBzaWRlQ2hhbm5lbFxcbiAgICAgICAgKSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIGpvaW5lZCA9IGtleXMuam9pbihvcHRpb25zLmRlbGltaXRlcik7XFxuICAgIHZhciBwcmVmaXggPSBvcHRpb25zLmFkZFF1ZXJ5UHJlZml4ID09PSB0cnVlID8gJz8nIDogJyc7XFxuXFxuICAgIGlmIChvcHRpb25zLmNoYXJzZXRTZW50aW5lbCkge1xcbiAgICAgICAgaWYgKG9wdGlvbnMuY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XFxuICAgICAgICAgICAgLy8gZW5jb2RlVVJJQ29tcG9uZW50KCcmIzEwMDAzOycpLCB0aGUgXFxcIm51bWVyaWMgZW50aXR5XFxcIiByZXByZXNlbnRhdGlvbiBvZiBhIGNoZWNrbWFya1xcbiAgICAgICAgICAgIHByZWZpeCArPSAndXRmOD0lMjYlMjMxMDAwMyUzQiYnO1xcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICAvLyBlbmNvZGVVUklDb21wb25lbnQoJ+KckycpXFxuICAgICAgICAgICAgcHJlZml4ICs9ICd1dGY4PSVFMiU5QyU5MyYnO1xcbiAgICAgICAgfVxcbiAgICB9XFxuXFxuICAgIHJldHVybiBqb2luZWQubGVuZ3RoID4gMCA/IHByZWZpeCArIGpvaW5lZCA6ICcnO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvcXMvbGliL3N0cmluZ2lmeS5qcz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4uL25vZGVfbW9kdWxlcy9xcy9saWIvdXRpbHMuanNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKG1vZHVsZSwgX191bnVzZWRfd2VicGFja19leHBvcnRzLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIlxcblxcbnZhciBmb3JtYXRzID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9mb3JtYXRzICovIFxcXCIuLi9ub2RlX21vZHVsZXMvcXMvbGliL2Zvcm1hdHMuanNcXFwiKTtcXG5cXG52YXIgaGFzID0gT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eTtcXG52YXIgaXNBcnJheSA9IEFycmF5LmlzQXJyYXk7XFxuXFxudmFyIGhleFRhYmxlID0gKGZ1bmN0aW9uICgpIHtcXG4gICAgdmFyIGFycmF5ID0gW107XFxuICAgIGZvciAodmFyIGkgPSAwOyBpIDwgMjU2OyArK2kpIHtcXG4gICAgICAgIGFycmF5LnB1c2goJyUnICsgKChpIDwgMTYgPyAnMCcgOiAnJykgKyBpLnRvU3RyaW5nKDE2KSkudG9VcHBlckNhc2UoKSk7XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIGFycmF5O1xcbn0oKSk7XFxuXFxudmFyIGNvbXBhY3RRdWV1ZSA9IGZ1bmN0aW9uIGNvbXBhY3RRdWV1ZShxdWV1ZSkge1xcbiAgICB3aGlsZSAocXVldWUubGVuZ3RoID4gMSkge1xcbiAgICAgICAgdmFyIGl0ZW0gPSBxdWV1ZS5wb3AoKTtcXG4gICAgICAgIHZhciBvYmogPSBpdGVtLm9ialtpdGVtLnByb3BdO1xcblxcbiAgICAgICAgaWYgKGlzQXJyYXkob2JqKSkge1xcbiAgICAgICAgICAgIHZhciBjb21wYWN0ZWQgPSBbXTtcXG5cXG4gICAgICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IG9iai5sZW5ndGg7ICsraikge1xcbiAgICAgICAgICAgICAgICBpZiAodHlwZW9mIG9ialtqXSAhPT0gJ3VuZGVmaW5lZCcpIHtcXG4gICAgICAgICAgICAgICAgICAgIGNvbXBhY3RlZC5wdXNoKG9ialtqXSk7XFxuICAgICAgICAgICAgICAgIH1cXG4gICAgICAgICAgICB9XFxuXFxuICAgICAgICAgICAgaXRlbS5vYmpbaXRlbS5wcm9wXSA9IGNvbXBhY3RlZDtcXG4gICAgICAgIH1cXG4gICAgfVxcbn07XFxuXFxudmFyIGFycmF5VG9PYmplY3QgPSBmdW5jdGlvbiBhcnJheVRvT2JqZWN0KHNvdXJjZSwgb3B0aW9ucykge1xcbiAgICB2YXIgb2JqID0gb3B0aW9ucyAmJiBvcHRpb25zLnBsYWluT2JqZWN0cyA/IE9iamVjdC5jcmVhdGUobnVsbCkgOiB7fTtcXG4gICAgZm9yICh2YXIgaSA9IDA7IGkgPCBzb3VyY2UubGVuZ3RoOyArK2kpIHtcXG4gICAgICAgIGlmICh0eXBlb2Ygc291cmNlW2ldICE9PSAndW5kZWZpbmVkJykge1xcbiAgICAgICAgICAgIG9ialtpXSA9IHNvdXJjZVtpXTtcXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICByZXR1cm4gb2JqO1xcbn07XFxuXFxudmFyIG1lcmdlID0gZnVuY3Rpb24gbWVyZ2UodGFyZ2V0LCBzb3VyY2UsIG9wdGlvbnMpIHtcXG4gICAgLyogZXNsaW50IG5vLXBhcmFtLXJlYXNzaWduOiAwICovXFxuICAgIGlmICghc291cmNlKSB7XFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xcbiAgICB9XFxuXFxuICAgIGlmICh0eXBlb2Ygc291cmNlICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgaWYgKGlzQXJyYXkodGFyZ2V0KSkge1xcbiAgICAgICAgICAgIHRhcmdldC5wdXNoKHNvdXJjZSk7XFxuICAgICAgICB9IGVsc2UgaWYgKHRhcmdldCAmJiB0eXBlb2YgdGFyZ2V0ID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgIGlmICgob3B0aW9ucyAmJiAob3B0aW9ucy5wbGFpbk9iamVjdHMgfHwgb3B0aW9ucy5hbGxvd1Byb3RvdHlwZXMpKSB8fCAhaGFzLmNhbGwoT2JqZWN0LnByb3RvdHlwZSwgc291cmNlKSkge1xcbiAgICAgICAgICAgICAgICB0YXJnZXRbc291cmNlXSA9IHRydWU7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSBlbHNlIHtcXG4gICAgICAgICAgICByZXR1cm4gW3RhcmdldCwgc291cmNlXTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIHJldHVybiB0YXJnZXQ7XFxuICAgIH1cXG5cXG4gICAgaWYgKCF0YXJnZXQgfHwgdHlwZW9mIHRhcmdldCAhPT0gJ29iamVjdCcpIHtcXG4gICAgICAgIHJldHVybiBbdGFyZ2V0XS5jb25jYXQoc291cmNlKTtcXG4gICAgfVxcblxcbiAgICB2YXIgbWVyZ2VUYXJnZXQgPSB0YXJnZXQ7XFxuICAgIGlmIChpc0FycmF5KHRhcmdldCkgJiYgIWlzQXJyYXkoc291cmNlKSkge1xcbiAgICAgICAgbWVyZ2VUYXJnZXQgPSBhcnJheVRvT2JqZWN0KHRhcmdldCwgb3B0aW9ucyk7XFxuICAgIH1cXG5cXG4gICAgaWYgKGlzQXJyYXkodGFyZ2V0KSAmJiBpc0FycmF5KHNvdXJjZSkpIHtcXG4gICAgICAgIHNvdXJjZS5mb3JFYWNoKGZ1bmN0aW9uIChpdGVtLCBpKSB7XFxuICAgICAgICAgICAgaWYgKGhhcy5jYWxsKHRhcmdldCwgaSkpIHtcXG4gICAgICAgICAgICAgICAgdmFyIHRhcmdldEl0ZW0gPSB0YXJnZXRbaV07XFxuICAgICAgICAgICAgICAgIGlmICh0YXJnZXRJdGVtICYmIHR5cGVvZiB0YXJnZXRJdGVtID09PSAnb2JqZWN0JyAmJiBpdGVtICYmIHR5cGVvZiBpdGVtID09PSAnb2JqZWN0Jykge1xcbiAgICAgICAgICAgICAgICAgICAgdGFyZ2V0W2ldID0gbWVyZ2UodGFyZ2V0SXRlbSwgaXRlbSwgb3B0aW9ucyk7XFxuICAgICAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgICAgICB0YXJnZXQucHVzaChpdGVtKTtcXG4gICAgICAgICAgICAgICAgfVxcbiAgICAgICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgICAgIHRhcmdldFtpXSA9IGl0ZW07XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfSk7XFxuICAgICAgICByZXR1cm4gdGFyZ2V0O1xcbiAgICB9XFxuXFxuICAgIHJldHVybiBPYmplY3Qua2V5cyhzb3VyY2UpLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBrZXkpIHtcXG4gICAgICAgIHZhciB2YWx1ZSA9IHNvdXJjZVtrZXldO1xcblxcbiAgICAgICAgaWYgKGhhcy5jYWxsKGFjYywga2V5KSkge1xcbiAgICAgICAgICAgIGFjY1trZXldID0gbWVyZ2UoYWNjW2tleV0sIHZhbHVlLCBvcHRpb25zKTtcXG4gICAgICAgIH0gZWxzZSB7XFxuICAgICAgICAgICAgYWNjW2tleV0gPSB2YWx1ZTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgIH0sIG1lcmdlVGFyZ2V0KTtcXG59O1xcblxcbnZhciBhc3NpZ24gPSBmdW5jdGlvbiBhc3NpZ25TaW5nbGVTb3VyY2UodGFyZ2V0LCBzb3VyY2UpIHtcXG4gICAgcmV0dXJuIE9iamVjdC5rZXlzKHNvdXJjZSkucmVkdWNlKGZ1bmN0aW9uIChhY2MsIGtleSkge1xcbiAgICAgICAgYWNjW2tleV0gPSBzb3VyY2Vba2V5XTtcXG4gICAgICAgIHJldHVybiBhY2M7XFxuICAgIH0sIHRhcmdldCk7XFxufTtcXG5cXG52YXIgZGVjb2RlID0gZnVuY3Rpb24gKHN0ciwgZGVjb2RlciwgY2hhcnNldCkge1xcbiAgICB2YXIgc3RyV2l0aG91dFBsdXMgPSBzdHIucmVwbGFjZSgvXFxcXCsvZywgJyAnKTtcXG4gICAgaWYgKGNoYXJzZXQgPT09ICdpc28tODg1OS0xJykge1xcbiAgICAgICAgLy8gdW5lc2NhcGUgbmV2ZXIgdGhyb3dzLCBubyB0cnkuLi5jYXRjaCBuZWVkZWQ6XFxuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXMucmVwbGFjZSgvJVswLTlhLWZdezJ9L2dpLCB1bmVzY2FwZSk7XFxuICAgIH1cXG4gICAgLy8gdXRmLThcXG4gICAgdHJ5IHtcXG4gICAgICAgIHJldHVybiBkZWNvZGVVUklDb21wb25lbnQoc3RyV2l0aG91dFBsdXMpO1xcbiAgICB9IGNhdGNoIChlKSB7XFxuICAgICAgICByZXR1cm4gc3RyV2l0aG91dFBsdXM7XFxuICAgIH1cXG59O1xcblxcbnZhciBlbmNvZGUgPSBmdW5jdGlvbiBlbmNvZGUoc3RyLCBkZWZhdWx0RW5jb2RlciwgY2hhcnNldCwga2luZCwgZm9ybWF0KSB7XFxuICAgIC8vIFRoaXMgY29kZSB3YXMgb3JpZ2luYWxseSB3cml0dGVuIGJ5IEJyaWFuIFdoaXRlIChtc2NkZXgpIGZvciB0aGUgaW8uanMgY29yZSBxdWVyeXN0cmluZyBsaWJyYXJ5LlxcbiAgICAvLyBJdCBoYXMgYmVlbiBhZGFwdGVkIGhlcmUgZm9yIHN0cmljdGVyIGFkaGVyZW5jZSB0byBSRkMgMzk4NlxcbiAgICBpZiAoc3RyLmxlbmd0aCA9PT0gMCkge1xcbiAgICAgICAgcmV0dXJuIHN0cjtcXG4gICAgfVxcblxcbiAgICB2YXIgc3RyaW5nID0gc3RyO1xcbiAgICBpZiAodHlwZW9mIHN0ciA9PT0gJ3N5bWJvbCcpIHtcXG4gICAgICAgIHN0cmluZyA9IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChzdHIpO1xcbiAgICB9IGVsc2UgaWYgKHR5cGVvZiBzdHIgIT09ICdzdHJpbmcnKSB7XFxuICAgICAgICBzdHJpbmcgPSBTdHJpbmcoc3RyKTtcXG4gICAgfVxcblxcbiAgICBpZiAoY2hhcnNldCA9PT0gJ2lzby04ODU5LTEnKSB7XFxuICAgICAgICByZXR1cm4gZXNjYXBlKHN0cmluZykucmVwbGFjZSgvJXVbMC05YS1mXXs0fS9naSwgZnVuY3Rpb24gKCQwKSB7XFxuICAgICAgICAgICAgcmV0dXJuICclMjYlMjMnICsgcGFyc2VJbnQoJDAuc2xpY2UoMiksIDE2KSArICclM0InO1xcbiAgICAgICAgfSk7XFxuICAgIH1cXG5cXG4gICAgdmFyIG91dCA9ICcnO1xcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHN0cmluZy5sZW5ndGg7ICsraSkge1xcbiAgICAgICAgdmFyIGMgPSBzdHJpbmcuY2hhckNvZGVBdChpKTtcXG5cXG4gICAgICAgIGlmIChcXG4gICAgICAgICAgICBjID09PSAweDJEIC8vIC1cXG4gICAgICAgICAgICB8fCBjID09PSAweDJFIC8vIC5cXG4gICAgICAgICAgICB8fCBjID09PSAweDVGIC8vIF9cXG4gICAgICAgICAgICB8fCBjID09PSAweDdFIC8vIH5cXG4gICAgICAgICAgICB8fCAoYyA+PSAweDMwICYmIGMgPD0gMHgzOSkgLy8gMC05XFxuICAgICAgICAgICAgfHwgKGMgPj0gMHg0MSAmJiBjIDw9IDB4NUEpIC8vIGEtelxcbiAgICAgICAgICAgIHx8IChjID49IDB4NjEgJiYgYyA8PSAweDdBKSAvLyBBLVpcXG4gICAgICAgICAgICB8fCAoZm9ybWF0ID09PSBmb3JtYXRzLlJGQzE3MzggJiYgKGMgPT09IDB4MjggfHwgYyA9PT0gMHgyOSkpIC8vICggKVxcbiAgICAgICAgKSB7XFxuICAgICAgICAgICAgb3V0ICs9IHN0cmluZy5jaGFyQXQoaSk7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYyA8IDB4ODApIHtcXG4gICAgICAgICAgICBvdXQgPSBvdXQgKyBoZXhUYWJsZVtjXTtcXG4gICAgICAgICAgICBjb250aW51ZTtcXG4gICAgICAgIH1cXG5cXG4gICAgICAgIGlmIChjIDwgMHg4MDApIHtcXG4gICAgICAgICAgICBvdXQgPSBvdXQgKyAoaGV4VGFibGVbMHhDMCB8IChjID4+IDYpXSArIGhleFRhYmxlWzB4ODAgfCAoYyAmIDB4M0YpXSk7XFxuICAgICAgICAgICAgY29udGludWU7XFxuICAgICAgICB9XFxuXFxuICAgICAgICBpZiAoYyA8IDB4RDgwMCB8fCBjID49IDB4RTAwMCkge1xcbiAgICAgICAgICAgIG91dCA9IG91dCArIChoZXhUYWJsZVsweEUwIHwgKGMgPj4gMTIpXSArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gNikgJiAweDNGKV0gKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV0pO1xcbiAgICAgICAgICAgIGNvbnRpbnVlO1xcbiAgICAgICAgfVxcblxcbiAgICAgICAgaSArPSAxO1xcbiAgICAgICAgYyA9IDB4MTAwMDAgKyAoKChjICYgMHgzRkYpIDw8IDEwKSB8IChzdHJpbmcuY2hhckNvZGVBdChpKSAmIDB4M0ZGKSk7XFxuICAgICAgICAvKiBlc2xpbnQgb3BlcmF0b3ItbGluZWJyZWFrOiBbMiwgXFxcImJlZm9yZVxcXCJdICovXFxuICAgICAgICBvdXQgKz0gaGV4VGFibGVbMHhGMCB8IChjID4+IDE4KV1cXG4gICAgICAgICAgICArIGhleFRhYmxlWzB4ODAgfCAoKGMgPj4gMTIpICYgMHgzRildXFxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKChjID4+IDYpICYgMHgzRildXFxuICAgICAgICAgICAgKyBoZXhUYWJsZVsweDgwIHwgKGMgJiAweDNGKV07XFxuICAgIH1cXG5cXG4gICAgcmV0dXJuIG91dDtcXG59O1xcblxcbnZhciBjb21wYWN0ID0gZnVuY3Rpb24gY29tcGFjdCh2YWx1ZSkge1xcbiAgICB2YXIgcXVldWUgPSBbeyBvYmo6IHsgbzogdmFsdWUgfSwgcHJvcDogJ28nIH1dO1xcbiAgICB2YXIgcmVmcyA9IFtdO1xcblxcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IHF1ZXVlLmxlbmd0aDsgKytpKSB7XFxuICAgICAgICB2YXIgaXRlbSA9IHF1ZXVlW2ldO1xcbiAgICAgICAgdmFyIG9iaiA9IGl0ZW0ub2JqW2l0ZW0ucHJvcF07XFxuXFxuICAgICAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iaik7XFxuICAgICAgICBmb3IgKHZhciBqID0gMDsgaiA8IGtleXMubGVuZ3RoOyArK2opIHtcXG4gICAgICAgICAgICB2YXIga2V5ID0ga2V5c1tqXTtcXG4gICAgICAgICAgICB2YXIgdmFsID0gb2JqW2tleV07XFxuICAgICAgICAgICAgaWYgKHR5cGVvZiB2YWwgPT09ICdvYmplY3QnICYmIHZhbCAhPT0gbnVsbCAmJiByZWZzLmluZGV4T2YodmFsKSA9PT0gLTEpIHtcXG4gICAgICAgICAgICAgICAgcXVldWUucHVzaCh7IG9iajogb2JqLCBwcm9wOiBrZXkgfSk7XFxuICAgICAgICAgICAgICAgIHJlZnMucHVzaCh2YWwpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgIH1cXG4gICAgfVxcblxcbiAgICBjb21wYWN0UXVldWUocXVldWUpO1xcblxcbiAgICByZXR1cm4gdmFsdWU7XFxufTtcXG5cXG52YXIgaXNSZWdFeHAgPSBmdW5jdGlvbiBpc1JlZ0V4cChvYmopIHtcXG4gICAgcmV0dXJuIE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBSZWdFeHBdJztcXG59O1xcblxcbnZhciBpc0J1ZmZlciA9IGZ1bmN0aW9uIGlzQnVmZmVyKG9iaikge1xcbiAgICBpZiAoIW9iaiB8fCB0eXBlb2Ygb2JqICE9PSAnb2JqZWN0Jykge1xcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xcbiAgICB9XFxuXFxuICAgIHJldHVybiAhIShvYmouY29uc3RydWN0b3IgJiYgb2JqLmNvbnN0cnVjdG9yLmlzQnVmZmVyICYmIG9iai5jb25zdHJ1Y3Rvci5pc0J1ZmZlcihvYmopKTtcXG59O1xcblxcbnZhciBjb21iaW5lID0gZnVuY3Rpb24gY29tYmluZShhLCBiKSB7XFxuICAgIHJldHVybiBbXS5jb25jYXQoYSwgYik7XFxufTtcXG5cXG52YXIgbWF5YmVNYXAgPSBmdW5jdGlvbiBtYXliZU1hcCh2YWwsIGZuKSB7XFxuICAgIGlmIChpc0FycmF5KHZhbCkpIHtcXG4gICAgICAgIHZhciBtYXBwZWQgPSBbXTtcXG4gICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgdmFsLmxlbmd0aDsgaSArPSAxKSB7XFxuICAgICAgICAgICAgbWFwcGVkLnB1c2goZm4odmFsW2ldKSk7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gbWFwcGVkO1xcbiAgICB9XFxuICAgIHJldHVybiBmbih2YWwpO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSB7XFxuICAgIGFycmF5VG9PYmplY3Q6IGFycmF5VG9PYmplY3QsXFxuICAgIGFzc2lnbjogYXNzaWduLFxcbiAgICBjb21iaW5lOiBjb21iaW5lLFxcbiAgICBjb21wYWN0OiBjb21wYWN0LFxcbiAgICBkZWNvZGU6IGRlY29kZSxcXG4gICAgZW5jb2RlOiBlbmNvZGUsXFxuICAgIGlzQnVmZmVyOiBpc0J1ZmZlcixcXG4gICAgaXNSZWdFeHA6IGlzUmVnRXhwLFxcbiAgICBtYXliZU1hcDogbWF5YmVNYXAsXFxuICAgIG1lcmdlOiBtZXJnZVxcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvcXMvbGliL3V0aWxzLmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi4vbm9kZV9tb2R1bGVzL3NpZGUtY2hhbm5lbC9pbmRleC5qc1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4uL25vZGVfbW9kdWxlcy9zaWRlLWNoYW5uZWwvaW5kZXguanMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgobW9kdWxlLCBfX3VudXNlZF93ZWJwYWNrX2V4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiXFxuXFxudmFyIEdldEludHJpbnNpYyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGdldC1pbnRyaW5zaWMgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9nZXQtaW50cmluc2ljL2luZGV4LmpzXFxcIik7XFxudmFyIGNhbGxCb3VuZCA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNhbGwtYmluZC9jYWxsQm91bmQgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9jYWxsLWJpbmQvY2FsbEJvdW5kLmpzXFxcIik7XFxudmFyIGluc3BlY3QgPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBvYmplY3QtaW5zcGVjdCAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL29iamVjdC1pbnNwZWN0L2luZGV4LmpzXFxcIik7XFxuXFxudmFyICRUeXBlRXJyb3IgPSBHZXRJbnRyaW5zaWMoJyVUeXBlRXJyb3IlJyk7XFxudmFyICRXZWFrTWFwID0gR2V0SW50cmluc2ljKCclV2Vha01hcCUnLCB0cnVlKTtcXG52YXIgJE1hcCA9IEdldEludHJpbnNpYygnJU1hcCUnLCB0cnVlKTtcXG5cXG52YXIgJHdlYWtNYXBHZXQgPSBjYWxsQm91bmQoJ1dlYWtNYXAucHJvdG90eXBlLmdldCcsIHRydWUpO1xcbnZhciAkd2Vha01hcFNldCA9IGNhbGxCb3VuZCgnV2Vha01hcC5wcm90b3R5cGUuc2V0JywgdHJ1ZSk7XFxudmFyICR3ZWFrTWFwSGFzID0gY2FsbEJvdW5kKCdXZWFrTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcXG52YXIgJG1hcEdldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5nZXQnLCB0cnVlKTtcXG52YXIgJG1hcFNldCA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5zZXQnLCB0cnVlKTtcXG52YXIgJG1hcEhhcyA9IGNhbGxCb3VuZCgnTWFwLnByb3RvdHlwZS5oYXMnLCB0cnVlKTtcXG5cXG4vKlxcbiAqIFRoaXMgZnVuY3Rpb24gdHJhdmVyc2VzIHRoZSBsaXN0IHJldHVybmluZyB0aGUgbm9kZSBjb3JyZXNwb25kaW5nIHRvIHRoZVxcbiAqIGdpdmVuIGtleS5cXG4gKlxcbiAqIFRoYXQgbm9kZSBpcyBhbHNvIG1vdmVkIHRvIHRoZSBoZWFkIG9mIHRoZSBsaXN0LCBzbyB0aGF0IGlmIGl0J3MgYWNjZXNzZWRcXG4gKiBhZ2FpbiB3ZSBkb24ndCBuZWVkIHRvIHRyYXZlcnNlIHRoZSB3aG9sZSBsaXN0LiBCeSBkb2luZyBzbywgYWxsIHRoZSByZWNlbnRseVxcbiAqIHVzZWQgbm9kZXMgY2FuIGJlIGFjY2Vzc2VkIHJlbGF0aXZlbHkgcXVpY2tseS5cXG4gKi9cXG52YXIgbGlzdEdldE5vZGUgPSBmdW5jdGlvbiAobGlzdCwga2V5KSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgY29uc2lzdGVudC1yZXR1cm5cXG5cXHRmb3IgKHZhciBwcmV2ID0gbGlzdCwgY3VycjsgKGN1cnIgPSBwcmV2Lm5leHQpICE9PSBudWxsOyBwcmV2ID0gY3Vycikge1xcblxcdFxcdGlmIChjdXJyLmtleSA9PT0ga2V5KSB7XFxuXFx0XFx0XFx0cHJldi5uZXh0ID0gY3Vyci5uZXh0O1xcblxcdFxcdFxcdGN1cnIubmV4dCA9IGxpc3QubmV4dDtcXG5cXHRcXHRcXHRsaXN0Lm5leHQgPSBjdXJyOyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLXBhcmFtLXJlYXNzaWduXFxuXFx0XFx0XFx0cmV0dXJuIGN1cnI7XFxuXFx0XFx0fVxcblxcdH1cXG59O1xcblxcbnZhciBsaXN0R2V0ID0gZnVuY3Rpb24gKG9iamVjdHMsIGtleSkge1xcblxcdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcXG5cXHRyZXR1cm4gbm9kZSAmJiBub2RlLnZhbHVlO1xcbn07XFxudmFyIGxpc3RTZXQgPSBmdW5jdGlvbiAob2JqZWN0cywga2V5LCB2YWx1ZSkge1xcblxcdHZhciBub2RlID0gbGlzdEdldE5vZGUob2JqZWN0cywga2V5KTtcXG5cXHRpZiAobm9kZSkge1xcblxcdFxcdG5vZGUudmFsdWUgPSB2YWx1ZTtcXG5cXHR9IGVsc2Uge1xcblxcdFxcdC8vIFByZXBlbmQgdGhlIG5ldyBub2RlIHRvIHRoZSBiZWdpbm5pbmcgb2YgdGhlIGxpc3RcXG5cXHRcXHRvYmplY3RzLm5leHQgPSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cXG5cXHRcXHRcXHRrZXk6IGtleSxcXG5cXHRcXHRcXHRuZXh0OiBvYmplY3RzLm5leHQsXFxuXFx0XFx0XFx0dmFsdWU6IHZhbHVlXFxuXFx0XFx0fTtcXG5cXHR9XFxufTtcXG52YXIgbGlzdEhhcyA9IGZ1bmN0aW9uIChvYmplY3RzLCBrZXkpIHtcXG5cXHRyZXR1cm4gISFsaXN0R2V0Tm9kZShvYmplY3RzLCBrZXkpO1xcbn07XFxuXFxubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbiBnZXRTaWRlQ2hhbm5lbCgpIHtcXG5cXHR2YXIgJHdtO1xcblxcdHZhciAkbTtcXG5cXHR2YXIgJG87XFxuXFx0dmFyIGNoYW5uZWwgPSB7XFxuXFx0XFx0YXNzZXJ0OiBmdW5jdGlvbiAoa2V5KSB7XFxuXFx0XFx0XFx0aWYgKCFjaGFubmVsLmhhcyhrZXkpKSB7XFxuXFx0XFx0XFx0XFx0dGhyb3cgbmV3ICRUeXBlRXJyb3IoJ1NpZGUgY2hhbm5lbCBkb2VzIG5vdCBjb250YWluICcgKyBpbnNwZWN0KGtleSkpO1xcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGdldDogZnVuY3Rpb24gKGtleSkgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIGNvbnNpc3RlbnQtcmV0dXJuXFxuXFx0XFx0XFx0aWYgKCRXZWFrTWFwICYmIGtleSAmJiAodHlwZW9mIGtleSA9PT0gJ29iamVjdCcgfHwgdHlwZW9mIGtleSA9PT0gJ2Z1bmN0aW9uJykpIHtcXG5cXHRcXHRcXHRcXHRpZiAoJHdtKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICR3ZWFrTWFwR2V0KCR3bSwga2V5KTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0fSBlbHNlIGlmICgkTWFwKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCRtKSB7XFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuICRtYXBHZXQoJG0sIGtleSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSB7XFxuXFx0XFx0XFx0XFx0aWYgKCRvKSB7IC8vIGVzbGludC1kaXNhYmxlLWxpbmUgbm8tbG9uZWx5LWlmXFxuXFx0XFx0XFx0XFx0XFx0cmV0dXJuIGxpc3RHZXQoJG8sIGtleSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH1cXG5cXHRcXHR9LFxcblxcdFxcdGhhczogZnVuY3Rpb24gKGtleSkge1xcblxcdFxcdFxcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCR3bSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkd2Vha01hcEhhcygkd20sIGtleSk7XFxuXFx0XFx0XFx0XFx0fVxcblxcdFxcdFxcdH0gZWxzZSBpZiAoJE1hcCkge1xcblxcdFxcdFxcdFxcdGlmICgkbSkge1xcblxcdFxcdFxcdFxcdFxcdHJldHVybiAkbWFwSGFzKCRtLCBrZXkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmICgkbykgeyAvLyBlc2xpbnQtZGlzYWJsZS1saW5lIG5vLWxvbmVseS1pZlxcblxcdFxcdFxcdFxcdFxcdHJldHVybiBsaXN0SGFzKCRvLCBrZXkpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHR9XFxuXFx0XFx0XFx0cmV0dXJuIGZhbHNlO1xcblxcdFxcdH0sXFxuXFx0XFx0c2V0OiBmdW5jdGlvbiAoa2V5LCB2YWx1ZSkge1xcblxcdFxcdFxcdGlmICgkV2Vha01hcCAmJiBrZXkgJiYgKHR5cGVvZiBrZXkgPT09ICdvYmplY3QnIHx8IHR5cGVvZiBrZXkgPT09ICdmdW5jdGlvbicpKSB7XFxuXFx0XFx0XFx0XFx0aWYgKCEkd20pIHtcXG5cXHRcXHRcXHRcXHRcXHQkd20gPSBuZXcgJFdlYWtNYXAoKTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0JHdlYWtNYXBTZXQoJHdtLCBrZXksIHZhbHVlKTtcXG5cXHRcXHRcXHR9IGVsc2UgaWYgKCRNYXApIHtcXG5cXHRcXHRcXHRcXHRpZiAoISRtKSB7XFxuXFx0XFx0XFx0XFx0XFx0JG0gPSBuZXcgJE1hcCgpO1xcblxcdFxcdFxcdFxcdH1cXG5cXHRcXHRcXHRcXHQkbWFwU2V0KCRtLCBrZXksIHZhbHVlKTtcXG5cXHRcXHRcXHR9IGVsc2Uge1xcblxcdFxcdFxcdFxcdGlmICghJG8pIHtcXG5cXHRcXHRcXHRcXHRcXHQvKlxcblxcdFxcdFxcdFxcdFxcdCAqIEluaXRpYWxpemUgdGhlIGxpbmtlZCBsaXN0IGFzIGFuIGVtcHR5IG5vZGUsIHNvIHRoYXQgd2UgZG9uJ3QgaGF2ZVxcblxcdFxcdFxcdFxcdFxcdCAqIHRvIHNwZWNpYWwtY2FzZSBoYW5kbGluZyBvZiB0aGUgZmlyc3Qgbm9kZTogd2UgY2FuIGFsd2F5cyByZWZlciB0b1xcblxcdFxcdFxcdFxcdFxcdCAqIGl0IGFzIChwcmV2aW91cyBub2RlKS5uZXh0LCBpbnN0ZWFkIG9mIHNvbWV0aGluZyBsaWtlIChsaXN0KS5oZWFkXFxuXFx0XFx0XFx0XFx0XFx0ICovXFxuXFx0XFx0XFx0XFx0XFx0JG8gPSB7IGtleToge30sIG5leHQ6IG51bGwgfTtcXG5cXHRcXHRcXHRcXHR9XFxuXFx0XFx0XFx0XFx0bGlzdFNldCgkbywga2V5LCB2YWx1ZSk7XFxuXFx0XFx0XFx0fVxcblxcdFxcdH1cXG5cXHR9O1xcblxcdHJldHVybiBjaGFubmVsO1xcbn07XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uLi9ub2RlX21vZHVsZXMvc2lkZS1jaGFubmVsL2luZGV4LmpzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jb250ZW50ZnVsLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL2NvbnRlbnRmdWwudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJjcmVhdGVDbGllbnRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVDbGllbnQpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBheGlvcyAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2F4aW9zL2luZGV4LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGF4aW9zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCA9IC8qI19fUFVSRV9fKi9fX3dlYnBhY2tfcmVxdWlyZV9fLm4oYXhpb3NfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvbnRlbnRmdWwtc2RrLWNvcmUgKi8gXFxcIi4uL25vZGVfbW9kdWxlcy9jb250ZW50ZnVsLXNkay1jb3JlL2Rpc3QvaW5kZXguZXMtbW9kdWxlcy5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY3JlYXRlX2dsb2JhbF9vcHRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NyZWF0ZS1nbG9iYWwtb3B0aW9ucyAqLyBcXFwiLi9jcmVhdGUtZ2xvYmFsLW9wdGlvbnMudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21ha2VfY2xpZW50X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21ha2UtY2xpZW50ICovIFxcXCIuL21ha2UtY2xpZW50LnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvdmFsaWRhdGUtcGFyYW1zICovIFxcXCIuL3V0aWxzL3ZhbGlkYXRlLXBhcmFtcy50c1xcXCIpO1xcbi8qKlxcbiAqIENvbnRlbnRmdWwgRGVsaXZlcnkgQVBJIFNESy4gQWxsb3dzIHlvdSB0byBjcmVhdGUgaW5zdGFuY2VzIG9mIGEgY2xpZW50XFxuICogd2l0aCBhY2Nlc3MgdG8gdGhlIENvbnRlbnRmdWwgQ29udGVudCBEZWxpdmVyeSBBUEkuXFxuICovXFxuXFxuXFxuXFxuXFxuXFxuLyoqXFxuICogQ3JlYXRlIGEgY2xpZW50IGluc3RhbmNlXFxuICogQHBhcmFtIHBhcmFtcyAtIENsaWVudCBpbml0aWFsaXphdGlvbiBwYXJhbWV0ZXJzXFxuICogQGNhdGVnb3J5IENsaWVudFxcbiAqIEBleGFtcGxlXFxuICogYGBgdHlwZXNjcmlwdFxcbiAqIGNvbnN0IGNvbnRlbnRmdWwgPSByZXF1aXJlKCdjb250ZW50ZnVsJylcXG4gKiBjb25zdCBjbGllbnQgPSBjb250ZW50ZnVsLmNyZWF0ZUNsaWVudCh7XFxuICogICBhY2Nlc3NUb2tlbjogJ215QWNjZXNzVG9rZW4nLFxcbiAqICAgc3BhY2U6ICdteVNwYWNlSWQnXFxuICogfSlcXG4gKiBgYGBcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVDbGllbnQocGFyYW1zKSB7XFxuICAgIGlmICghcGFyYW1zLmFjY2Vzc1Rva2VuKSB7XFxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdFeHBlY3RlZCBwYXJhbWV0ZXIgYWNjZXNzVG9rZW4nKTtcXG4gICAgfVxcbiAgICBpZiAoIXBhcmFtcy5zcGFjZSkge1xcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhwZWN0ZWQgcGFyYW1ldGVyIHNwYWNlJyk7XFxuICAgIH1cXG4gICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3BhcmFtc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fLnZhbGlkYXRlUmVzb2x2ZUxpbmtzUGFyYW0pKHBhcmFtcyk7XFxuICAgICgwLF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXy52YWxpZGF0ZVJlbW92ZVVucmVzb2x2ZWRQYXJhbSkocGFyYW1zKTtcXG4gICAgY29uc3QgZGVmYXVsdENvbmZpZyA9IHtcXG4gICAgICAgIHJlc29sdmVMaW5rczogdHJ1ZSxcXG4gICAgICAgIHJlbW92ZVVucmVzb2x2ZWQ6IGZhbHNlLFxcbiAgICAgICAgZGVmYXVsdEhvc3RuYW1lOiAnY2RuLmNvbnRlbnRmdWwuY29tJyxcXG4gICAgICAgIGVudmlyb25tZW50OiAnbWFzdGVyJyxcXG4gICAgfTtcXG4gICAgY29uc3QgY29uZmlnID0ge1xcbiAgICAgICAgLi4uZGVmYXVsdENvbmZpZyxcXG4gICAgICAgIC4uLnBhcmFtcyxcXG4gICAgfTtcXG4gICAgY29uc3QgdXNlckFnZW50SGVhZGVyID0gKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmdldFVzZXJBZ2VudEhlYWRlcikoYGNvbnRlbnRmdWwuanMvJHtcXFwiMTAuMS4wXFxcIn1gLCBjb25maWcuYXBwbGljYXRpb24sIGNvbmZpZy5pbnRlZ3JhdGlvbik7XFxuICAgIGNvbmZpZy5oZWFkZXJzID0ge1xcbiAgICAgICAgLi4uY29uZmlnLmhlYWRlcnMsXFxuICAgICAgICAnQ29udGVudC1UeXBlJzogJ2FwcGxpY2F0aW9uL3ZuZC5jb250ZW50ZnVsLmRlbGl2ZXJ5LnYxK2pzb24nLFxcbiAgICAgICAgJ1gtQ29udGVudGZ1bC1Vc2VyLUFnZW50JzogdXNlckFnZW50SGVhZGVyLFxcbiAgICB9O1xcbiAgICBjb25zdCBodHRwID0gKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLmNyZWF0ZUh0dHBDbGllbnQpKChheGlvc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fX2RlZmF1bHQoKSksIGNvbmZpZyk7XFxuICAgIGlmICghaHR0cC5kZWZhdWx0cy5iYXNlVVJMKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1BsZWFzZSBkZWZpbmUgYSBiYXNlVVJMJyk7XFxuICAgIH1cXG4gICAgY29uc3QgZ2V0R2xvYmFsT3B0aW9ucyA9ICgwLF9jcmVhdGVfZ2xvYmFsX29wdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXy5jcmVhdGVHbG9iYWxPcHRpb25zKSh7XFxuICAgICAgICBzcGFjZTogY29uZmlnLnNwYWNlLFxcbiAgICAgICAgZW52aXJvbm1lbnQ6IGNvbmZpZy5lbnZpcm9ubWVudCxcXG4gICAgICAgIHNwYWNlQmFzZVVybDogaHR0cC5kZWZhdWx0cy5iYXNlVVJMLFxcbiAgICAgICAgZW52aXJvbm1lbnRCYXNlVXJsOiBgJHtodHRwLmRlZmF1bHRzLmJhc2VVUkx9ZW52aXJvbm1lbnRzLyR7Y29uZmlnLmVudmlyb25tZW50fWAsXFxuICAgIH0pO1xcbiAgICAvLyBBcHBlbmQgZW52aXJvbm1lbnQgdG8gYmFzZVVSTFxcbiAgICBodHRwLmRlZmF1bHRzLmJhc2VVUkwgPSBnZXRHbG9iYWxPcHRpb25zKHt9KS5lbnZpcm9ubWVudEJhc2VVcmw7XFxuICAgIHJldHVybiAoMCxfbWFrZV9jbGllbnRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXy5tYWtlQ2xpZW50KSh7XFxuICAgICAgICBodHRwLFxcbiAgICAgICAgZ2V0R2xvYmFsT3B0aW9ucyxcXG4gICAgfSk7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi9jb250ZW50ZnVsLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jcmVhdGUtY29udGVudGZ1bC1hcGkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jcmVhdGUtY29udGVudGZ1bC1hcGkudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVDb250ZW50ZnVsQXBpKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb250ZW50ZnVsLXNkay1jb3JlICovIFxcXCIuLi9ub2RlX21vZHVsZXMvY29udGVudGZ1bC1zZGstY29yZS9kaXN0L2luZGV4LmVzLW1vZHVsZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3BhZ2VkX3N5bmNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcGFnZWQtc3luYyAqLyBcXFwiLi9wYWdlZC1zeW5jLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19ub3JtYWxpemVfc2VhcmNoX3BhcmFtZXRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbm9ybWFsaXplLXNlYXJjaC1wYXJhbWV0ZXJzICovIFxcXCIuL3V0aWxzL25vcm1hbGl6ZS1zZWFyY2gtcGFyYW1ldGVycy50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfbm9ybWFsaXplX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi91dGlscy9ub3JtYWxpemUtc2VsZWN0ICovIFxcXCIuL3V0aWxzL25vcm1hbGl6ZS1zZWxlY3QudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3Jlc29sdmVfY2lyY3VsYXJfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvcmVzb2x2ZS1jaXJjdWxhciAqLyBcXFwiLi91dGlscy9yZXNvbHZlLWNpcmN1bGFyLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc192YWxpZGF0ZV90aW1lc3RhbXBfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvdmFsaWRhdGUtdGltZXN0YW1wICovIFxcXCIuL3V0aWxzL3ZhbGlkYXRlLXRpbWVzdGFtcC50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdXRpbHNfdmFsaWRhdGVfcGFyYW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3ZhbGlkYXRlLXBhcmFtcyAqLyBcXFwiLi91dGlscy92YWxpZGF0ZS1wYXJhbXMudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX3ZhbGlkYXRlX3NlYXJjaF9wYXJhbWV0ZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3ZhbGlkYXRlLXNlYXJjaC1wYXJhbWV0ZXJzICovIFxcXCIuL3V0aWxzL3ZhbGlkYXRlLXNlYXJjaC1wYXJhbWV0ZXJzLnRzXFxcIik7XFxuLyoqXFxuICogQ29udGVudGZ1bCBEZWxpdmVyeSBBUEkgQ2xpZW50LiBDb250YWlucyBtZXRob2RzIHdoaWNoIGFsbG93IGFjY2VzcyB0byB0aGVcXG4gKiBkaWZmZXJlbnQga2luZHMgb2YgZW50aXRpZXMgcHJlc2VudCBpbiBDb250ZW50ZnVsIChFbnRyaWVzLCBBc3NldHMsIGV0YykuXFxuICovXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuY29uc3QgQVNTRVRfS0VZX01BWF9MSUZFVElNRSA9IDQ4ICogNjAgKiA2MDtcXG5jbGFzcyBOb3RGb3VuZEVycm9yIGV4dGVuZHMgRXJyb3Ige1xcbiAgICBzeXM7XFxuICAgIGRldGFpbHM7XFxuICAgIGNvbnN0cnVjdG9yKGlkLCBlbnZpcm9ubWVudCwgc3BhY2UpIHtcXG4gICAgICAgIHN1cGVyKCdUaGUgcmVzb3VyY2UgY291bGQgbm90IGJlIGZvdW5kLicpO1xcbiAgICAgICAgdGhpcy5zeXMgPSB7XFxuICAgICAgICAgICAgdHlwZTogJ0Vycm9yJyxcXG4gICAgICAgICAgICBpZDogJ05vdEZvdW5kJyxcXG4gICAgICAgIH07XFxuICAgICAgICB0aGlzLmRldGFpbHMgPSB7XFxuICAgICAgICAgICAgdHlwZTogJ0VudHJ5JyxcXG4gICAgICAgICAgICBpZCxcXG4gICAgICAgICAgICBlbnZpcm9ubWVudCxcXG4gICAgICAgICAgICBzcGFjZSxcXG4gICAgICAgIH07XFxuICAgIH1cXG59XFxuZnVuY3Rpb24gY3JlYXRlQ29udGVudGZ1bEFwaSh7IGh0dHAsIGdldEdsb2JhbE9wdGlvbnMgfSwgb3B0aW9ucykge1xcbiAgICBjb25zdCBub3RGb3VuZEVycm9yID0gKGlkID0gJ3Vua25vd24nKSA9PiB7XFxuICAgICAgICByZXR1cm4gbmV3IE5vdEZvdW5kRXJyb3IoaWQsIGdldEdsb2JhbE9wdGlvbnMoKS5lbnZpcm9ubWVudCwgZ2V0R2xvYmFsT3B0aW9ucygpLnNwYWNlKTtcXG4gICAgfTtcXG4gICAgY29uc3QgZ2V0QmFzZVVybCA9IChjb250ZXh0KSA9PiB7XFxuICAgICAgICBsZXQgYmFzZVVybCA9IGNvbnRleHQgPT09ICdzcGFjZScgPyBnZXRHbG9iYWxPcHRpb25zKCkuc3BhY2VCYXNlVXJsIDogZ2V0R2xvYmFsT3B0aW9ucygpLmVudmlyb25tZW50QmFzZVVybDtcXG4gICAgICAgIGlmICghYmFzZVVybCkge1xcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcignUGxlYXNlIGRlZmluZSBiYXNlVXJsIGZvciAnICsgY29udGV4dCk7XFxuICAgICAgICB9XFxuICAgICAgICBpZiAoIWJhc2VVcmwuZW5kc1dpdGgoJy8nKSkge1xcbiAgICAgICAgICAgIGJhc2VVcmwgKz0gJy8nO1xcbiAgICAgICAgfVxcbiAgICAgICAgcmV0dXJuIGJhc2VVcmw7XFxuICAgIH07XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldCh7IGNvbnRleHQsIHBhdGgsIGNvbmZpZyB9KSB7XFxuICAgICAgICBjb25zdCBiYXNlVXJsID0gZ2V0QmFzZVVybChjb250ZXh0KTtcXG4gICAgICAgIHRyeSB7XFxuICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwLmdldChiYXNlVXJsICsgcGF0aCwgY29uZmlnKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgICgwLGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5lcnJvckhhbmRsZXIpKGVycm9yKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBwb3N0KHsgY29udGV4dCwgcGF0aCwgZGF0YSwgY29uZmlnIH0pIHtcXG4gICAgICAgIGNvbnN0IGJhc2VVcmwgPSBnZXRCYXNlVXJsKGNvbnRleHQpO1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGh0dHAucG9zdChiYXNlVXJsICsgcGF0aCwgZGF0YSwgY29uZmlnKTtcXG4gICAgICAgICAgICByZXR1cm4gcmVzcG9uc2UuZGF0YTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgICgwLGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5lcnJvckhhbmRsZXIpKGVycm9yKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRTcGFjZSgpIHtcXG4gICAgICAgIHJldHVybiBnZXQoeyBjb250ZXh0OiAnc3BhY2UnLCBwYXRoOiAnJyB9KTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRDb250ZW50VHlwZShpZCkge1xcbiAgICAgICAgcmV0dXJuIGdldCh7XFxuICAgICAgICAgICAgY29udGV4dDogJ2Vudmlyb25tZW50JyxcXG4gICAgICAgICAgICBwYXRoOiBgY29udGVudF90eXBlcy8ke2lkfWAsXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRDb250ZW50VHlwZXMocXVlcnkgPSB7fSkge1xcbiAgICAgICAgcmV0dXJuIGdldCh7XFxuICAgICAgICAgICAgY29udGV4dDogJ2Vudmlyb25tZW50JyxcXG4gICAgICAgICAgICBwYXRoOiAnY29udGVudF90eXBlcycsXFxuICAgICAgICAgICAgY29uZmlnOiAoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY3JlYXRlUmVxdWVzdENvbmZpZykoeyBxdWVyeSB9KSxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEVudHJ5KGlkLCBxdWVyeSA9IHt9KSB7XFxuICAgICAgICByZXR1cm4gbWFrZUdldEVudHJ5KGlkLCBxdWVyeSwgb3B0aW9ucyk7XFxuICAgIH1cXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0RW50cmllcyhxdWVyeSA9IHt9KSB7XFxuICAgICAgICByZXR1cm4gbWFrZUdldEVudHJpZXMocXVlcnksIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIG1ha2VHZXRFbnRyeShpZCwgcXVlcnksIG9wdGlvbnMgPSB7XFxuICAgICAgICB3aXRoQWxsTG9jYWxlczogZmFsc2UsXFxuICAgICAgICB3aXRob3V0TGlua1Jlc29sdXRpb246IGZhbHNlLFxcbiAgICAgICAgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzOiBmYWxzZSxcXG4gICAgfSkge1xcbiAgICAgICAgY29uc3QgeyB3aXRoQWxsTG9jYWxlcyB9ID0gb3B0aW9ucztcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy52YWxpZGF0ZUxvY2FsZVBhcmFtKShxdWVyeSwgd2l0aEFsbExvY2FsZXMpO1xcbiAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3BhcmFtc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLnZhbGlkYXRlUmVzb2x2ZUxpbmtzUGFyYW0pKHF1ZXJ5KTtcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy52YWxpZGF0ZVJlbW92ZVVucmVzb2x2ZWRQYXJhbSkocXVlcnkpO1xcbiAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3NlYXJjaF9wYXJhbWV0ZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkocXVlcnkpO1xcbiAgICAgICAgcmV0dXJuIGludGVybmFsR2V0RW50cnkoaWQsIHdpdGhBbGxMb2NhbGVzID8geyAuLi5xdWVyeSwgbG9jYWxlOiAnKicgfSA6IHF1ZXJ5LCBvcHRpb25zKTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBpbnRlcm5hbEdldEVudHJ5KGlkLCBxdWVyeSwgb3B0aW9ucykge1xcbiAgICAgICAgaWYgKCFpZCkge1xcbiAgICAgICAgICAgIHRocm93IG5vdEZvdW5kRXJyb3IoaWQpO1xcbiAgICAgICAgfVxcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGludGVybmFsR2V0RW50cmllcyh7ICdzeXMuaWQnOiBpZCwgLi4ucXVlcnkgfSwgb3B0aW9ucyk7XFxuICAgICAgICAgICAgaWYgKHJlc3BvbnNlLml0ZW1zLmxlbmd0aCA+IDApIHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHJlc3BvbnNlLml0ZW1zWzBdO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICBlbHNlIHtcXG4gICAgICAgICAgICAgICAgdGhyb3cgbm90Rm91bmRFcnJvcihpZCk7XFxuICAgICAgICAgICAgfVxcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICAgICAgKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmVycm9ySGFuZGxlcikoZXJyb3IpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIG1ha2VHZXRFbnRyaWVzKHF1ZXJ5LCBvcHRpb25zID0ge1xcbiAgICAgICAgd2l0aEFsbExvY2FsZXM6IGZhbHNlLFxcbiAgICAgICAgd2l0aG91dExpbmtSZXNvbHV0aW9uOiBmYWxzZSxcXG4gICAgICAgIHdpdGhvdXRVbnJlc29sdmFibGVMaW5rczogZmFsc2UsXFxuICAgIH0pIHtcXG4gICAgICAgIGNvbnN0IHsgd2l0aEFsbExvY2FsZXMgfSA9IG9wdGlvbnM7XFxuICAgICAgICAoMCxfdXRpbHNfdmFsaWRhdGVfcGFyYW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18udmFsaWRhdGVMb2NhbGVQYXJhbSkocXVlcnksIHdpdGhBbGxMb2NhbGVzKTtcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy52YWxpZGF0ZVJlc29sdmVMaW5rc1BhcmFtKShxdWVyeSk7XFxuICAgICAgICAoMCxfdXRpbHNfdmFsaWRhdGVfcGFyYW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18udmFsaWRhdGVSZW1vdmVVbnJlc29sdmVkUGFyYW0pKHF1ZXJ5KTtcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9zZWFyY2hfcGFyYW1ldGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl0pKHF1ZXJ5KTtcXG4gICAgICAgIHJldHVybiBpbnRlcm5hbEdldEVudHJpZXMod2l0aEFsbExvY2FsZXNcXG4gICAgICAgICAgICA/IHtcXG4gICAgICAgICAgICAgICAgLi4ucXVlcnksXFxuICAgICAgICAgICAgICAgIGxvY2FsZTogJyonLFxcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICA6IHF1ZXJ5LCBvcHRpb25zKTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBpbnRlcm5hbEdldEVudHJpZXMocXVlcnksIG9wdGlvbnMpIHtcXG4gICAgICAgIGNvbnN0IHsgd2l0aG91dExpbmtSZXNvbHV0aW9uLCB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3MgfSA9IG9wdGlvbnM7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGNvbnN0IGVudHJpZXMgPSBhd2FpdCBnZXQoe1xcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAnZW52aXJvbm1lbnQnLFxcbiAgICAgICAgICAgICAgICBwYXRoOiAnZW50cmllcycsXFxuICAgICAgICAgICAgICAgIGNvbmZpZzogKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNyZWF0ZVJlcXVlc3RDb25maWcpKHsgcXVlcnk6ICgwLF91dGlsc19ub3JtYWxpemVfc2VhcmNoX3BhcmFtZXRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzJfX1tcXFwiZGVmYXVsdFxcXCJdKSgoMCxfdXRpbHNfbm9ybWFsaXplX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fW1xcXCJkZWZhdWx0XFxcIl0pKHF1ZXJ5KSkgfSksXFxuICAgICAgICAgICAgfSk7XFxuICAgICAgICAgICAgcmV0dXJuICgwLF91dGlsc19yZXNvbHZlX2NpcmN1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X19bXFxcImRlZmF1bHRcXFwiXSkoZW50cmllcywge1xcbiAgICAgICAgICAgICAgICByZXNvbHZlTGlua3M6ICF3aXRob3V0TGlua1Jlc29sdXRpb24gPz8gdHJ1ZSxcXG4gICAgICAgICAgICAgICAgcmVtb3ZlVW5yZXNvbHZlZDogd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzID8/IGZhbHNlLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICAgICAgKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmVycm9ySGFuZGxlcikoZXJyb3IpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldEFzc2V0KGlkLCBxdWVyeSA9IHt9KSB7XFxuICAgICAgICByZXR1cm4gbWFrZUdldEFzc2V0KGlkLCBxdWVyeSwgb3B0aW9ucyk7XFxuICAgIH1cXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0QXNzZXRzKHF1ZXJ5ID0ge30pIHtcXG4gICAgICAgIHJldHVybiBtYWtlR2V0QXNzZXRzKHF1ZXJ5LCBvcHRpb25zKTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBtYWtlR2V0QXNzZXRzKHF1ZXJ5LCBvcHRpb25zID0ge1xcbiAgICAgICAgd2l0aEFsbExvY2FsZXM6IGZhbHNlLFxcbiAgICAgICAgd2l0aG91dExpbmtSZXNvbHV0aW9uOiBmYWxzZSxcXG4gICAgICAgIHdpdGhvdXRVbnJlc29sdmFibGVMaW5rczogZmFsc2UsXFxuICAgIH0pIHtcXG4gICAgICAgIGNvbnN0IHsgd2l0aEFsbExvY2FsZXMgfSA9IG9wdGlvbnM7XFxuICAgICAgICAoMCxfdXRpbHNfdmFsaWRhdGVfcGFyYW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18udmFsaWRhdGVMb2NhbGVQYXJhbSkocXVlcnksIHdpdGhBbGxMb2NhbGVzKTtcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9zZWFyY2hfcGFyYW1ldGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfN19fW1xcXCJkZWZhdWx0XFxcIl0pKHF1ZXJ5KTtcXG4gICAgICAgIGNvbnN0IGxvY2FsZVNwZWNpZmljUXVlcnkgPSB3aXRoQWxsTG9jYWxlcyA/IHsgLi4ucXVlcnksIGxvY2FsZTogJyonIH0gOiBxdWVyeTtcXG4gICAgICAgIHJldHVybiBpbnRlcm5hbEdldEFzc2V0cyhsb2NhbGVTcGVjaWZpY1F1ZXJ5KTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBpbnRlcm5hbEdldEFzc2V0KGlkLCBxdWVyeSkge1xcbiAgICAgICAgdHJ5IHtcXG4gICAgICAgICAgICByZXR1cm4gZ2V0KHtcXG4gICAgICAgICAgICAgICAgY29udGV4dDogJ2Vudmlyb25tZW50JyxcXG4gICAgICAgICAgICAgICAgcGF0aDogYGFzc2V0cy8ke2lkfWAsXFxuICAgICAgICAgICAgICAgIGNvbmZpZzogKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmNyZWF0ZVJlcXVlc3RDb25maWcpKHsgcXVlcnk6ICgwLF91dGlsc19ub3JtYWxpemVfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkocXVlcnkpIH0pLFxcbiAgICAgICAgICAgIH0pO1xcbiAgICAgICAgfVxcbiAgICAgICAgY2F0Y2ggKGVycm9yKSB7XFxuICAgICAgICAgICAgKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLmVycm9ySGFuZGxlcikoZXJyb3IpO1xcbiAgICAgICAgfVxcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIG1ha2VHZXRBc3NldChpZCwgcXVlcnksIG9wdGlvbnMgPSB7XFxuICAgICAgICB3aXRoQWxsTG9jYWxlczogZmFsc2UsXFxuICAgICAgICB3aXRob3V0TGlua1Jlc29sdXRpb246IGZhbHNlLFxcbiAgICAgICAgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzOiBmYWxzZSxcXG4gICAgfSkge1xcbiAgICAgICAgY29uc3QgeyB3aXRoQWxsTG9jYWxlcyB9ID0gb3B0aW9ucztcXG4gICAgICAgICgwLF91dGlsc192YWxpZGF0ZV9wYXJhbXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXy52YWxpZGF0ZUxvY2FsZVBhcmFtKShxdWVyeSwgd2l0aEFsbExvY2FsZXMpO1xcbiAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3NlYXJjaF9wYXJhbWV0ZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkocXVlcnkpO1xcbiAgICAgICAgY29uc3QgbG9jYWxlU3BlY2lmaWNRdWVyeSA9IHdpdGhBbGxMb2NhbGVzID8geyAuLi5xdWVyeSwgbG9jYWxlOiAnKicgfSA6IHF1ZXJ5O1xcbiAgICAgICAgcmV0dXJuIGludGVybmFsR2V0QXNzZXQoaWQsIGxvY2FsZVNwZWNpZmljUXVlcnkpO1xcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGludGVybmFsR2V0QXNzZXRzKHF1ZXJ5KSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIHJldHVybiBnZXQoe1xcbiAgICAgICAgICAgICAgICBjb250ZXh0OiAnZW52aXJvbm1lbnQnLFxcbiAgICAgICAgICAgICAgICBwYXRoOiAnYXNzZXRzJyxcXG4gICAgICAgICAgICAgICAgY29uZmlnOiAoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY3JlYXRlUmVxdWVzdENvbmZpZykoeyBxdWVyeTogKDAsX3V0aWxzX25vcm1hbGl6ZV9zZWFyY2hfcGFyYW1ldGVyc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fW1xcXCJkZWZhdWx0XFxcIl0pKCgwLF91dGlsc19ub3JtYWxpemVfc2VsZWN0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX19bXFxcImRlZmF1bHRcXFwiXSkocXVlcnkpKSB9KSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIGNhdGNoIChlcnJvcikge1xcbiAgICAgICAgICAgICgwLGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5lcnJvckhhbmRsZXIpKGVycm9yKTtcXG4gICAgICAgIH1cXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBnZXRUYWcoaWQpIHtcXG4gICAgICAgIHJldHVybiBnZXQoe1xcbiAgICAgICAgICAgIGNvbnRleHQ6ICdlbnZpcm9ubWVudCcsXFxuICAgICAgICAgICAgcGF0aDogYHRhZ3MvJHtpZH1gLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgYXN5bmMgZnVuY3Rpb24gZ2V0VGFncyhxdWVyeSA9IHt9KSB7XFxuICAgICAgICAoMCxfdXRpbHNfdmFsaWRhdGVfc2VhcmNoX3BhcmFtZXRlcnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzdfX1tcXFwiZGVmYXVsdFxcXCJdKShxdWVyeSk7XFxuICAgICAgICByZXR1cm4gZ2V0KHtcXG4gICAgICAgICAgICBjb250ZXh0OiAnZW52aXJvbm1lbnQnLFxcbiAgICAgICAgICAgIHBhdGg6ICd0YWdzJyxcXG4gICAgICAgICAgICBjb25maWc6ICgwLGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5jcmVhdGVSZXF1ZXN0Q29uZmlnKSh7IHF1ZXJ5OiAoMCxfdXRpbHNfbm9ybWFsaXplX3NlYXJjaF9wYXJhbWV0ZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoKDAsX3V0aWxzX25vcm1hbGl6ZV9zZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShxdWVyeSkpIH0pLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgYXN5bmMgZnVuY3Rpb24gY3JlYXRlQXNzZXRLZXkoZXhwaXJlc0F0KSB7XFxuICAgICAgICB0cnkge1xcbiAgICAgICAgICAgIGNvbnN0IG5vdyA9IE1hdGguZmxvb3IoRGF0ZS5ub3coKSAvIDEwMDApO1xcbiAgICAgICAgICAgIGNvbnN0IGN1cnJlbnRNYXhMaWZldGltZSA9IG5vdyArIEFTU0VUX0tFWV9NQVhfTElGRVRJTUU7XFxuICAgICAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3RpbWVzdGFtcF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNV9fW1xcXCJkZWZhdWx0XFxcIl0pKCdleHBpcmVzQXQnLCBleHBpcmVzQXQsIHsgbWF4aW11bTogY3VycmVudE1heExpZmV0aW1lLCBub3cgfSk7XFxuICAgICAgICB9XFxuICAgICAgICBjYXRjaCAoZXJyb3IpIHtcXG4gICAgICAgICAgICAoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uZXJyb3JIYW5kbGVyKShlcnJvcik7XFxuICAgICAgICB9XFxuICAgICAgICByZXR1cm4gcG9zdCh7XFxuICAgICAgICAgICAgY29udGV4dDogJ2Vudmlyb25tZW50JyxcXG4gICAgICAgICAgICBwYXRoOiAnYXNzZXRfa2V5cycsXFxuICAgICAgICAgICAgZGF0YTogeyBleHBpcmVzQXQgfSxcXG4gICAgICAgIH0pO1xcbiAgICB9XFxuICAgIGFzeW5jIGZ1bmN0aW9uIGdldExvY2FsZXMocXVlcnkgPSB7fSkge1xcbiAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3NlYXJjaF9wYXJhbWV0ZXJzX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X19bXFxcImRlZmF1bHRcXFwiXSkocXVlcnkpO1xcbiAgICAgICAgcmV0dXJuIGdldCh7XFxuICAgICAgICAgICAgY29udGV4dDogJ2Vudmlyb25tZW50JyxcXG4gICAgICAgICAgICBwYXRoOiAnbG9jYWxlcycsXFxuICAgICAgICAgICAgY29uZmlnOiAoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uY3JlYXRlUmVxdWVzdENvbmZpZykoeyBxdWVyeTogKDAsX3V0aWxzX25vcm1hbGl6ZV9zZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfX1tcXFwiZGVmYXVsdFxcXCJdKShxdWVyeSkgfSksXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBzeW5jKHF1ZXJ5LCBzeW5jT3B0aW9ucyA9IHsgcGFnaW5hdGU6IHRydWUgfSkge1xcbiAgICAgICAgcmV0dXJuIG1ha2VQYWdlZFN5bmMocXVlcnksIHN5bmNPcHRpb25zLCBvcHRpb25zKTtcXG4gICAgfVxcbiAgICBhc3luYyBmdW5jdGlvbiBtYWtlUGFnZWRTeW5jKHF1ZXJ5LCBzeW5jT3B0aW9ucywgb3B0aW9ucyA9IHtcXG4gICAgICAgIHdpdGhBbGxMb2NhbGVzOiBmYWxzZSxcXG4gICAgICAgIHdpdGhvdXRMaW5rUmVzb2x1dGlvbjogZmFsc2UsXFxuICAgICAgICB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3M6IGZhbHNlLFxcbiAgICB9KSB7XFxuICAgICAgICAoMCxfdXRpbHNfdmFsaWRhdGVfcGFyYW1zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18udmFsaWRhdGVSZXNvbHZlTGlua3NQYXJhbSkocXVlcnkpO1xcbiAgICAgICAgKDAsX3V0aWxzX3ZhbGlkYXRlX3BhcmFtc19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNl9fLnZhbGlkYXRlUmVtb3ZlVW5yZXNvbHZlZFBhcmFtKShxdWVyeSk7XFxuICAgICAgICBjb25zdCBjb21iaW5lZE9wdGlvbnMgPSB7XFxuICAgICAgICAgICAgLi4uc3luY09wdGlvbnMsXFxuICAgICAgICAgICAgLi4ub3B0aW9ucyxcXG4gICAgICAgIH07XFxuICAgICAgICBzd2l0Y2hUb0Vudmlyb25tZW50KGh0dHApO1xcbiAgICAgICAgcmV0dXJuICgwLF9wYWdlZF9zeW5jX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX19bXFxcImRlZmF1bHRcXFwiXSkoaHR0cCwgcXVlcnksIGNvbWJpbmVkT3B0aW9ucyk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gcGFyc2VFbnRyaWVzKGRhdGEpIHtcXG4gICAgICAgIHJldHVybiBtYWtlUGFyc2VFbnRyaWVzKGRhdGEsIG9wdGlvbnMpO1xcbiAgICB9XFxuICAgIGZ1bmN0aW9uIG1ha2VQYXJzZUVudHJpZXMoZGF0YSwgb3B0aW9ucyA9IHtcXG4gICAgICAgIHdpdGhBbGxMb2NhbGVzOiBmYWxzZSxcXG4gICAgICAgIHdpdGhvdXRMaW5rUmVzb2x1dGlvbjogZmFsc2UsXFxuICAgICAgICB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3M6IGZhbHNlLFxcbiAgICB9KSB7XFxuICAgICAgICByZXR1cm4gaW50ZXJuYWxQYXJzZUVudHJpZXMoZGF0YSwgb3B0aW9ucyk7XFxuICAgIH1cXG4gICAgZnVuY3Rpb24gaW50ZXJuYWxQYXJzZUVudHJpZXMoZGF0YSwgb3B0aW9ucykge1xcbiAgICAgICAgY29uc3QgeyB3aXRob3V0TGlua1Jlc29sdXRpb24sIHdpdGhvdXRVbnJlc29sdmFibGVMaW5rcyB9ID0gb3B0aW9ucztcXG4gICAgICAgIHJldHVybiAoMCxfdXRpbHNfcmVzb2x2ZV9jaXJjdWxhcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfNF9fW1xcXCJkZWZhdWx0XFxcIl0pKGRhdGEsIHtcXG4gICAgICAgICAgICByZXNvbHZlTGlua3M6ICF3aXRob3V0TGlua1Jlc29sdXRpb24gPz8gdHJ1ZSxcXG4gICAgICAgICAgICByZW1vdmVVbnJlc29sdmVkOiB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3MgPz8gZmFsc2UsXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICAvKlxcbiAgICAgKiBTd2l0Y2hlcyBCYXNlVVJMIHRvIHVzZSAvZW52aXJvbm1lbnRzIHBhdGhcXG4gICAgICogKi9cXG4gICAgZnVuY3Rpb24gc3dpdGNoVG9FbnZpcm9ubWVudChodHRwKSB7XFxuICAgICAgICBodHRwLmRlZmF1bHRzLmJhc2VVUkwgPSBnZXRHbG9iYWxPcHRpb25zKCkuZW52aXJvbm1lbnRCYXNlVXJsO1xcbiAgICB9XFxuICAgIHJldHVybiB7XFxuICAgICAgICB2ZXJzaW9uOiBcXFwiMTAuMS4wXFxcIixcXG4gICAgICAgIGdldFNwYWNlLFxcbiAgICAgICAgZ2V0Q29udGVudFR5cGUsXFxuICAgICAgICBnZXRDb250ZW50VHlwZXMsXFxuICAgICAgICBnZXRBc3NldCxcXG4gICAgICAgIGdldEFzc2V0cyxcXG4gICAgICAgIGdldFRhZyxcXG4gICAgICAgIGdldFRhZ3MsXFxuICAgICAgICBnZXRMb2NhbGVzLFxcbiAgICAgICAgcGFyc2VFbnRyaWVzLFxcbiAgICAgICAgc3luYyxcXG4gICAgICAgIGdldEVudHJ5LFxcbiAgICAgICAgZ2V0RW50cmllcyxcXG4gICAgICAgIGNyZWF0ZUFzc2V0S2V5LFxcbiAgICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vY3JlYXRlLWNvbnRlbnRmdWwtYXBpLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9jcmVhdGUtZ2xvYmFsLW9wdGlvbnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9jcmVhdGUtZ2xvYmFsLW9wdGlvbnMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNyZWF0ZUdsb2JhbE9wdGlvbnNcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBjcmVhdGVHbG9iYWxPcHRpb25zKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qKlxcbiAqIEBwYXJhbSBnbG9iYWxTZXR0aW5ncyAtIEdsb2JhbCBsaWJyYXJ5IHNldHRpbmdzXFxuICogQHJldHVybnMgZ2V0R2xvYmFsU2V0dGluZ3MgLSBNZXRob2QgcmV0dXJuaW5nIGNsaWVudCBzZXR0aW5nc1xcbiAqIEBjYXRlZ29yeSBDbGllbnRcXG4gKi9cXG5mdW5jdGlvbiBjcmVhdGVHbG9iYWxPcHRpb25zKGdsb2JhbFNldHRpbmdzKSB7XFxuICAgIC8qKlxcbiAgICAgKiBNZXRob2QgbWVyZ2luZyBwcmUtY29uZmlndXJlZCBnbG9iYWwgb3B0aW9ucyBhbmQgcHJvdmlkZWQgbG9jYWwgcGFyYW1ldGVyc1xcbiAgICAgKiBAcGFyYW0gcXVlcnkgLSByZWd1bGFyIHF1ZXJ5IG9iamVjdCB1c2VkIGZvciBjb2xsZWN0aW9uIGVuZHBvaW50c1xcbiAgICAgKiBAcGFyYW0gcXVlcnkuZW52aXJvbm1lbnQgLSBvcHRpb25hbCBuYW1lIG9mIHRoZSBlbnZpcm9ubWVudFxcbiAgICAgKiBAcGFyYW0gcXVlcnkuc3BhY2UgLSBvcHRpb25hbCBzcGFjZSBJRFxcbiAgICAgKiBAcGFyYW0gcXVlcnkuc3BhY2VCYXNlVXJsIC0gb3B0aW9uYWwgYmFzZSBVUkwgZm9yIHRoZSBzcGFjZVxcbiAgICAgKiBAcGFyYW0gcXVlcnkuZW52aXJvbm1lbnRCYXNlVXJsIC0gb3B0aW9uYWwgYmFzZSBVUkwgZm9yIHRoZSBlbnZpcm9ubWVudFxcbiAgICAgKiBAcmV0dXJucyBnbG9iYWwgb3B0aW9uc1xcbiAgICAgKi9cXG4gICAgcmV0dXJuIGZ1bmN0aW9uIGdldEdsb2JhbE9wdGlvbnMocXVlcnkpIHtcXG4gICAgICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBnbG9iYWxTZXR0aW5ncywgcXVlcnkpO1xcbiAgICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vY3JlYXRlLWdsb2JhbC1vcHRpb25zLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiY3JlYXRlQ2xpZW50XFxcIjogKCkgPT4gKC8qIHJlZXhwb3J0IHNhZmUgKi8gX2NvbnRlbnRmdWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5jcmVhdGVDbGllbnQpLFxcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImNyZWF0ZUdsb2JhbE9wdGlvbnNcXFwiOiAoKSA9PiAoLyogcmVleHBvcnQgc2FmZSAqLyBfY3JlYXRlX2dsb2JhbF9vcHRpb25zX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uY3JlYXRlR2xvYmFsT3B0aW9ucylcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NvbnRlbnRmdWxfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY29udGVudGZ1bCAqLyBcXFwiLi9jb250ZW50ZnVsLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jcmVhdGVfZ2xvYmFsX29wdGlvbnNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vY3JlYXRlLWdsb2JhbC1vcHRpb25zICovIFxcXCIuL2NyZWF0ZS1nbG9iYWwtb3B0aW9ucy50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbWl4aW5zX3N0cmluZ2lmeV9zYWZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21peGlucy9zdHJpbmdpZnktc2FmZSAqLyBcXFwiLi9taXhpbnMvc3RyaW5naWZ5LXNhZmUudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3V0aWxzX25vcm1hbGl6ZV9zZWxlY3RfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdXRpbHMvbm9ybWFsaXplLXNlbGVjdCAqLyBcXFwiLi91dGlscy9ub3JtYWxpemUtc2VsZWN0LnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF91dGlsc19yZXNvbHZlX2NpcmN1bGFyX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3V0aWxzL3Jlc29sdmUtY2lyY3VsYXIgKi8gXFxcIi4vdXRpbHMvcmVzb2x2ZS1jaXJjdWxhci50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfdHlwZXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzVfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdHlwZXMgKi8gXFxcIi4vdHlwZXMvaW5kZXgudHNcXFwiKTtcXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vaW5kZXgudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL21ha2UtY2xpZW50LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi9tYWtlLWNsaWVudC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJtYWtlQ2xpZW50XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbWFrZUNsaWVudClcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2NyZWF0ZV9jb250ZW50ZnVsX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9jcmVhdGUtY29udGVudGZ1bC1hcGkgKi8gXFxcIi4vY3JlYXRlLWNvbnRlbnRmdWwtYXBpLnRzXFxcIik7XFxuXFxuZnVuY3Rpb24gY3JlYXRlKHsgaHR0cCwgZ2V0R2xvYmFsT3B0aW9ucyB9LCBvcHRpb25zLCBtYWtlSW5uZXJDbGllbnQpIHtcXG4gICAgY29uc3QgY2xpZW50ID0gKDAsX2NyZWF0ZV9jb250ZW50ZnVsX2FwaV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKHtcXG4gICAgICAgIGh0dHAsXFxuICAgICAgICBnZXRHbG9iYWxPcHRpb25zLFxcbiAgICB9LCBvcHRpb25zKTtcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBjbGllbnQ7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3dpdGhBbGxMb2NhbGVzJywge1xcbiAgICAgICAgZ2V0OiAoKSA9PiBtYWtlSW5uZXJDbGllbnQoeyAuLi5vcHRpb25zLCB3aXRoQWxsTG9jYWxlczogdHJ1ZSB9KSxcXG4gICAgfSk7XFxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShyZXNwb25zZSwgJ3dpdGhvdXRMaW5rUmVzb2x1dGlvbicsIHtcXG4gICAgICAgIGdldDogKCkgPT4gbWFrZUlubmVyQ2xpZW50KHsgLi4ub3B0aW9ucywgd2l0aG91dExpbmtSZXNvbHV0aW9uOiB0cnVlIH0pLFxcbiAgICB9KTtcXG4gICAgT2JqZWN0LmRlZmluZVByb3BlcnR5KHJlc3BvbnNlLCAnd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzJywge1xcbiAgICAgICAgZ2V0OiAoKSA9PiBtYWtlSW5uZXJDbGllbnQoeyAuLi5vcHRpb25zLCB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3M6IHRydWUgfSksXFxuICAgIH0pO1xcbiAgICByZXR1cm4gT2JqZWN0LmNyZWF0ZShyZXNwb25zZSk7XFxufVxcbmNvbnN0IG1ha2VDbGllbnQgPSAoeyBodHRwLCBnZXRHbG9iYWxPcHRpb25zLCB9KSA9PiB7XFxuICAgIGZ1bmN0aW9uIG1ha2VJbm5lckNsaWVudChvcHRpb25zKSB7XFxuICAgICAgICByZXR1cm4gY3JlYXRlKHsgaHR0cCwgZ2V0R2xvYmFsT3B0aW9ucyB9LCBvcHRpb25zLCBtYWtlSW5uZXJDbGllbnQpO1xcbiAgICB9XFxuICAgIGNvbnN0IGNsaWVudCA9ICgwLF9jcmVhdGVfY29udGVudGZ1bF9hcGlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX1tcXFwiZGVmYXVsdFxcXCJdKSh7IGh0dHAsIGdldEdsb2JhbE9wdGlvbnMgfSwge1xcbiAgICAgICAgd2l0aG91dExpbmtSZXNvbHV0aW9uOiBmYWxzZSxcXG4gICAgICAgIHdpdGhBbGxMb2NhbGVzOiBmYWxzZSxcXG4gICAgICAgIHdpdGhvdXRVbnJlc29sdmFibGVMaW5rczogZmFsc2UsXFxuICAgIH0pO1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgLi4uY2xpZW50LFxcbiAgICAgICAgZ2V0IHdpdGhBbGxMb2NhbGVzKCkge1xcbiAgICAgICAgICAgIHJldHVybiBtYWtlSW5uZXJDbGllbnQoe1xcbiAgICAgICAgICAgICAgICB3aXRoQWxsTG9jYWxlczogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgd2l0aG91dExpbmtSZXNvbHV0aW9uOiBmYWxzZSxcXG4gICAgICAgICAgICAgICAgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzOiBmYWxzZSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXQgd2l0aG91dExpbmtSZXNvbHV0aW9uKCkge1xcbiAgICAgICAgICAgIHJldHVybiBtYWtlSW5uZXJDbGllbnQoe1xcbiAgICAgICAgICAgICAgICB3aXRoQWxsTG9jYWxlczogZmFsc2UsXFxuICAgICAgICAgICAgICAgIHdpdGhvdXRMaW5rUmVzb2x1dGlvbjogdHJ1ZSxcXG4gICAgICAgICAgICAgICAgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzOiBmYWxzZSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgICAgICBnZXQgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzKCkge1xcbiAgICAgICAgICAgIHJldHVybiBtYWtlSW5uZXJDbGllbnQoe1xcbiAgICAgICAgICAgICAgICB3aXRoQWxsTG9jYWxlczogZmFsc2UsXFxuICAgICAgICAgICAgICAgIHdpdGhvdXRMaW5rUmVzb2x1dGlvbjogZmFsc2UsXFxuICAgICAgICAgICAgICAgIHdpdGhvdXRVbnJlc29sdmFibGVMaW5rczogdHJ1ZSxcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgIH07XFxufTtcXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vbWFrZS1jbGllbnQudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL21peGlucy9zdHJpbmdpZnktc2FmZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL21peGlucy9zdHJpbmdpZnktc2FmZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIG1peGluU3RyaW5naWZ5U2FmZSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIganNvbl9zdHJpbmdpZnlfc2FmZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEganNvbi1zdHJpbmdpZnktc2FmZSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2pzb24tc3RyaW5naWZ5LXNhZmUvc3RyaW5naWZ5LmpzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIGpzb25fc3RyaW5naWZ5X3NhZmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfX19kZWZhdWx0ID0gLyojX19QVVJFX18qL19fd2VicGFja19yZXF1aXJlX18ubihqc29uX3N0cmluZ2lmeV9zYWZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18pO1xcblxcbmZ1bmN0aW9uIG1peGluU3RyaW5naWZ5U2FmZShkYXRhKSB7XFxuICAgIHJldHVybiBPYmplY3QuZGVmaW5lUHJvcGVydHkoZGF0YSwgJ3N0cmluZ2lmeVNhZmUnLCB7XFxuICAgICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcXG4gICAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXFxuICAgICAgICB3cml0YWJsZTogZmFsc2UsXFxuICAgICAgICB2YWx1ZTogZnVuY3Rpb24gKHNlcmlhbGl6ZXIgPSBudWxsLCBpbmRlbnQgPSAnJykge1xcbiAgICAgICAgICAgIHJldHVybiBqc29uX3N0cmluZ2lmeV9zYWZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19fZGVmYXVsdCgpKHRoaXMsIHNlcmlhbGl6ZXIsIGluZGVudCwgKGtleSwgdmFsdWUpID0+IHtcXG4gICAgICAgICAgICAgICAgcmV0dXJuIHtcXG4gICAgICAgICAgICAgICAgICAgIHN5czoge1xcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGU6ICdMaW5rJyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBsaW5rVHlwZTogJ0VudHJ5JyxcXG4gICAgICAgICAgICAgICAgICAgICAgICBpZDogdmFsdWUuc3lzLmlkLFxcbiAgICAgICAgICAgICAgICAgICAgICAgIGNpcmN1bGFyOiB0cnVlLFxcbiAgICAgICAgICAgICAgICAgICAgfSxcXG4gICAgICAgICAgICAgICAgfTtcXG4gICAgICAgICAgICB9KTtcXG4gICAgICAgIH0sXFxuICAgIH0pO1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vbWl4aW5zL3N0cmluZ2lmeS1zYWZlLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi9wYWdlZC1zeW5jLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3BhZ2VkLXN5bmMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gcGFnZWRTeW5jKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb250ZW50ZnVsX3Jlc29sdmVfcmVzcG9uc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZS9kaXN0L2VzbS9pbmRleC5qc1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISBjb250ZW50ZnVsLXNkay1jb3JlICovIFxcXCIuLi9ub2RlX21vZHVsZXMvY29udGVudGZ1bC1zZGstY29yZS9kaXN0L2luZGV4LmVzLW1vZHVsZXMuanNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zdHJpbmdpZnlfc2FmZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMl9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9taXhpbnMvc3RyaW5naWZ5LXNhZmUgKi8gXFxcIi4vbWl4aW5zL3N0cmluZ2lmeS1zYWZlLnRzXFxcIik7XFxuXFxuXFxuXFxuLyoqXFxuICogUmV0cmlldmVzIGFsbCB0aGUgYXZhaWxhYmxlIHBhZ2VzIGZvciBhIHN5bmMgb3BlcmF0aW9uXFxuICovXFxuYXN5bmMgZnVuY3Rpb24gcGFnZWRTeW5jKGh0dHAsIHF1ZXJ5LCBvcHRpb25zKSB7XFxuICAgIGlmICghcXVlcnkgfHwgKCFxdWVyeS5pbml0aWFsICYmICFxdWVyeS5uZXh0U3luY1Rva2VuICYmICFxdWVyeS5uZXh0UGFnZVRva2VuKSkge1xcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKCdQbGVhc2UgcHJvdmlkZSBvbmUgb2YgYGluaXRpYWxgLCBgbmV4dFN5bmNUb2tlbmAgb3IgYG5leHRQYWdlVG9rZW5gIHBhcmFtZXRlcnMgZm9yIHN5bmNpbmcnKTtcXG4gICAgfVxcbiAgICBpZiAocXVlcnlbJ2NvbnRlbnRfdHlwZSddICYmICFxdWVyeS50eXBlKSB7XFxuICAgICAgICBxdWVyeS50eXBlID0gJ0VudHJ5JztcXG4gICAgfVxcbiAgICBlbHNlIGlmIChxdWVyeVsnY29udGVudF90eXBlJ10gJiYgcXVlcnkudHlwZSAmJiBxdWVyeS50eXBlICE9PSAnRW50cnknKSB7XFxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ1doZW4gdXNpbmcgdGhlIGBjb250ZW50X3R5cGVgIGZpbHRlciB5b3VyIGB0eXBlYCBwYXJhbWV0ZXIgY2Fubm90IGJlIGRpZmZlcmVudCBmcm9tIGBFbnRyeWAuJyk7XFxuICAgIH1cXG4gICAgY29uc3QgZGVmYXVsdE9wdGlvbnMgPSB7XFxuICAgICAgICB3aXRob3V0TGlua1Jlc29sdXRpb246IGZhbHNlLFxcbiAgICAgICAgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzOiBmYWxzZSxcXG4gICAgICAgIHBhZ2luYXRlOiB0cnVlLFxcbiAgICB9O1xcbiAgICBjb25zdCB7IHdpdGhvdXRMaW5rUmVzb2x1dGlvbiwgd2l0aG91dFVucmVzb2x2YWJsZUxpbmtzLCBwYWdpbmF0ZSB9ID0ge1xcbiAgICAgICAgLi4uZGVmYXVsdE9wdGlvbnMsXFxuICAgICAgICAuLi5vcHRpb25zLFxcbiAgICB9O1xcbiAgICBjb25zdCByZXNwb25zZSA9IGF3YWl0IGdldFN5bmNQYWdlKGh0dHAsIFtdLCBxdWVyeSwgeyBwYWdpbmF0ZSB9KTtcXG4gICAgLy8gY2xvbmVzIHJlc3BvbnNlLml0ZW1zIHVzZWQgaW4gaW5jbHVkZXMgYmVjYXVzZSB3ZSBkb24ndCB3YW50IHRoZXNlIHRvIGJlIG11dGF0ZWRcXG4gICAgaWYgKCF3aXRob3V0TGlua1Jlc29sdXRpb24pIHtcXG4gICAgICAgIHJlc3BvbnNlLml0ZW1zID0gKDAsY29udGVudGZ1bF9yZXNvbHZlX3Jlc3BvbnNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX19bXFxcImRlZmF1bHRcXFwiXSkocmVzcG9uc2UsIHtcXG4gICAgICAgICAgICByZW1vdmVVbnJlc29sdmVkOiB3aXRob3V0VW5yZXNvbHZhYmxlTGlua3MsXFxuICAgICAgICAgICAgaXRlbUVudHJ5UG9pbnRzOiBbJ2ZpZWxkcyddLFxcbiAgICAgICAgfSk7XFxuICAgIH1cXG4gICAgLy8gbWFwcyByZXNwb25zZSBpdGVtcyBhZ2FpbiBhZnRlciBnZXR0ZXJzIGFyZSBhdHRhY2hlZFxcbiAgICBjb25zdCBtYXBwZWRSZXNwb25zZUl0ZW1zID0gbWFwUmVzcG9uc2VJdGVtcyhyZXNwb25zZS5pdGVtcyk7XFxuICAgIGlmIChyZXNwb25zZS5uZXh0U3luY1Rva2VuKSB7XFxuICAgICAgICBtYXBwZWRSZXNwb25zZUl0ZW1zLm5leHRTeW5jVG9rZW4gPSByZXNwb25zZS5uZXh0U3luY1Rva2VuO1xcbiAgICB9XFxuICAgIGlmIChyZXNwb25zZS5uZXh0UGFnZVRva2VuKSB7XFxuICAgICAgICBtYXBwZWRSZXNwb25zZUl0ZW1zLm5leHRQYWdlVG9rZW4gPSByZXNwb25zZS5uZXh0UGFnZVRva2VuO1xcbiAgICB9XFxuICAgIHJldHVybiAoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18uZnJlZXplU3lzKSgoMCxfbWl4aW5zX3N0cmluZ2lmeV9zYWZlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX19bXFxcImRlZmF1bHRcXFwiXSkoKDAsY29udGVudGZ1bF9zZGtfY29yZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fLnRvUGxhaW5PYmplY3QpKG1hcHBlZFJlc3BvbnNlSXRlbXMpKSk7XFxufVxcbi8qKlxcbiAqIEBwcml2YXRlXFxuICogQHBhcmFtIGl0ZW1zXFxuICogQHJldHVybnMgRW50aXRpZXMgbWFwcGVkIHRvIGFuIG9iamVjdCBmb3IgZWFjaCBlbnRpdHkgdHlwZVxcbiAqL1xcbmZ1bmN0aW9uIG1hcFJlc3BvbnNlSXRlbXMoaXRlbXMpIHtcXG4gICAgY29uc3QgcmVkdWNlciA9ICh0eXBlKSA9PiB7XFxuICAgICAgICByZXR1cm4gKGFjY3VtdWxhdGVkLCBpdGVtKSA9PiB7XFxuICAgICAgICAgICAgaWYgKGl0ZW0uc3lzLnR5cGUgPT09IHR5cGUpIHtcXG4gICAgICAgICAgICAgICAgYWNjdW11bGF0ZWQucHVzaCgoMCxjb250ZW50ZnVsX3Nka19jb3JlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18udG9QbGFpbk9iamVjdCkoaXRlbSkpO1xcbiAgICAgICAgICAgIH1cXG4gICAgICAgICAgICByZXR1cm4gYWNjdW11bGF0ZWQ7XFxuICAgICAgICB9O1xcbiAgICB9O1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgZW50cmllczogaXRlbXMucmVkdWNlKHJlZHVjZXIoJ0VudHJ5JyksIFtdKSxcXG4gICAgICAgIGFzc2V0czogaXRlbXMucmVkdWNlKHJlZHVjZXIoJ0Fzc2V0JyksIFtdKSxcXG4gICAgICAgIGRlbGV0ZWRFbnRyaWVzOiBpdGVtcy5yZWR1Y2UocmVkdWNlcignRGVsZXRlZEVudHJ5JyksIFtdKSxcXG4gICAgICAgIGRlbGV0ZWRBc3NldHM6IGl0ZW1zLnJlZHVjZShyZWR1Y2VyKCdEZWxldGVkQXNzZXQnKSwgW10pLFxcbiAgICB9O1xcbn1cXG5mdW5jdGlvbiBjcmVhdGVSZXF1ZXN0UXVlcnkob3JpZ2luYWxRdWVyeSkge1xcbiAgICBpZiAob3JpZ2luYWxRdWVyeS5uZXh0UGFnZVRva2VuKSB7XFxuICAgICAgICByZXR1cm4geyBzeW5jX3Rva2VuOiBvcmlnaW5hbFF1ZXJ5Lm5leHRQYWdlVG9rZW4gfTtcXG4gICAgfVxcbiAgICBpZiAob3JpZ2luYWxRdWVyeS5uZXh0U3luY1Rva2VuKSB7XFxuICAgICAgICByZXR1cm4geyBzeW5jX3Rva2VuOiBvcmlnaW5hbFF1ZXJ5Lm5leHRTeW5jVG9rZW4gfTtcXG4gICAgfVxcbiAgICBpZiAob3JpZ2luYWxRdWVyeS5zeW5jX3Rva2VuKSB7XFxuICAgICAgICByZXR1cm4geyBzeW5jX3Rva2VuOiBvcmlnaW5hbFF1ZXJ5LnN5bmNfdG9rZW4gfTtcXG4gICAgfVxcbiAgICByZXR1cm4gb3JpZ2luYWxRdWVyeTtcXG59XFxuLyoqXFxuICogSWYgdGhlIHJlc3BvbnNlIGNvbnRhaW5zIGEgbmV4dFBhZ2VVcmwsIGV4dHJhY3RzIHRoZSBzeW5jIHRva2VuIHRvIGdldCB0aGVcXG4gKiBuZXh0IHBhZ2UgYW5kIGNhbGxzIGl0c2VsZiBhZ2FpbiB3aXRoIHRoYXQgdG9rZW4uXFxuICogT3RoZXJ3aXNlLCBpZiB0aGUgcmVzcG9uc2UgY29udGFpbnMgYSBuZXh0U3luY1VybCwgZXh0cmFjdHMgdGhlIHN5bmMgdG9rZW5cXG4gKiBhbmQgcmV0dXJucyBpdC5cXG4gKiBPbiBlYWNoIGNhbGwgb2YgdGhpcyBmdW5jdGlvbiwgYW55IHJldHJpZXZlZCBpdGVtcyBhcmUgY29sbGVjdGVkIGluIHRoZVxcbiAqIHN1cHBsaWVkIGl0ZW1zIGFycmF5LCB3aGljaCBnZXRzIHJldHVybmVkIGluIHRoZSBlbmQuXFxuICovXFxuYXN5bmMgZnVuY3Rpb24gZ2V0U3luY1BhZ2UoaHR0cCwgaXRlbXMsIHF1ZXJ5LCB7IHBhZ2luYXRlIH0pIHtcXG4gICAgY29uc3QgcmVxdWVzdFF1ZXJ5ID0gY3JlYXRlUmVxdWVzdFF1ZXJ5KHF1ZXJ5KTtcXG4gICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBodHRwLmdldCgnc3luYycsICgwLGNvbnRlbnRmdWxfc2RrX2NvcmVfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXy5jcmVhdGVSZXF1ZXN0Q29uZmlnKSh7IHF1ZXJ5OiByZXF1ZXN0UXVlcnkgfSkpO1xcbiAgICBjb25zdCBkYXRhID0gcmVzcG9uc2UuZGF0YSB8fCB7fTtcXG4gICAgaXRlbXMgPSBpdGVtcy5jb25jYXQoZGF0YS5pdGVtcyB8fCBbXSk7XFxuICAgIGlmIChkYXRhLm5leHRQYWdlVXJsKSB7XFxuICAgICAgICBpZiAocGFnaW5hdGUpIHtcXG4gICAgICAgICAgICBkZWxldGUgcmVxdWVzdFF1ZXJ5LmluaXRpYWw7XFxuICAgICAgICAgICAgcmVxdWVzdFF1ZXJ5LnN5bmNfdG9rZW4gPSBnZXRUb2tlbihkYXRhLm5leHRQYWdlVXJsKTtcXG4gICAgICAgICAgICByZXR1cm4gZ2V0U3luY1BhZ2UoaHR0cCwgaXRlbXMsIHJlcXVlc3RRdWVyeSwgeyBwYWdpbmF0ZSB9KTtcXG4gICAgICAgIH1cXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXRlbXMsXFxuICAgICAgICAgICAgbmV4dFBhZ2VUb2tlbjogZ2V0VG9rZW4oZGF0YS5uZXh0UGFnZVVybCksXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIGVsc2UgaWYgKGRhdGEubmV4dFN5bmNVcmwpIHtcXG4gICAgICAgIHJldHVybiB7XFxuICAgICAgICAgICAgaXRlbXMsXFxuICAgICAgICAgICAgbmV4dFN5bmNUb2tlbjogZ2V0VG9rZW4oZGF0YS5uZXh0U3luY1VybCksXFxuICAgICAgICB9O1xcbiAgICB9XFxuICAgIGVsc2Uge1xcbiAgICAgICAgcmV0dXJuIHsgaXRlbXM6IFtdIH07XFxuICAgIH1cXG59XFxuLyoqXFxuICogRXh0cmFjdHMgdG9rZW4gb3V0IG9mIGFuIHVybFxcbiAqIEBwcml2YXRlXFxuICovXFxuZnVuY3Rpb24gZ2V0VG9rZW4odXJsKSB7XFxuICAgIGNvbnN0IHVybFBhcnRzID0gdXJsLnNwbGl0KCc/Jyk7XFxuICAgIHJldHVybiB1cmxQYXJ0cy5sZW5ndGggPiAwID8gdXJsUGFydHNbMV0ucmVwbGFjZSgnc3luY190b2tlbj0nLCAnJykgOiAnJztcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3BhZ2VkLXN5bmMudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL2Fzc2V0LWtleS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL2Fzc2V0LWtleS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9hc3NldC1rZXkudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL2Fzc2V0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9hc3NldC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL2Fzc2V0LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9jb2xsZWN0aW9uLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL2NvbGxlY3Rpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL2NvbGxlY3Rpb24udHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL2NvbnRlbnQtdHlwZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL2NvbnRlbnQtdHlwZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9jb250ZW50LXR5cGUudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL2VudHJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9lbnRyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL2VudHJ5LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9pbmRleC50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvaW5kZXgudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfYXNzZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vYXNzZXQgKi8gXFxcIi4vdHlwZXMvYXNzZXQudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2Fzc2V0X2tleV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9hc3NldC1rZXkgKi8gXFxcIi4vdHlwZXMvYXNzZXQta2V5LnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9jb2xsZWN0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbGxlY3Rpb24gKi8gXFxcIi4vdHlwZXMvY29sbGVjdGlvbi50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfY29udGVudF90eXBlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8zX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2NvbnRlbnQtdHlwZSAqLyBcXFwiLi90eXBlcy9jb250ZW50LXR5cGUudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2VudHJ5X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV80X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2VudHJ5ICovIFxcXCIuL3R5cGVzL2VudHJ5LnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9saW5rX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xpbmsgKi8gXFxcIi4vdHlwZXMvbGluay50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfbG9jYWxlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV82X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvY2FsZSAqLyBcXFwiLi90eXBlcy9sb2NhbGUudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21ldGFkYXRhX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL21ldGFkYXRhICovIFxcXCIuL3R5cGVzL21ldGFkYXRhLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9xdWVyeV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9xdWVyeSAqLyBcXFwiLi90eXBlcy9xdWVyeS9pbmRleC50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcmVzb3VyY2VfbGlua19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOV9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9yZXNvdXJjZS1saW5rICovIFxcXCIuL3R5cGVzL3Jlc291cmNlLWxpbmsudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NwYWNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zcGFjZSAqLyBcXFwiLi90eXBlcy9zcGFjZS50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3luY19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc3luYyAqLyBcXFwiLi90eXBlcy9zeW5jLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zeXNfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzEyX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3N5cyAqLyBcXFwiLi90eXBlcy9zeXMudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3RhZ19fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMTNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdGFnICovIFxcXCIuL3R5cGVzL3RhZy50c1xcXCIpO1xcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9pbmRleC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvbGluay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9saW5rLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9saW5rLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9sb2NhbGUudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9sb2NhbGUudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdHlwZXMvbG9jYWxlLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9tZXRhZGF0YS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvbWV0YWRhdGEudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9tZXRhZGF0YS50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvZXF1YWxpdHkudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL3F1ZXJ5L2VxdWFsaXR5LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdHlwZXMvcXVlcnkvZXF1YWxpdHkudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL3F1ZXJ5L2V4aXN0ZW5jZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL3F1ZXJ5L2V4aXN0ZW5jZS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9xdWVyeS9leGlzdGVuY2UudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL3F1ZXJ5L2luZGV4LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9xdWVyeS9pbmRleC50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9lcXVhbGl0eV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9lcXVhbGl0eSAqLyBcXFwiLi90eXBlcy9xdWVyeS9lcXVhbGl0eS50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfZXhpc3RlbmNlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2V4aXN0ZW5jZSAqLyBcXFwiLi90eXBlcy9xdWVyeS9leGlzdGVuY2UudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX2xvY2F0aW9uX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8yX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL2xvY2F0aW9uICovIFxcXCIuL3R5cGVzL3F1ZXJ5L2xvY2F0aW9uLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9vcmRlcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfM19fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9vcmRlciAqLyBcXFwiLi90eXBlcy9xdWVyeS9vcmRlci50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfcXVlcnlfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzRfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcXVlcnkgKi8gXFxcIi4vdHlwZXMvcXVlcnkvcXVlcnkudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3JhbmdlX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV81X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3JhbmdlICovIFxcXCIuL3R5cGVzL3F1ZXJ5L3JhbmdlLnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9yZWZlcmVuY2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzZfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vcmVmZXJlbmNlICovIFxcXCIuL3R5cGVzL3F1ZXJ5L3JlZmVyZW5jZS50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc2VhcmNoX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV83X18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3NlYXJjaCAqLyBcXFwiLi90eXBlcy9xdWVyeS9zZWFyY2gudHNcXFwiKTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3NlbGVjdF9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfOF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zZWxlY3QgKi8gXFxcIi4vdHlwZXMvcXVlcnkvc2VsZWN0LnRzXFxcIik7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF9zZXRfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzlfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vc2V0ICovIFxcXCIuL3R5cGVzL3F1ZXJ5L3NldC50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBfc3Vic2V0X19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8xMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi9zdWJzZXQgKi8gXFxcIi4vdHlwZXMvcXVlcnkvc3Vic2V0LnRzXFxcIik7XFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L2luZGV4LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9xdWVyeS9sb2NhdGlvbi50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvbG9jYXRpb24udHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9xdWVyeS9sb2NhdGlvbi50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvb3JkZXIudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3R5cGVzL3F1ZXJ5L29yZGVyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdHlwZXMvcXVlcnkvb3JkZXIudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3R5cGVzL3F1ZXJ5L3F1ZXJ5LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9xdWVyeS9xdWVyeS50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3F1ZXJ5LnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9xdWVyeS9yYW5nZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvcmFuZ2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9xdWVyeS9yYW5nZS50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvcmVmZXJlbmNlLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvcmVmZXJlbmNlLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3JlZmVyZW5jZS50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvc2VhcmNoLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvc2VhcmNoLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3NlYXJjaC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvc2VsZWN0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvc2VsZWN0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3NlbGVjdC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvc2V0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvc2V0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3NldC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcXVlcnkvc3Vic2V0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvcXVlcnkvc3Vic2V0LnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuXFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3R5cGVzL3F1ZXJ5L3N1YnNldC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvcmVzb3VyY2UtbGluay50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9yZXNvdXJjZS1saW5rLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9yZXNvdXJjZS1saW5rLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9zcGFjZS50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdHlwZXMvc3BhY2UudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9zcGFjZS50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdHlwZXMvc3luYy50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9zeW5jLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcblxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi90eXBlcy9zeW5jLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy9zeXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy9zeXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdHlwZXMvc3lzLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi90eXBlcy90YWcudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi90eXBlcy90YWcudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG5cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdHlwZXMvdGFnLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi91dGlscy9ub3JtYWxpemUtc2VhcmNoLXBhcmFtZXRlcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi91dGlscy9ub3JtYWxpemUtc2VhcmNoLXBhcmFtZXRlcnMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyBub3JtYWxpemVTZWFyY2hQYXJhbWV0ZXJzKVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbmZ1bmN0aW9uIG5vcm1hbGl6ZVNlYXJjaFBhcmFtZXRlcnMocXVlcnkpIHtcXG4gICAgY29uc3QgY29udmVydGVkUXVlcnkgPSB7fTtcXG4gICAgbGV0IGhhc0NvbnZlcnRlZCA9IGZhbHNlO1xcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBxdWVyeSkge1xcbiAgICAgICAgLy8gV2UgYWxsb3cgbXVsdGlwbGUgdmFsdWVzIHRvIGJlIHBhc3NlZCBhcyBhcnJheXNcXG4gICAgICAgIC8vIHdoaWNoIGhhdmUgdG8gYmUgY29udmVydGVkIHRvIGNvbW1hLXNlcGFyYXRlZCBzdHJpbmdzIGJlZm9yZSBiZWluZyBzZW50IHRvIHRoZSBBUElcXG4gICAgICAgIGlmIChBcnJheS5pc0FycmF5KHF1ZXJ5W2tleV0pKSB7XFxuICAgICAgICAgICAgY29udmVydGVkUXVlcnlba2V5XSA9IHF1ZXJ5W2tleV0uam9pbignLCcpO1xcbiAgICAgICAgICAgIGhhc0NvbnZlcnRlZCA9IHRydWU7XFxuICAgICAgICB9XFxuICAgIH1cXG4gICAgaWYgKGhhc0NvbnZlcnRlZCkge1xcbiAgICAgICAgcmV0dXJuIHsgLi4ucXVlcnksIC4uLmNvbnZlcnRlZFF1ZXJ5IH07XFxuICAgIH1cXG4gICAgcmV0dXJuIHF1ZXJ5O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdXRpbHMvbm9ybWFsaXplLXNlYXJjaC1wYXJhbWV0ZXJzLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi91dGlscy9ub3JtYWxpemUtc2VsZWN0LnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3V0aWxzL25vcm1hbGl6ZS1zZWxlY3QudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gbm9ybWFsaXplU2VsZWN0KVxcbi8qIGhhcm1vbnkgZXhwb3J0ICovIH0pO1xcbi8qXFxuICogc2RrIHJlbGllcyBoZWF2aWx5IG9uIHN5cyBtZXRhZGF0YVxcbiAqIHNvIHdlIGNhbm5vdCBvbWl0IHRoZSBzeXMgcHJvcGVydHkgb24gc2RrIGxldmVsIGVudGlyZWx5XFxuICogYW5kIHdlIGhhdmUgdG8gZW5zdXJlIHRoYXQgYXQgbGVhc3QgYGlkYCBhbmQgYHR5cGVgIGFyZSBwcmVzZW50XFxuICogKi9cXG5mdW5jdGlvbiBub3JtYWxpemVTZWxlY3QocXVlcnkpIHtcXG4gICAgaWYgKCFxdWVyeS5zZWxlY3QpIHtcXG4gICAgICAgIHJldHVybiBxdWVyeTtcXG4gICAgfVxcbiAgICAvLyBUaGUgc2VsZWN0aW9uIG9mIGZpZWxkcyBmb3IgdGhlIHF1ZXJ5IGlzIGxpbWl0ZWRcXG4gICAgLy8gR2V0IHRoZSBkaWZmZXJlbnQgcGFydHMgdGhhdCBhcmUgbGlzdGVkIGZvciBzZWxlY3Rpb25cXG4gICAgY29uc3QgYWxsU2VsZWN0cyA9IEFycmF5LmlzQXJyYXkocXVlcnkuc2VsZWN0KVxcbiAgICAgICAgPyBxdWVyeS5zZWxlY3RcXG4gICAgICAgIDogcXVlcnkuc2VsZWN0LnNwbGl0KCcsJykubWFwKChxKSA9PiBxLnRyaW0oKSk7XFxuICAgIC8vIE1vdmUgdGhlIHBhcnRzIGludG8gYSBzZXQgZm9yIGVhc3kgYWNjZXNzIGFuZCBkZWR1cGxpY2F0aW9uXFxuICAgIGNvbnN0IHNlbGVjdGVkU2V0ID0gbmV3IFNldChhbGxTZWxlY3RzKTtcXG4gICAgLy8gSWYgd2UgYWxyZWFkeSBzZWxlY3QgYWxsIG9mIGBzeXNgIHdlIGNhbiBqdXN0IHJldHVyblxcbiAgICAvLyBzaW5jZSB3ZSdyZSBhbnl3YXkgZmV0Y2hpbmcgZXZlcnl0aGluZyB0aGF0IGlzIG5lZWRlZFxcbiAgICBpZiAoc2VsZWN0ZWRTZXQuaGFzKCdzeXMnKSkge1xcbiAgICAgICAgcmV0dXJuIHF1ZXJ5O1xcbiAgICB9XFxuICAgIC8vIFdlIGRvbid0IHNlbGVjdCBgc3lzYCBzbyB3ZSBuZWVkIHRvIGVuc3VyZSB0aGUgbWluaW11bSBzZXRcXG4gICAgc2VsZWN0ZWRTZXQuYWRkKCdzeXMuaWQnKTtcXG4gICAgc2VsZWN0ZWRTZXQuYWRkKCdzeXMudHlwZScpO1xcbiAgICAvLyBSZWFzc2lnbiB0aGUgbm9ybWFsaXplZCBzeXMgcHJvcGVydGllc1xcbiAgICByZXR1cm4ge1xcbiAgICAgICAgLi4ucXVlcnksXFxuICAgICAgICBzZWxlY3Q6IFsuLi5zZWxlY3RlZFNldF0uam9pbignLCcpLFxcbiAgICB9O1xcbn1cXG5cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdXRpbHMvbm9ybWFsaXplLXNlbGVjdC50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdXRpbHMvcmVzb2x2ZS1jaXJjdWxhci50c1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi91dGlscy9yZXNvbHZlLWNpcmN1bGFyLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoX191bnVzZWRfd2VicGFja19tb2R1bGUsIF9fd2VicGFja19leHBvcnRzX18sIF9fd2VicGFja19yZXF1aXJlX18pID0+IHtcblxuXCJ1c2Ugc3RyaWN0XCI7XG5ldmFsKFwiX193ZWJwYWNrX3JlcXVpcmVfXy5yKF9fd2VicGFja19leHBvcnRzX18pO1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovIF9fd2VicGFja19yZXF1aXJlX18uZChfX3dlYnBhY2tfZXhwb3J0c19fLCB7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gICBcXFwiZGVmYXVsdFxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHJlc29sdmVDaXJjdWxhcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX21peGluc19zdHJpbmdpZnlfc2FmZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fID0gX193ZWJwYWNrX3JlcXVpcmVfXygvKiEgLi4vbWl4aW5zL3N0cmluZ2lmeS1zYWZlICovIFxcXCIuL21peGlucy9zdHJpbmdpZnktc2FmZS50c1xcXCIpO1xcbi8qIGhhcm1vbnkgaW1wb3J0ICovIHZhciBjb250ZW50ZnVsX3Jlc29sdmVfcmVzcG9uc2VfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzFfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIGNvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZSAqLyBcXFwiLi4vbm9kZV9tb2R1bGVzL2NvbnRlbnRmdWwtcmVzb2x2ZS1yZXNwb25zZS9kaXN0L2VzbS9pbmRleC5qc1xcXCIpO1xcblxcblxcbmZ1bmN0aW9uIHJlc29sdmVDaXJjdWxhcihkYXRhLCB7IHJlc29sdmVMaW5rcywgcmVtb3ZlVW5yZXNvbHZlZCB9KSB7XFxuICAgIGNvbnN0IHdyYXBwZWREYXRhID0gKDAsX21peGluc19zdHJpbmdpZnlfc2FmZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fW1xcXCJkZWZhdWx0XFxcIl0pKGRhdGEpO1xcbiAgICBpZiAocmVzb2x2ZUxpbmtzKSB7XFxuICAgICAgICB3cmFwcGVkRGF0YS5pdGVtcyA9ICgwLGNvbnRlbnRmdWxfcmVzb2x2ZV9yZXNwb25zZV9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMV9fW1xcXCJkZWZhdWx0XFxcIl0pKHdyYXBwZWREYXRhLCB7XFxuICAgICAgICAgICAgcmVtb3ZlVW5yZXNvbHZlZCxcXG4gICAgICAgICAgICBpdGVtRW50cnlQb2ludHM6IFsnZmllbGRzJ10sXFxuICAgICAgICB9KTtcXG4gICAgfVxcbiAgICByZXR1cm4gd3JhcHBlZERhdGE7XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi91dGlscy9yZXNvbHZlLWNpcmN1bGFyLnRzP1wiKTtcblxuLyoqKi8gfSksXG5cbi8qKiovIFwiLi91dGlscy92YWxpZGF0ZS1wYXJhbXMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi91dGlscy92YWxpZGF0ZS1wYXJhbXMudHMgKioqIVxuICBcXCoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcInZhbGlkYXRlTG9jYWxlUGFyYW1cXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB2YWxpZGF0ZUxvY2FsZVBhcmFtKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJ2YWxpZGF0ZVJlbW92ZVVucmVzb2x2ZWRQYXJhbVxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIHZhbGlkYXRlUmVtb3ZlVW5yZXNvbHZlZFBhcmFtKSxcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJ2YWxpZGF0ZVJlc29sdmVMaW5rc1BhcmFtXFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFsaWRhdGVSZXNvbHZlTGlua3NQYXJhbSlcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG4vKiBoYXJtb255IGltcG9ydCAqLyB2YXIgX3ZhbGlkYXRpb25fZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXyA9IF9fd2VicGFja19yZXF1aXJlX18oLyohIC4vdmFsaWRhdGlvbi1lcnJvciAqLyBcXFwiLi91dGlscy92YWxpZGF0aW9uLWVycm9yLnRzXFxcIik7XFxuXFxuZnVuY3Rpb24gY2hlY2tMb2NhbGVQYXJhbUlzQWxsKHF1ZXJ5KSB7XFxuICAgIGlmIChxdWVyeS5sb2NhbGUgPT09ICcqJykge1xcbiAgICAgICAgdGhyb3cgbmV3IF92YWxpZGF0aW9uX2Vycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18uVmFsaWRhdGlvbkVycm9yKCdsb2NhbGUnLCBgVGhlIHVzZSBvZiBsb2NhbGU9JyonIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuVG8gZmV0Y2ggYW4gZW50cnkgaW4gYWxsIGV4aXN0aW5nIGxvY2FsZXMsIFxcbiAgICAgIHVzZSBjbGllbnQud2l0aEFsbExvY2FsZXMgaW5zdGVhZCBvZiB0aGUgbG9jYWxlPScqJyBwYXJhbWV0ZXIuYCk7XFxuICAgIH1cXG59XFxuZnVuY3Rpb24gY2hlY2tMb2NhbGVQYXJhbUV4aXN0cyhxdWVyeSkge1xcbiAgICBpZiAocXVlcnkubG9jYWxlKSB7XFxuICAgICAgICB0aHJvdyBuZXcgX3ZhbGlkYXRpb25fZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WYWxpZGF0aW9uRXJyb3IoJ2xvY2FsZScsICdUaGUgYGxvY2FsZWAgcGFyYW1ldGVyIGlzIG5vdCBhbGxvd2VkJyk7XFxuICAgIH1cXG59XFxuZnVuY3Rpb24gdmFsaWRhdGVMb2NhbGVQYXJhbShxdWVyeSwgaXNXaXRoQWxsTG9jYWxlc0NsaWVudCkge1xcbiAgICBpZiAoaXNXaXRoQWxsTG9jYWxlc0NsaWVudCkge1xcbiAgICAgICAgY2hlY2tMb2NhbGVQYXJhbUV4aXN0cyhxdWVyeSk7XFxuICAgIH1cXG4gICAgZWxzZSB7XFxuICAgICAgICBjaGVja0xvY2FsZVBhcmFtSXNBbGwocXVlcnkpO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG59XFxuZnVuY3Rpb24gdmFsaWRhdGVSZXNvbHZlTGlua3NQYXJhbShxdWVyeSkge1xcbiAgICBpZiAoJ3Jlc29sdmVMaW5rcycgaW4gcXVlcnkpIHtcXG4gICAgICAgIHRocm93IG5ldyBfdmFsaWRhdGlvbl9lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlZhbGlkYXRpb25FcnJvcigncmVzb2x2ZUxpbmtzJywgYFRoZSB1c2Ugb2YgdGhlICdyZXNvbHZlTGlua3MnIHBhcmFtZXRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkLiBCeSBkZWZhdWx0LCBsaW5rcyBhcmUgcmVzb2x2ZWQuIFxcbiAgICAgIElmIHlvdSBkbyBub3Qgd2FudCB0byByZXNvbHZlIGxpbmtzLCB1c2UgY2xpZW50LndpdGhvdXRMaW5rUmVzb2x1dGlvbi5gKTtcXG4gICAgfVxcbiAgICByZXR1cm47XFxufVxcbmZ1bmN0aW9uIHZhbGlkYXRlUmVtb3ZlVW5yZXNvbHZlZFBhcmFtKHF1ZXJ5KSB7XFxuICAgIGlmICgncmVtb3ZlVW5yZXNvbHZlZCcgaW4gcXVlcnkpIHtcXG4gICAgICAgIHRocm93IG5ldyBfdmFsaWRhdGlvbl9lcnJvcl9fV0VCUEFDS19JTVBPUlRFRF9NT0RVTEVfMF9fLlZhbGlkYXRpb25FcnJvcigncmVtb3ZlVW5yZXNvbHZlZCcsIGBUaGUgdXNlIG9mIHRoZSAncmVtb3ZlVW5yZXNvbHZlZCcgcGFyYW1ldGVyIGlzIG5vIGxvbmdlciBzdXBwb3J0ZWQuIEJ5IGRlZmF1bHQsIHVucmVzb2x2ZWQgbGlua3MgYXJlIGtlcHQgYXMgbGluayBvYmplY3RzLlxcbiAgICAgIElmIHlvdSBkbyBub3Qgd2FudCB0byBpbmNsdWRlIHVucmVzb2x2ZWQgbGlua3MsIHVzZSBjbGllbnQud2l0aG91dFVucmVzb2x2YWJsZUxpbmtzLmApO1xcbiAgICB9XFxuICAgIHJldHVybjtcXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3V0aWxzL3ZhbGlkYXRlLXBhcmFtcy50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdXRpbHMvdmFsaWRhdGUtc2VhcmNoLXBhcmFtZXRlcnMudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiEqXFxcbiAgISoqKiAuL3V0aWxzL3ZhbGlkYXRlLXNlYXJjaC1wYXJhbWV0ZXJzLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcImRlZmF1bHRcXFwiOiAoKSA9PiAoLyogYmluZGluZyAqLyB2YWxpZGF0ZVNlYXJjaFBhcmFtZXRlcnMpXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuZnVuY3Rpb24gdmFsaWRhdGVTZWFyY2hQYXJhbWV0ZXJzKHF1ZXJ5KSB7XFxuICAgIGZvciAoY29uc3Qga2V5IGluIHF1ZXJ5KSB7XFxuICAgICAgICBjb25zdCB2YWx1ZSA9IHF1ZXJ5W2tleV07XFxuICAgICAgICAvLyBXZSBkb27igJl0IGFsbG93IGFueSBvYmplY3RzIGFzIHZhbHVlcyBmb3IgcXVlcnkgcGFyYW1ldGVyc1xcbiAgICAgICAgaWYgKHR5cGVvZiB2YWx1ZSA9PT0gJ29iamVjdCcgJiYgdmFsdWUgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkodmFsdWUpKSB7XFxuICAgICAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBPYmplY3RzIGFyZSBub3Qgc3VwcG9ydGVkIGFzIHZhbHVlIGZvciB0aGUgXFxcIiR7a2V5fVxcXCIgcXVlcnkgcGFyYW1ldGVyLmApO1xcbiAgICAgICAgfVxcbiAgICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi91dGlscy92YWxpZGF0ZS1zZWFyY2gtcGFyYW1ldGVycy50cz9cIik7XG5cbi8qKiovIH0pLFxuXG4vKioqLyBcIi4vdXRpbHMvdmFsaWRhdGUtdGltZXN0YW1wLnRzXCI6XG4vKiEqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdXRpbHMvdmFsaWRhdGUtdGltZXN0YW1wLnRzICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKi8gKChfX3VudXNlZF93ZWJwYWNrX21vZHVsZSwgX193ZWJwYWNrX2V4cG9ydHNfXywgX193ZWJwYWNrX3JlcXVpcmVfXykgPT4ge1xuXG5cInVzZSBzdHJpY3RcIjtcbmV2YWwoXCJfX3dlYnBhY2tfcmVxdWlyZV9fLnIoX193ZWJwYWNrX2V4cG9ydHNfXyk7XFxuLyogaGFybW9ueSBleHBvcnQgKi8gX193ZWJwYWNrX3JlcXVpcmVfXy5kKF9fd2VicGFja19leHBvcnRzX18sIHtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyAgIFxcXCJkZWZhdWx0XFxcIjogKCkgPT4gKC8qIGJpbmRpbmcgKi8gdmFsaWRhdGVUaW1lc3RhbXApXFxuLyogaGFybW9ueSBleHBvcnQgKi8gfSk7XFxuLyogaGFybW9ueSBpbXBvcnQgKi8gdmFyIF92YWxpZGF0aW9uX2Vycm9yX19XRUJQQUNLX0lNUE9SVEVEX01PRFVMRV8wX18gPSBfX3dlYnBhY2tfcmVxdWlyZV9fKC8qISAuL3ZhbGlkYXRpb24tZXJyb3IgKi8gXFxcIi4vdXRpbHMvdmFsaWRhdGlvbi1lcnJvci50c1xcXCIpO1xcblxcbmZ1bmN0aW9uIHZhbGlkYXRlVGltZXN0YW1wKG5hbWUsIHRpbWVzdGFtcCwgb3B0aW9ucykge1xcbiAgICBvcHRpb25zID0gb3B0aW9ucyB8fCB7fTtcXG4gICAgaWYgKHR5cGVvZiB0aW1lc3RhbXAgIT09ICdudW1iZXInKSB7XFxuICAgICAgICB0aHJvdyBuZXcgX3ZhbGlkYXRpb25fZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WYWxpZGF0aW9uRXJyb3IobmFtZSwgYG9ubHkgbnVtZXJpYyB2YWx1ZXMgYXJlIGFsbG93ZWQgZm9yIHRpbWVzdGFtcHMsIHByb3ZpZGVkIHR5cGUgd2FzIFxcXCIke3R5cGVvZiB0aW1lc3RhbXB9XFxcImApO1xcbiAgICB9XFxuICAgIGlmIChvcHRpb25zLm1heGltdW0gJiYgdGltZXN0YW1wID4gb3B0aW9ucy5tYXhpbXVtKSB7XFxuICAgICAgICB0aHJvdyBuZXcgX3ZhbGlkYXRpb25fZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WYWxpZGF0aW9uRXJyb3IobmFtZSwgYHZhbHVlICgke3RpbWVzdGFtcH0pIGNhbm5vdCBiZSBmdXJ0aGVyIGluIHRoZSBmdXR1cmUgdGhhbiBleHBlY3RlZCBtYXhpbXVtICgke29wdGlvbnMubWF4aW11bX0pYCk7XFxuICAgIH1cXG4gICAgaWYgKG9wdGlvbnMubm93ICYmIHRpbWVzdGFtcCA8IG9wdGlvbnMubm93KSB7XFxuICAgICAgICB0aHJvdyBuZXcgX3ZhbGlkYXRpb25fZXJyb3JfX1dFQlBBQ0tfSU1QT1JURURfTU9EVUxFXzBfXy5WYWxpZGF0aW9uRXJyb3IobmFtZSwgYHZhbHVlICgke3RpbWVzdGFtcH0pIGNhbm5vdCBiZSBpbiB0aGUgcGFzdCwgY3VycmVudCB0aW1lIHdhcyAke29wdGlvbnMubm93fWApO1xcbiAgICB9XFxufVxcblxcblxcbi8vIyBzb3VyY2VVUkw9d2VicGFjazovL2NvbnRlbnRmdWwvLi91dGlscy92YWxpZGF0ZS10aW1lc3RhbXAudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCIuL3V0aWxzL3ZhbGlkYXRpb24tZXJyb3IudHNcIjpcbi8qISoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqISpcXFxuICAhKioqIC4vdXRpbHMvdmFsaWRhdGlvbi1lcnJvci50cyAqKiohXG4gIFxcKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqLyAoKF9fdW51c2VkX3dlYnBhY2tfbW9kdWxlLCBfX3dlYnBhY2tfZXhwb3J0c19fLCBfX3dlYnBhY2tfcmVxdWlyZV9fKSA9PiB7XG5cblwidXNlIHN0cmljdFwiO1xuZXZhbChcIl9fd2VicGFja19yZXF1aXJlX18ucihfX3dlYnBhY2tfZXhwb3J0c19fKTtcXG4vKiBoYXJtb255IGV4cG9ydCAqLyBfX3dlYnBhY2tfcmVxdWlyZV9fLmQoX193ZWJwYWNrX2V4cG9ydHNfXywge1xcbi8qIGhhcm1vbnkgZXhwb3J0ICovICAgXFxcIlZhbGlkYXRpb25FcnJvclxcXCI6ICgpID0+ICgvKiBiaW5kaW5nICovIFZhbGlkYXRpb25FcnJvcilcXG4vKiBoYXJtb255IGV4cG9ydCAqLyB9KTtcXG5jbGFzcyBWYWxpZGF0aW9uRXJyb3IgZXh0ZW5kcyBFcnJvciB7XFxuICAgIGNvbnN0cnVjdG9yKG5hbWUsIG1lc3NhZ2UpIHtcXG4gICAgICAgIHN1cGVyKGBJbnZhbGlkIFxcXCIke25hbWV9XFxcIiBwcm92aWRlZCwgYCArIG1lc3NhZ2UpO1xcbiAgICAgICAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XFxuICAgIH1cXG59XFxuXFxuXFxuLy8jIHNvdXJjZVVSTD13ZWJwYWNrOi8vY29udGVudGZ1bC8uL3V0aWxzL3ZhbGlkYXRpb24tZXJyb3IudHM/XCIpO1xuXG4vKioqLyB9KSxcblxuLyoqKi8gXCI/ZDkxY1wiOlxuLyohKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiohKlxcXG4gICEqKiogLi91dGlsLmluc3BlY3QgKGlnbm9yZWQpICoqKiFcbiAgXFwqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qKiovICgoKSA9PiB7XG5cbmV2YWwoXCIvKiAoaWdub3JlZCkgKi9cXG5cXG4vLyMgc291cmNlVVJMPXdlYnBhY2s6Ly9jb250ZW50ZnVsLy4vdXRpbC5pbnNwZWN0XyhpZ25vcmVkKT9cIik7XG5cbi8qKiovIH0pXG5cbi8qKioqKiovIFx0fSk7XG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyoqKioqKi8gXHQvLyBUaGUgbW9kdWxlIGNhY2hlXG4vKioqKioqLyBcdHZhciBfX3dlYnBhY2tfbW9kdWxlX2NhY2hlX18gPSB7fTtcbi8qKioqKiovIFx0XG4vKioqKioqLyBcdC8vIFRoZSByZXF1aXJlIGZ1bmN0aW9uXG4vKioqKioqLyBcdGZ1bmN0aW9uIF9fd2VicGFja19yZXF1aXJlX18obW9kdWxlSWQpIHtcbi8qKioqKiovIFx0XHQvLyBDaGVjayBpZiBtb2R1bGUgaXMgaW4gY2FjaGVcbi8qKioqKiovIFx0XHR2YXIgY2FjaGVkTW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXTtcbi8qKioqKiovIFx0XHRpZiAoY2FjaGVkTW9kdWxlICE9PSB1bmRlZmluZWQpIHtcbi8qKioqKiovIFx0XHRcdHJldHVybiBjYWNoZWRNb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0XHR9XG4vKioqKioqLyBcdFx0Ly8gQ3JlYXRlIGEgbmV3IG1vZHVsZSAoYW5kIHB1dCBpdCBpbnRvIHRoZSBjYWNoZSlcbi8qKioqKiovIFx0XHR2YXIgbW9kdWxlID0gX193ZWJwYWNrX21vZHVsZV9jYWNoZV9fW21vZHVsZUlkXSA9IHtcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5pZCBuZWVkZWRcbi8qKioqKiovIFx0XHRcdC8vIG5vIG1vZHVsZS5sb2FkZWQgbmVlZGVkXG4vKioqKioqLyBcdFx0XHRleHBvcnRzOiB7fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHRcdC8vIEV4ZWN1dGUgdGhlIG1vZHVsZSBmdW5jdGlvblxuLyoqKioqKi8gXHRcdF9fd2VicGFja19tb2R1bGVzX19bbW9kdWxlSWRdLmNhbGwobW9kdWxlLmV4cG9ydHMsIG1vZHVsZSwgbW9kdWxlLmV4cG9ydHMsIF9fd2VicGFja19yZXF1aXJlX18pO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0XHQvLyBSZXR1cm4gdGhlIGV4cG9ydHMgb2YgdGhlIG1vZHVsZVxuLyoqKioqKi8gXHRcdHJldHVybiBtb2R1bGUuZXhwb3J0cztcbi8qKioqKiovIFx0fVxuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdC8qIHdlYnBhY2svcnVudGltZS9jb21wYXQgZ2V0IGRlZmF1bHQgZXhwb3J0ICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0Ly8gZ2V0RGVmYXVsdEV4cG9ydCBmdW5jdGlvbiBmb3IgY29tcGF0aWJpbGl0eSB3aXRoIG5vbi1oYXJtb255IG1vZHVsZXNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLm4gPSAobW9kdWxlKSA9PiB7XG4vKioqKioqLyBcdFx0XHR2YXIgZ2V0dGVyID0gbW9kdWxlICYmIG1vZHVsZS5fX2VzTW9kdWxlID9cbi8qKioqKiovIFx0XHRcdFx0KCkgPT4gKG1vZHVsZVsnZGVmYXVsdCddKSA6XG4vKioqKioqLyBcdFx0XHRcdCgpID0+IChtb2R1bGUpO1xuLyoqKioqKi8gXHRcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kKGdldHRlciwgeyBhOiBnZXR0ZXIgfSk7XG4vKioqKioqLyBcdFx0XHRyZXR1cm4gZ2V0dGVyO1xuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZGVmaW5lIHByb3BlcnR5IGdldHRlcnMgKi9cbi8qKioqKiovIFx0KCgpID0+IHtcbi8qKioqKiovIFx0XHQvLyBkZWZpbmUgZ2V0dGVyIGZ1bmN0aW9ucyBmb3IgaGFybW9ueSBleHBvcnRzXG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5kID0gKGV4cG9ydHMsIGRlZmluaXRpb24pID0+IHtcbi8qKioqKiovIFx0XHRcdGZvcih2YXIga2V5IGluIGRlZmluaXRpb24pIHtcbi8qKioqKiovIFx0XHRcdFx0aWYoX193ZWJwYWNrX3JlcXVpcmVfXy5vKGRlZmluaXRpb24sIGtleSkgJiYgIV9fd2VicGFja19yZXF1aXJlX18ubyhleHBvcnRzLCBrZXkpKSB7XG4vKioqKioqLyBcdFx0XHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsIGtleSwgeyBlbnVtZXJhYmxlOiB0cnVlLCBnZXQ6IGRlZmluaXRpb25ba2V5XSB9KTtcbi8qKioqKiovIFx0XHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH07XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvZ2xvYmFsICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5nID0gKGZ1bmN0aW9uKCkge1xuLyoqKioqKi8gXHRcdFx0aWYgKHR5cGVvZiBnbG9iYWxUaGlzID09PSAnb2JqZWN0JykgcmV0dXJuIGdsb2JhbFRoaXM7XG4vKioqKioqLyBcdFx0XHR0cnkge1xuLyoqKioqKi8gXHRcdFx0XHRyZXR1cm4gdGhpcyB8fCBuZXcgRnVuY3Rpb24oJ3JldHVybiB0aGlzJykoKTtcbi8qKioqKiovIFx0XHRcdH0gY2F0Y2ggKGUpIHtcbi8qKioqKiovIFx0XHRcdFx0aWYgKHR5cGVvZiB3aW5kb3cgPT09ICdvYmplY3QnKSByZXR1cm4gd2luZG93O1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdH0pKCk7XG4vKioqKioqLyBcdH0pKCk7XG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvKiB3ZWJwYWNrL3J1bnRpbWUvaGFzT3duUHJvcGVydHkgc2hvcnRoYW5kICovXG4vKioqKioqLyBcdCgoKSA9PiB7XG4vKioqKioqLyBcdFx0X193ZWJwYWNrX3JlcXVpcmVfXy5vID0gKG9iaiwgcHJvcCkgPT4gKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChvYmosIHByb3ApKVxuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0Lyogd2VicGFjay9ydW50aW1lL21ha2UgbmFtZXNwYWNlIG9iamVjdCAqL1xuLyoqKioqKi8gXHQoKCkgPT4ge1xuLyoqKioqKi8gXHRcdC8vIGRlZmluZSBfX2VzTW9kdWxlIG9uIGV4cG9ydHNcbi8qKioqKiovIFx0XHRfX3dlYnBhY2tfcmVxdWlyZV9fLnIgPSAoZXhwb3J0cykgPT4ge1xuLyoqKioqKi8gXHRcdFx0aWYodHlwZW9mIFN5bWJvbCAhPT0gJ3VuZGVmaW5lZCcgJiYgU3ltYm9sLnRvU3RyaW5nVGFnKSB7XG4vKioqKioqLyBcdFx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShleHBvcnRzLCBTeW1ib2wudG9TdHJpbmdUYWcsIHsgdmFsdWU6ICdNb2R1bGUnIH0pO1xuLyoqKioqKi8gXHRcdFx0fVxuLyoqKioqKi8gXHRcdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGV4cG9ydHMsICdfX2VzTW9kdWxlJywgeyB2YWx1ZTogdHJ1ZSB9KTtcbi8qKioqKiovIFx0XHR9O1xuLyoqKioqKi8gXHR9KSgpO1xuLyoqKioqKi8gXHRcbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKioqKioqLyBcdFxuLyoqKioqKi8gXHQvLyBzdGFydHVwXG4vKioqKioqLyBcdC8vIExvYWQgZW50cnkgbW9kdWxlIGFuZCByZXR1cm4gZXhwb3J0c1xuLyoqKioqKi8gXHQvLyBUaGlzIGVudHJ5IG1vZHVsZSBjYW4ndCBiZSBpbmxpbmVkIGJlY2F1c2UgdGhlIGV2YWwgZGV2dG9vbCBpcyB1c2VkLlxuLyoqKioqKi8gXHR2YXIgX193ZWJwYWNrX2V4cG9ydHNfXyA9IF9fd2VicGFja19yZXF1aXJlX18oXCIuL2luZGV4LnRzXCIpO1xuLyoqKioqKi8gXHRcbi8qKioqKiovIFx0cmV0dXJuIF9fd2VicGFja19leHBvcnRzX187XG4vKioqKioqLyB9KSgpXG47XG59KTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/contentful/dist/contentful.browser.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css":
/*!*****************************************************************************************************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css ***!
  \*****************************************************************************************************************************************************************************************************************************************************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../next/dist/build/webpack/loaders/css-loader/src/runtime/api.js */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\");\n/* harmony import */ var _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(_next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0__);\n// Imports\n\nvar ___CSS_LOADER_EXPORT___ = _next_dist_build_webpack_loaders_css_loader_src_runtime_api_js__WEBPACK_IMPORTED_MODULE_0___default()(true);\n// Module\n___CSS_LOADER_EXPORT___.push([module.id, \"/*\\n! tailwindcss v3.3.1 | MIT License | https://tailwindcss.com\\n*//*\\n1. Prevent padding and border from affecting element width. (https://github.com/mozdevs/cssremedy/issues/4)\\n2. Allow adding a border to an element by just adding a border-width. (https://github.com/tailwindcss/tailwindcss/pull/116)\\n*/\\n\\n*,\\n::before,\\n::after {\\n  box-sizing: border-box; /* 1 */\\n  border-width: 0; /* 2 */\\n  border-style: solid; /* 2 */\\n  border-color: #e5e7eb; /* 2 */\\n}\\n\\n::before,\\n::after {\\n  --tw-content: '';\\n}\\n\\n/*\\n1. Use a consistent sensible line-height in all browsers.\\n2. Prevent adjustments of font size after orientation changes in iOS.\\n3. Use a more readable tab size.\\n4. Use the user's configured `sans` font-family by default.\\n5. Use the user's configured `sans` font-feature-settings by default.\\n6. Use the user's configured `sans` font-variation-settings by default.\\n*/\\n\\nhtml {\\n  line-height: 1.5; /* 1 */\\n  -webkit-text-size-adjust: 100%; /* 2 */ /* 3 */\\n  tab-size: 4; /* 3 */\\n  font-family: ui-sans-serif, system-ui, -apple-system, BlinkMacSystemFont, \\\"Segoe UI\\\", Roboto, \\\"Helvetica Neue\\\", Arial, \\\"Noto Sans\\\", sans-serif, \\\"Apple Color Emoji\\\", \\\"Segoe UI Emoji\\\", \\\"Segoe UI Symbol\\\", \\\"Noto Color Emoji\\\"; /* 4 */\\n  font-feature-settings: normal; /* 5 */\\n  font-variation-settings: normal; /* 6 */\\n}\\n\\n/*\\n1. Remove the margin in all browsers.\\n2. Inherit line-height from `html` so users can set them as a class directly on the `html` element.\\n*/\\n\\nbody {\\n  margin: 0; /* 1 */\\n  line-height: inherit; /* 2 */\\n}\\n\\n/*\\n1. Add the correct height in Firefox.\\n2. Correct the inheritance of border color in Firefox. (https://bugzilla.mozilla.org/show_bug.cgi?id=190655)\\n3. Ensure horizontal rules are visible by default.\\n*/\\n\\nhr {\\n  height: 0; /* 1 */\\n  color: inherit; /* 2 */\\n  border-top-width: 1px; /* 3 */\\n}\\n\\n/*\\nAdd the correct text decoration in Chrome, Edge, and Safari.\\n*/\\n\\nabbr:where([title]) {\\n  -webkit-text-decoration: underline dotted;\\n          text-decoration: underline dotted;\\n}\\n\\n/*\\nRemove the default font size and weight for headings.\\n*/\\n\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6 {\\n  font-size: inherit;\\n  font-weight: inherit;\\n}\\n\\n/*\\nReset links to optimize for opt-in styling instead of opt-out.\\n*/\\n\\na {\\n  color: inherit;\\n  text-decoration: inherit;\\n}\\n\\n/*\\nAdd the correct font weight in Edge and Safari.\\n*/\\n\\nb,\\nstrong {\\n  font-weight: bolder;\\n}\\n\\n/*\\n1. Use the user's configured `mono` font family by default.\\n2. Correct the odd `em` font sizing in all browsers.\\n*/\\n\\ncode,\\nkbd,\\nsamp,\\npre {\\n  font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, \\\"Liberation Mono\\\", \\\"Courier New\\\", monospace; /* 1 */\\n  font-size: 1em; /* 2 */\\n}\\n\\n/*\\nAdd the correct font size in all browsers.\\n*/\\n\\nsmall {\\n  font-size: 80%;\\n}\\n\\n/*\\nPrevent `sub` and `sup` elements from affecting the line height in all browsers.\\n*/\\n\\nsub,\\nsup {\\n  font-size: 75%;\\n  line-height: 0;\\n  position: relative;\\n  vertical-align: baseline;\\n}\\n\\nsub {\\n  bottom: -0.25em;\\n}\\n\\nsup {\\n  top: -0.5em;\\n}\\n\\n/*\\n1. Remove text indentation from table contents in Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=999088, https://bugs.webkit.org/show_bug.cgi?id=201297)\\n2. Correct table border color inheritance in all Chrome and Safari. (https://bugs.chromium.org/p/chromium/issues/detail?id=935729, https://bugs.webkit.org/show_bug.cgi?id=195016)\\n3. Remove gaps between table borders by default.\\n*/\\n\\ntable {\\n  text-indent: 0; /* 1 */\\n  border-color: inherit; /* 2 */\\n  border-collapse: collapse; /* 3 */\\n}\\n\\n/*\\n1. Change the font styles in all browsers.\\n2. Remove the margin in Firefox and Safari.\\n3. Remove default padding in all browsers.\\n*/\\n\\nbutton,\\ninput,\\noptgroup,\\nselect,\\ntextarea {\\n  font-family: inherit; /* 1 */\\n  font-size: 100%; /* 1 */\\n  font-weight: inherit; /* 1 */\\n  line-height: inherit; /* 1 */\\n  color: inherit; /* 1 */\\n  margin: 0; /* 2 */\\n  padding: 0; /* 3 */\\n}\\n\\n/*\\nRemove the inheritance of text transform in Edge and Firefox.\\n*/\\n\\nbutton,\\nselect {\\n  text-transform: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Remove default button styles.\\n*/\\n\\nbutton,\\n[type='button'],\\n[type='reset'],\\n[type='submit'] {\\n  -webkit-appearance: button; /* 1 */\\n  background-color: transparent; /* 2 */\\n  background-image: none; /* 2 */\\n}\\n\\n/*\\nUse the modern Firefox focus style for all focusable elements.\\n*/\\n\\n:-moz-focusring {\\n  outline: auto;\\n}\\n\\n/*\\nRemove the additional `:invalid` styles in Firefox. (https://github.com/mozilla/gecko-dev/blob/2f9eacd9d3d995c937b4251a5557d95d494c9be1/layout/style/res/forms.css#L728-L737)\\n*/\\n\\n:-moz-ui-invalid {\\n  box-shadow: none;\\n}\\n\\n/*\\nAdd the correct vertical alignment in Chrome and Firefox.\\n*/\\n\\nprogress {\\n  vertical-align: baseline;\\n}\\n\\n/*\\nCorrect the cursor style of increment and decrement buttons in Safari.\\n*/\\n\\n::-webkit-inner-spin-button,\\n::-webkit-outer-spin-button {\\n  height: auto;\\n}\\n\\n/*\\n1. Correct the odd appearance in Chrome and Safari.\\n2. Correct the outline style in Safari.\\n*/\\n\\n[type='search'] {\\n  -webkit-appearance: textfield; /* 1 */\\n  outline-offset: -2px; /* 2 */\\n}\\n\\n/*\\nRemove the inner padding in Chrome and Safari on macOS.\\n*/\\n\\n::-webkit-search-decoration {\\n  -webkit-appearance: none;\\n}\\n\\n/*\\n1. Correct the inability to style clickable types in iOS and Safari.\\n2. Change font properties to `inherit` in Safari.\\n*/\\n\\n::-webkit-file-upload-button {\\n  -webkit-appearance: button; /* 1 */\\n  font: inherit; /* 2 */\\n}\\n\\n/*\\nAdd the correct display in Chrome and Safari.\\n*/\\n\\nsummary {\\n  display: list-item;\\n}\\n\\n/*\\nRemoves the default spacing and border for appropriate elements.\\n*/\\n\\nblockquote,\\ndl,\\ndd,\\nh1,\\nh2,\\nh3,\\nh4,\\nh5,\\nh6,\\nhr,\\nfigure,\\np,\\npre {\\n  margin: 0;\\n}\\n\\nfieldset {\\n  margin: 0;\\n  padding: 0;\\n}\\n\\nlegend {\\n  padding: 0;\\n}\\n\\nol,\\nul,\\nmenu {\\n  list-style: none;\\n  margin: 0;\\n  padding: 0;\\n}\\n\\n/*\\nPrevent resizing textareas horizontally by default.\\n*/\\n\\ntextarea {\\n  resize: vertical;\\n}\\n\\n/*\\n1. Reset the default placeholder opacity in Firefox. (https://github.com/tailwindlabs/tailwindcss/issues/3300)\\n2. Set the default placeholder color to the user's configured gray 400 color.\\n*/\\n\\ninput::placeholder,\\ntextarea::placeholder {\\n  opacity: 1; /* 1 */\\n  color: #9ca3af; /* 2 */\\n}\\n\\n/*\\nSet the default cursor for buttons.\\n*/\\n\\nbutton,\\n[role=\\\"button\\\"] {\\n  cursor: pointer;\\n}\\n\\n/*\\nMake sure disabled buttons don't get the pointer cursor.\\n*/\\n:disabled {\\n  cursor: default;\\n}\\n\\n/*\\n1. Make replaced elements `display: block` by default. (https://github.com/mozdevs/cssremedy/issues/14)\\n2. Add `vertical-align: middle` to align replaced elements more sensibly by default. (https://github.com/jensimmons/cssremedy/issues/14#issuecomment-634934210)\\n   This can trigger a poorly considered lint error in some tools but is included by design.\\n*/\\n\\nimg,\\nsvg,\\nvideo,\\ncanvas,\\naudio,\\niframe,\\nembed,\\nobject {\\n  display: block; /* 1 */\\n  vertical-align: middle; /* 2 */\\n}\\n\\n/*\\nConstrain images and videos to the parent width and preserve their intrinsic aspect ratio. (https://github.com/mozdevs/cssremedy/issues/14)\\n*/\\n\\nimg,\\nvideo {\\n  max-width: 100%;\\n  height: auto;\\n}\\n\\n/* Make elements with the HTML hidden attribute stay hidden by default */\\n[hidden] {\\n  display: none;\\n}\\n\\n*, ::before, ::after {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\\n::backdrop {\\n  --tw-border-spacing-x: 0;\\n  --tw-border-spacing-y: 0;\\n  --tw-translate-x: 0;\\n  --tw-translate-y: 0;\\n  --tw-rotate: 0;\\n  --tw-skew-x: 0;\\n  --tw-skew-y: 0;\\n  --tw-scale-x: 1;\\n  --tw-scale-y: 1;\\n  --tw-pan-x:  ;\\n  --tw-pan-y:  ;\\n  --tw-pinch-zoom:  ;\\n  --tw-scroll-snap-strictness: proximity;\\n  --tw-ordinal:  ;\\n  --tw-slashed-zero:  ;\\n  --tw-numeric-figure:  ;\\n  --tw-numeric-spacing:  ;\\n  --tw-numeric-fraction:  ;\\n  --tw-ring-inset:  ;\\n  --tw-ring-offset-width: 0px;\\n  --tw-ring-offset-color: #fff;\\n  --tw-ring-color: rgb(59 130 246 / 0.5);\\n  --tw-ring-offset-shadow: 0 0 #0000;\\n  --tw-ring-shadow: 0 0 #0000;\\n  --tw-shadow: 0 0 #0000;\\n  --tw-shadow-colored: 0 0 #0000;\\n  --tw-blur:  ;\\n  --tw-brightness:  ;\\n  --tw-contrast:  ;\\n  --tw-grayscale:  ;\\n  --tw-hue-rotate:  ;\\n  --tw-invert:  ;\\n  --tw-saturate:  ;\\n  --tw-sepia:  ;\\n  --tw-drop-shadow:  ;\\n  --tw-backdrop-blur:  ;\\n  --tw-backdrop-brightness:  ;\\n  --tw-backdrop-contrast:  ;\\n  --tw-backdrop-grayscale:  ;\\n  --tw-backdrop-hue-rotate:  ;\\n  --tw-backdrop-invert:  ;\\n  --tw-backdrop-opacity:  ;\\n  --tw-backdrop-saturate:  ;\\n  --tw-backdrop-sepia:  ;\\n}\\n\", \"\",{\"version\":3,\"sources\":[\"webpack://node_modules/tailwindcss/tailwind.css\"],\"names\":[],\"mappings\":\"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\",\"sourcesContent\":[\"@tailwind base;\\n\\n@tailwind components;\\n\\n@tailwind utilities;\\n\"],\"sourceRoot\":\"\"}]);\n// Exports\n/* harmony default export */ __webpack_exports__[\"default\"] = (___CSS_LOADER_EXPORT___);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxMV0udXNlWzFdIS4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzExXS51c2VbMl0hLi9ub2RlX21vZHVsZXMvdGFpbHdpbmRjc3MvdGFpbHdpbmQuY3NzLmpzIiwibWFwcGluZ3MiOiI7OztBQUFBO0FBQzJHO0FBQzNHLDhCQUE4QixxR0FBMkI7QUFDekQ7QUFDQSwwWEFBMFgsNEJBQTRCLDRCQUE0QixnQ0FBZ0Msa0NBQWtDLFVBQVUsd0JBQXdCLHFCQUFxQixHQUFHLHFZQUFxWSxzQkFBc0IsMkNBQTJDLGdDQUFnQyx1UEFBdVAsMENBQTBDLDRDQUE0QyxVQUFVLGdLQUFnSyxlQUFlLGlDQUFpQyxVQUFVLDJOQUEyTixlQUFlLDJCQUEyQixrQ0FBa0MsVUFBVSxpR0FBaUcsOENBQThDLDhDQUE4QyxHQUFHLGtHQUFrRyx1QkFBdUIseUJBQXlCLEdBQUcsaUZBQWlGLG1CQUFtQiw2QkFBNkIsR0FBRywyRUFBMkUsd0JBQXdCLEdBQUcsMEpBQTBKLHlIQUF5SCwyQkFBMkIsVUFBVSxpRUFBaUUsbUJBQW1CLEdBQUcsMkdBQTJHLG1CQUFtQixtQkFBbUIsdUJBQXVCLDZCQUE2QixHQUFHLFNBQVMsb0JBQW9CLEdBQUcsU0FBUyxnQkFBZ0IsR0FBRyxnYkFBZ2Isb0JBQW9CLGtDQUFrQyxzQ0FBc0MsVUFBVSxrTUFBa00sMEJBQTBCLDRCQUE0QixpQ0FBaUMsaUNBQWlDLDJCQUEyQixzQkFBc0IsdUJBQXVCLFVBQVUsOEZBQThGLHlCQUF5QixHQUFHLG1MQUFtTCxnQ0FBZ0MsMENBQTBDLG1DQUFtQyxVQUFVLCtGQUErRixrQkFBa0IsR0FBRywrTUFBK00s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L3RhaWx3aW5kY3NzL3RhaWx3aW5kLmNzcz8zN2UyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vIEltcG9ydHNcbmltcG9ydCBfX19DU1NfTE9BREVSX0FQSV9JTVBPUlRfX18gZnJvbSBcIi4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanNcIjtcbnZhciBfX19DU1NfTE9BREVSX0VYUE9SVF9fXyA9IF9fX0NTU19MT0FERVJfQVBJX0lNUE9SVF9fXyh0cnVlKTtcbi8vIE1vZHVsZVxuX19fQ1NTX0xPQURFUl9FWFBPUlRfX18ucHVzaChbbW9kdWxlLmlkLCBcIi8qXFxuISB0YWlsd2luZGNzcyB2My4zLjEgfCBNSVQgTGljZW5zZSB8IGh0dHBzOi8vdGFpbHdpbmRjc3MuY29tXFxuKi8vKlxcbjEuIFByZXZlbnQgcGFkZGluZyBhbmQgYm9yZGVyIGZyb20gYWZmZWN0aW5nIGVsZW1lbnQgd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzQpXFxuMi4gQWxsb3cgYWRkaW5nIGEgYm9yZGVyIHRvIGFuIGVsZW1lbnQgYnkganVzdCBhZGRpbmcgYSBib3JkZXItd2lkdGguIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRjc3MvdGFpbHdpbmRjc3MvcHVsbC8xMTYpXFxuKi9cXG5cXG4qLFxcbjo6YmVmb3JlLFxcbjo6YWZ0ZXIge1xcbiAgYm94LXNpemluZzogYm9yZGVyLWJveDsgLyogMSAqL1xcbiAgYm9yZGVyLXdpZHRoOiAwOyAvKiAyICovXFxuICBib3JkZXItc3R5bGU6IHNvbGlkOyAvKiAyICovXFxuICBib3JkZXItY29sb3I6ICNlNWU3ZWI7IC8qIDIgKi9cXG59XFxuXFxuOjpiZWZvcmUsXFxuOjphZnRlciB7XFxuICAtLXR3LWNvbnRlbnQ6ICcnO1xcbn1cXG5cXG4vKlxcbjEuIFVzZSBhIGNvbnNpc3RlbnQgc2Vuc2libGUgbGluZS1oZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbjIuIFByZXZlbnQgYWRqdXN0bWVudHMgb2YgZm9udCBzaXplIGFmdGVyIG9yaWVudGF0aW9uIGNoYW5nZXMgaW4gaU9TLlxcbjMuIFVzZSBhIG1vcmUgcmVhZGFibGUgdGFiIHNpemUuXFxuNC4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgc2Fuc2AgZm9udC1mYW1pbHkgYnkgZGVmYXVsdC5cXG41LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LWZlYXR1cmUtc2V0dGluZ3MgYnkgZGVmYXVsdC5cXG42LiBVc2UgdGhlIHVzZXIncyBjb25maWd1cmVkIGBzYW5zYCBmb250LXZhcmlhdGlvbi1zZXR0aW5ncyBieSBkZWZhdWx0LlxcbiovXFxuXFxuaHRtbCB7XFxuICBsaW5lLWhlaWdodDogMS41OyAvKiAxICovXFxuICAtd2Via2l0LXRleHQtc2l6ZS1hZGp1c3Q6IDEwMCU7IC8qIDIgKi8gLyogMyAqL1xcbiAgdGFiLXNpemU6IDQ7IC8qIDMgKi9cXG4gIGZvbnQtZmFtaWx5OiB1aS1zYW5zLXNlcmlmLCBzeXN0ZW0tdWksIC1hcHBsZS1zeXN0ZW0sIEJsaW5rTWFjU3lzdGVtRm9udCwgXFxcIlNlZ29lIFVJXFxcIiwgUm9ib3RvLCBcXFwiSGVsdmV0aWNhIE5ldWVcXFwiLCBBcmlhbCwgXFxcIk5vdG8gU2Fuc1xcXCIsIHNhbnMtc2VyaWYsIFxcXCJBcHBsZSBDb2xvciBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBFbW9qaVxcXCIsIFxcXCJTZWdvZSBVSSBTeW1ib2xcXFwiLCBcXFwiTm90byBDb2xvciBFbW9qaVxcXCI7IC8qIDQgKi9cXG4gIGZvbnQtZmVhdHVyZS1zZXR0aW5nczogbm9ybWFsOyAvKiA1ICovXFxuICBmb250LXZhcmlhdGlvbi1zZXR0aW5nczogbm9ybWFsOyAvKiA2ICovXFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gYWxsIGJyb3dzZXJzLlxcbjIuIEluaGVyaXQgbGluZS1oZWlnaHQgZnJvbSBgaHRtbGAgc28gdXNlcnMgY2FuIHNldCB0aGVtIGFzIGEgY2xhc3MgZGlyZWN0bHkgb24gdGhlIGBodG1sYCBlbGVtZW50LlxcbiovXFxuXFxuYm9keSB7XFxuICBtYXJnaW46IDA7IC8qIDEgKi9cXG4gIGxpbmUtaGVpZ2h0OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qXFxuMS4gQWRkIHRoZSBjb3JyZWN0IGhlaWdodCBpbiBGaXJlZm94LlxcbjIuIENvcnJlY3QgdGhlIGluaGVyaXRhbmNlIG9mIGJvcmRlciBjb2xvciBpbiBGaXJlZm94LiAoaHR0cHM6Ly9idWd6aWxsYS5tb3ppbGxhLm9yZy9zaG93X2J1Zy5jZ2k/aWQ9MTkwNjU1KVxcbjMuIEVuc3VyZSBob3Jpem9udGFsIHJ1bGVzIGFyZSB2aXNpYmxlIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG5ociB7XFxuICBoZWlnaHQ6IDA7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItdG9wLXdpZHRoOiAxcHg7IC8qIDMgKi9cXG59XFxuXFxuLypcXG5BZGQgdGhlIGNvcnJlY3QgdGV4dCBkZWNvcmF0aW9uIGluIENocm9tZSwgRWRnZSwgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmFiYnI6d2hlcmUoW3RpdGxlXSkge1xcbiAgLXdlYmtpdC10ZXh0LWRlY29yYXRpb246IHVuZGVybGluZSBkb3R0ZWQ7XFxuICAgICAgICAgIHRleHQtZGVjb3JhdGlvbjogdW5kZXJsaW5lIGRvdHRlZDtcXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGRlZmF1bHQgZm9udCBzaXplIGFuZCB3ZWlnaHQgZm9yIGhlYWRpbmdzLlxcbiovXFxuXFxuaDEsXFxuaDIsXFxuaDMsXFxuaDQsXFxuaDUsXFxuaDYge1xcbiAgZm9udC1zaXplOiBpbmhlcml0O1xcbiAgZm9udC13ZWlnaHQ6IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuUmVzZXQgbGlua3MgdG8gb3B0aW1pemUgZm9yIG9wdC1pbiBzdHlsaW5nIGluc3RlYWQgb2Ygb3B0LW91dC5cXG4qL1xcblxcbmEge1xcbiAgY29sb3I6IGluaGVyaXQ7XFxuICB0ZXh0LWRlY29yYXRpb246IGluaGVyaXQ7XFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgd2VpZ2h0IGluIEVkZ2UgYW5kIFNhZmFyaS5cXG4qL1xcblxcbmIsXFxuc3Ryb25nIHtcXG4gIGZvbnQtd2VpZ2h0OiBib2xkZXI7XFxufVxcblxcbi8qXFxuMS4gVXNlIHRoZSB1c2VyJ3MgY29uZmlndXJlZCBgbW9ub2AgZm9udCBmYW1pbHkgYnkgZGVmYXVsdC5cXG4yLiBDb3JyZWN0IHRoZSBvZGQgYGVtYCBmb250IHNpemluZyBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5jb2RlLFxcbmtiZCxcXG5zYW1wLFxcbnByZSB7XFxuICBmb250LWZhbWlseTogdWktbW9ub3NwYWNlLCBTRk1vbm8tUmVndWxhciwgTWVubG8sIE1vbmFjbywgQ29uc29sYXMsIFxcXCJMaWJlcmF0aW9uIE1vbm9cXFwiLCBcXFwiQ291cmllciBOZXdcXFwiLCBtb25vc3BhY2U7IC8qIDEgKi9cXG4gIGZvbnQtc2l6ZTogMWVtOyAvKiAyICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGZvbnQgc2l6ZSBpbiBhbGwgYnJvd3NlcnMuXFxuKi9cXG5cXG5zbWFsbCB7XFxuICBmb250LXNpemU6IDgwJTtcXG59XFxuXFxuLypcXG5QcmV2ZW50IGBzdWJgIGFuZCBgc3VwYCBlbGVtZW50cyBmcm9tIGFmZmVjdGluZyB0aGUgbGluZSBoZWlnaHQgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuc3ViLFxcbnN1cCB7XFxuICBmb250LXNpemU6IDc1JTtcXG4gIGxpbmUtaGVpZ2h0OiAwO1xcbiAgcG9zaXRpb246IHJlbGF0aXZlO1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG5zdWIge1xcbiAgYm90dG9tOiAtMC4yNWVtO1xcbn1cXG5cXG5zdXAge1xcbiAgdG9wOiAtMC41ZW07XFxufVxcblxcbi8qXFxuMS4gUmVtb3ZlIHRleHQgaW5kZW50YXRpb24gZnJvbSB0YWJsZSBjb250ZW50cyBpbiBDaHJvbWUgYW5kIFNhZmFyaS4gKGh0dHBzOi8vYnVncy5jaHJvbWl1bS5vcmcvcC9jaHJvbWl1bS9pc3N1ZXMvZGV0YWlsP2lkPTk5OTA4OCwgaHR0cHM6Ly9idWdzLndlYmtpdC5vcmcvc2hvd19idWcuY2dpP2lkPTIwMTI5NylcXG4yLiBDb3JyZWN0IHRhYmxlIGJvcmRlciBjb2xvciBpbmhlcml0YW5jZSBpbiBhbGwgQ2hyb21lIGFuZCBTYWZhcmkuIChodHRwczovL2J1Z3MuY2hyb21pdW0ub3JnL3AvY2hyb21pdW0vaXNzdWVzL2RldGFpbD9pZD05MzU3MjksIGh0dHBzOi8vYnVncy53ZWJraXQub3JnL3Nob3dfYnVnLmNnaT9pZD0xOTUwMTYpXFxuMy4gUmVtb3ZlIGdhcHMgYmV0d2VlbiB0YWJsZSBib3JkZXJzIGJ5IGRlZmF1bHQuXFxuKi9cXG5cXG50YWJsZSB7XFxuICB0ZXh0LWluZGVudDogMDsgLyogMSAqL1xcbiAgYm9yZGVyLWNvbG9yOiBpbmhlcml0OyAvKiAyICovXFxuICBib3JkZXItY29sbGFwc2U6IGNvbGxhcHNlOyAvKiAzICovXFxufVxcblxcbi8qXFxuMS4gQ2hhbmdlIHRoZSBmb250IHN0eWxlcyBpbiBhbGwgYnJvd3NlcnMuXFxuMi4gUmVtb3ZlIHRoZSBtYXJnaW4gaW4gRmlyZWZveCBhbmQgU2FmYXJpLlxcbjMuIFJlbW92ZSBkZWZhdWx0IHBhZGRpbmcgaW4gYWxsIGJyb3dzZXJzLlxcbiovXFxuXFxuYnV0dG9uLFxcbmlucHV0LFxcbm9wdGdyb3VwLFxcbnNlbGVjdCxcXG50ZXh0YXJlYSB7XFxuICBmb250LWZhbWlseTogaW5oZXJpdDsgLyogMSAqL1xcbiAgZm9udC1zaXplOiAxMDAlOyAvKiAxICovXFxuICBmb250LXdlaWdodDogaW5oZXJpdDsgLyogMSAqL1xcbiAgbGluZS1oZWlnaHQ6IGluaGVyaXQ7IC8qIDEgKi9cXG4gIGNvbG9yOiBpbmhlcml0OyAvKiAxICovXFxuICBtYXJnaW46IDA7IC8qIDIgKi9cXG4gIHBhZGRpbmc6IDA7IC8qIDMgKi9cXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGluaGVyaXRhbmNlIG9mIHRleHQgdHJhbnNmb3JtIGluIEVkZ2UgYW5kIEZpcmVmb3guXFxuKi9cXG5cXG5idXR0b24sXFxuc2VsZWN0IHtcXG4gIHRleHQtdHJhbnNmb3JtOiBub25lO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIGluYWJpbGl0eSB0byBzdHlsZSBjbGlja2FibGUgdHlwZXMgaW4gaU9TIGFuZCBTYWZhcmkuXFxuMi4gUmVtb3ZlIGRlZmF1bHQgYnV0dG9uIHN0eWxlcy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bdHlwZT0nYnV0dG9uJ10sXFxuW3R5cGU9J3Jlc2V0J10sXFxuW3R5cGU9J3N1Ym1pdCddIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBiYWNrZ3JvdW5kLWNvbG9yOiB0cmFuc3BhcmVudDsgLyogMiAqL1xcbiAgYmFja2dyb3VuZC1pbWFnZTogbm9uZTsgLyogMiAqL1xcbn1cXG5cXG4vKlxcblVzZSB0aGUgbW9kZXJuIEZpcmVmb3ggZm9jdXMgc3R5bGUgZm9yIGFsbCBmb2N1c2FibGUgZWxlbWVudHMuXFxuKi9cXG5cXG46LW1vei1mb2N1c3Jpbmcge1xcbiAgb3V0bGluZTogYXV0bztcXG59XFxuXFxuLypcXG5SZW1vdmUgdGhlIGFkZGl0aW9uYWwgYDppbnZhbGlkYCBzdHlsZXMgaW4gRmlyZWZveC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9tb3ppbGxhL2dlY2tvLWRldi9ibG9iLzJmOWVhY2Q5ZDNkOTk1YzkzN2I0MjUxYTU1NTdkOTVkNDk0YzliZTEvbGF5b3V0L3N0eWxlL3Jlcy9mb3Jtcy5jc3MjTDcyOC1MNzM3KVxcbiovXFxuXFxuOi1tb3otdWktaW52YWxpZCB7XFxuICBib3gtc2hhZG93OiBub25lO1xcbn1cXG5cXG4vKlxcbkFkZCB0aGUgY29ycmVjdCB2ZXJ0aWNhbCBhbGlnbm1lbnQgaW4gQ2hyb21lIGFuZCBGaXJlZm94LlxcbiovXFxuXFxucHJvZ3Jlc3Mge1xcbiAgdmVydGljYWwtYWxpZ246IGJhc2VsaW5lO1xcbn1cXG5cXG4vKlxcbkNvcnJlY3QgdGhlIGN1cnNvciBzdHlsZSBvZiBpbmNyZW1lbnQgYW5kIGRlY3JlbWVudCBidXR0b25zIGluIFNhZmFyaS5cXG4qL1xcblxcbjo6LXdlYmtpdC1pbm5lci1zcGluLWJ1dHRvbixcXG46Oi13ZWJraXQtb3V0ZXItc3Bpbi1idXR0b24ge1xcbiAgaGVpZ2h0OiBhdXRvO1xcbn1cXG5cXG4vKlxcbjEuIENvcnJlY3QgdGhlIG9kZCBhcHBlYXJhbmNlIGluIENocm9tZSBhbmQgU2FmYXJpLlxcbjIuIENvcnJlY3QgdGhlIG91dGxpbmUgc3R5bGUgaW4gU2FmYXJpLlxcbiovXFxuXFxuW3R5cGU9J3NlYXJjaCddIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogdGV4dGZpZWxkOyAvKiAxICovXFxuICBvdXRsaW5lLW9mZnNldDogLTJweDsgLyogMiAqL1xcbn1cXG5cXG4vKlxcblJlbW92ZSB0aGUgaW5uZXIgcGFkZGluZyBpbiBDaHJvbWUgYW5kIFNhZmFyaSBvbiBtYWNPUy5cXG4qL1xcblxcbjo6LXdlYmtpdC1zZWFyY2gtZGVjb3JhdGlvbiB7XFxuICAtd2Via2l0LWFwcGVhcmFuY2U6IG5vbmU7XFxufVxcblxcbi8qXFxuMS4gQ29ycmVjdCB0aGUgaW5hYmlsaXR5IHRvIHN0eWxlIGNsaWNrYWJsZSB0eXBlcyBpbiBpT1MgYW5kIFNhZmFyaS5cXG4yLiBDaGFuZ2UgZm9udCBwcm9wZXJ0aWVzIHRvIGBpbmhlcml0YCBpbiBTYWZhcmkuXFxuKi9cXG5cXG46Oi13ZWJraXQtZmlsZS11cGxvYWQtYnV0dG9uIHtcXG4gIC13ZWJraXQtYXBwZWFyYW5jZTogYnV0dG9uOyAvKiAxICovXFxuICBmb250OiBpbmhlcml0OyAvKiAyICovXFxufVxcblxcbi8qXFxuQWRkIHRoZSBjb3JyZWN0IGRpc3BsYXkgaW4gQ2hyb21lIGFuZCBTYWZhcmkuXFxuKi9cXG5cXG5zdW1tYXJ5IHtcXG4gIGRpc3BsYXk6IGxpc3QtaXRlbTtcXG59XFxuXFxuLypcXG5SZW1vdmVzIHRoZSBkZWZhdWx0IHNwYWNpbmcgYW5kIGJvcmRlciBmb3IgYXBwcm9wcmlhdGUgZWxlbWVudHMuXFxuKi9cXG5cXG5ibG9ja3F1b3RlLFxcbmRsLFxcbmRkLFxcbmgxLFxcbmgyLFxcbmgzLFxcbmg0LFxcbmg1LFxcbmg2LFxcbmhyLFxcbmZpZ3VyZSxcXG5wLFxcbnByZSB7XFxuICBtYXJnaW46IDA7XFxufVxcblxcbmZpZWxkc2V0IHtcXG4gIG1hcmdpbjogMDtcXG4gIHBhZGRpbmc6IDA7XFxufVxcblxcbmxlZ2VuZCB7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG5vbCxcXG51bCxcXG5tZW51IHtcXG4gIGxpc3Qtc3R5bGU6IG5vbmU7XFxuICBtYXJnaW46IDA7XFxuICBwYWRkaW5nOiAwO1xcbn1cXG5cXG4vKlxcblByZXZlbnQgcmVzaXppbmcgdGV4dGFyZWFzIGhvcml6b250YWxseSBieSBkZWZhdWx0LlxcbiovXFxuXFxudGV4dGFyZWEge1xcbiAgcmVzaXplOiB2ZXJ0aWNhbDtcXG59XFxuXFxuLypcXG4xLiBSZXNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBvcGFjaXR5IGluIEZpcmVmb3guIChodHRwczovL2dpdGh1Yi5jb20vdGFpbHdpbmRsYWJzL3RhaWx3aW5kY3NzL2lzc3Vlcy8zMzAwKVxcbjIuIFNldCB0aGUgZGVmYXVsdCBwbGFjZWhvbGRlciBjb2xvciB0byB0aGUgdXNlcidzIGNvbmZpZ3VyZWQgZ3JheSA0MDAgY29sb3IuXFxuKi9cXG5cXG5pbnB1dDo6cGxhY2Vob2xkZXIsXFxudGV4dGFyZWE6OnBsYWNlaG9sZGVyIHtcXG4gIG9wYWNpdHk6IDE7IC8qIDEgKi9cXG4gIGNvbG9yOiAjOWNhM2FmOyAvKiAyICovXFxufVxcblxcbi8qXFxuU2V0IHRoZSBkZWZhdWx0IGN1cnNvciBmb3IgYnV0dG9ucy5cXG4qL1xcblxcbmJ1dHRvbixcXG5bcm9sZT1cXFwiYnV0dG9uXFxcIl0ge1xcbiAgY3Vyc29yOiBwb2ludGVyO1xcbn1cXG5cXG4vKlxcbk1ha2Ugc3VyZSBkaXNhYmxlZCBidXR0b25zIGRvbid0IGdldCB0aGUgcG9pbnRlciBjdXJzb3IuXFxuKi9cXG46ZGlzYWJsZWQge1xcbiAgY3Vyc29yOiBkZWZhdWx0O1xcbn1cXG5cXG4vKlxcbjEuIE1ha2UgcmVwbGFjZWQgZWxlbWVudHMgYGRpc3BsYXk6IGJsb2NrYCBieSBkZWZhdWx0LiAoaHR0cHM6Ly9naXRodWIuY29tL21vemRldnMvY3NzcmVtZWR5L2lzc3Vlcy8xNClcXG4yLiBBZGQgYHZlcnRpY2FsLWFsaWduOiBtaWRkbGVgIHRvIGFsaWduIHJlcGxhY2VkIGVsZW1lbnRzIG1vcmUgc2Vuc2libHkgYnkgZGVmYXVsdC4gKGh0dHBzOi8vZ2l0aHViLmNvbS9qZW5zaW1tb25zL2Nzc3JlbWVkeS9pc3N1ZXMvMTQjaXNzdWVjb21tZW50LTYzNDkzNDIxMClcXG4gICBUaGlzIGNhbiB0cmlnZ2VyIGEgcG9vcmx5IGNvbnNpZGVyZWQgbGludCBlcnJvciBpbiBzb21lIHRvb2xzIGJ1dCBpcyBpbmNsdWRlZCBieSBkZXNpZ24uXFxuKi9cXG5cXG5pbWcsXFxuc3ZnLFxcbnZpZGVvLFxcbmNhbnZhcyxcXG5hdWRpbyxcXG5pZnJhbWUsXFxuZW1iZWQsXFxub2JqZWN0IHtcXG4gIGRpc3BsYXk6IGJsb2NrOyAvKiAxICovXFxuICB2ZXJ0aWNhbC1hbGlnbjogbWlkZGxlOyAvKiAyICovXFxufVxcblxcbi8qXFxuQ29uc3RyYWluIGltYWdlcyBhbmQgdmlkZW9zIHRvIHRoZSBwYXJlbnQgd2lkdGggYW5kIHByZXNlcnZlIHRoZWlyIGludHJpbnNpYyBhc3BlY3QgcmF0aW8uIChodHRwczovL2dpdGh1Yi5jb20vbW96ZGV2cy9jc3NyZW1lZHkvaXNzdWVzLzE0KVxcbiovXFxuXFxuaW1nLFxcbnZpZGVvIHtcXG4gIG1heC13aWR0aDogMTAwJTtcXG4gIGhlaWdodDogYXV0bztcXG59XFxuXFxuLyogTWFrZSBlbGVtZW50cyB3aXRoIHRoZSBIVE1MIGhpZGRlbiBhdHRyaWJ1dGUgc3RheSBoaWRkZW4gYnkgZGVmYXVsdCAqL1xcbltoaWRkZW5dIHtcXG4gIGRpc3BsYXk6IG5vbmU7XFxufVxcblxcbiosIDo6YmVmb3JlLCA6OmFmdGVyIHtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteDogMDtcXG4gIC0tdHctYm9yZGVyLXNwYWNpbmcteTogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXg6IDA7XFxuICAtLXR3LXRyYW5zbGF0ZS15OiAwO1xcbiAgLS10dy1yb3RhdGU6IDA7XFxuICAtLXR3LXNrZXcteDogMDtcXG4gIC0tdHctc2tldy15OiAwO1xcbiAgLS10dy1zY2FsZS14OiAxO1xcbiAgLS10dy1zY2FsZS15OiAxO1xcbiAgLS10dy1wYW4teDogIDtcXG4gIC0tdHctcGFuLXk6ICA7XFxuICAtLXR3LXBpbmNoLXpvb206ICA7XFxuICAtLXR3LXNjcm9sbC1zbmFwLXN0cmljdG5lc3M6IHByb3hpbWl0eTtcXG4gIC0tdHctb3JkaW5hbDogIDtcXG4gIC0tdHctc2xhc2hlZC16ZXJvOiAgO1xcbiAgLS10dy1udW1lcmljLWZpZ3VyZTogIDtcXG4gIC0tdHctbnVtZXJpYy1zcGFjaW5nOiAgO1xcbiAgLS10dy1udW1lcmljLWZyYWN0aW9uOiAgO1xcbiAgLS10dy1yaW5nLWluc2V0OiAgO1xcbiAgLS10dy1yaW5nLW9mZnNldC13aWR0aDogMHB4O1xcbiAgLS10dy1yaW5nLW9mZnNldC1jb2xvcjogI2ZmZjtcXG4gIC0tdHctcmluZy1jb2xvcjogcmdiKDU5IDEzMCAyNDYgLyAwLjUpO1xcbiAgLS10dy1yaW5nLW9mZnNldC1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctcmluZy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93OiAwIDAgIzAwMDA7XFxuICAtLXR3LXNoYWRvdy1jb2xvcmVkOiAwIDAgIzAwMDA7XFxuICAtLXR3LWJsdXI6ICA7XFxuICAtLXR3LWJyaWdodG5lc3M6ICA7XFxuICAtLXR3LWNvbnRyYXN0OiAgO1xcbiAgLS10dy1ncmF5c2NhbGU6ICA7XFxuICAtLXR3LWh1ZS1yb3RhdGU6ICA7XFxuICAtLXR3LWludmVydDogIDtcXG4gIC0tdHctc2F0dXJhdGU6ICA7XFxuICAtLXR3LXNlcGlhOiAgO1xcbiAgLS10dy1kcm9wLXNoYWRvdzogIDtcXG4gIC0tdHctYmFja2Ryb3AtYmx1cjogIDtcXG4gIC0tdHctYmFja2Ryb3AtYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctYmFja2Ryb3AtY29udHJhc3Q6ICA7XFxuICAtLXR3LWJhY2tkcm9wLWdyYXlzY2FsZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3AtaW52ZXJ0OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1vcGFjaXR5OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zYXR1cmF0ZTogIDtcXG4gIC0tdHctYmFja2Ryb3Atc2VwaWE6ICA7XFxufVxcblxcbjo6YmFja2Ryb3Age1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy14OiAwO1xcbiAgLS10dy1ib3JkZXItc3BhY2luZy15OiAwO1xcbiAgLS10dy10cmFuc2xhdGUteDogMDtcXG4gIC0tdHctdHJhbnNsYXRlLXk6IDA7XFxuICAtLXR3LXJvdGF0ZTogMDtcXG4gIC0tdHctc2tldy14OiAwO1xcbiAgLS10dy1za2V3LXk6IDA7XFxuICAtLXR3LXNjYWxlLXg6IDE7XFxuICAtLXR3LXNjYWxlLXk6IDE7XFxuICAtLXR3LXBhbi14OiAgO1xcbiAgLS10dy1wYW4teTogIDtcXG4gIC0tdHctcGluY2gtem9vbTogIDtcXG4gIC0tdHctc2Nyb2xsLXNuYXAtc3RyaWN0bmVzczogcHJveGltaXR5O1xcbiAgLS10dy1vcmRpbmFsOiAgO1xcbiAgLS10dy1zbGFzaGVkLXplcm86ICA7XFxuICAtLXR3LW51bWVyaWMtZmlndXJlOiAgO1xcbiAgLS10dy1udW1lcmljLXNwYWNpbmc6ICA7XFxuICAtLXR3LW51bWVyaWMtZnJhY3Rpb246ICA7XFxuICAtLXR3LXJpbmctaW5zZXQ6ICA7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXdpZHRoOiAwcHg7XFxuICAtLXR3LXJpbmctb2Zmc2V0LWNvbG9yOiAjZmZmO1xcbiAgLS10dy1yaW5nLWNvbG9yOiByZ2IoNTkgMTMwIDI0NiAvIDAuNSk7XFxuICAtLXR3LXJpbmctb2Zmc2V0LXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1yaW5nLXNoYWRvdzogMCAwICMwMDAwO1xcbiAgLS10dy1zaGFkb3c6IDAgMCAjMDAwMDtcXG4gIC0tdHctc2hhZG93LWNvbG9yZWQ6IDAgMCAjMDAwMDtcXG4gIC0tdHctYmx1cjogIDtcXG4gIC0tdHctYnJpZ2h0bmVzczogIDtcXG4gIC0tdHctY29udHJhc3Q6ICA7XFxuICAtLXR3LWdyYXlzY2FsZTogIDtcXG4gIC0tdHctaHVlLXJvdGF0ZTogIDtcXG4gIC0tdHctaW52ZXJ0OiAgO1xcbiAgLS10dy1zYXR1cmF0ZTogIDtcXG4gIC0tdHctc2VwaWE6ICA7XFxuICAtLXR3LWRyb3Atc2hhZG93OiAgO1xcbiAgLS10dy1iYWNrZHJvcC1ibHVyOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1icmlnaHRuZXNzOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1jb250cmFzdDogIDtcXG4gIC0tdHctYmFja2Ryb3AtZ3JheXNjYWxlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1odWUtcm90YXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1pbnZlcnQ6ICA7XFxuICAtLXR3LWJhY2tkcm9wLW9wYWNpdHk6ICA7XFxuICAtLXR3LWJhY2tkcm9wLXNhdHVyYXRlOiAgO1xcbiAgLS10dy1iYWNrZHJvcC1zZXBpYTogIDtcXG59XFxuXCIsIFwiXCIse1widmVyc2lvblwiOjMsXCJzb3VyY2VzXCI6W1wid2VicGFjazovL25vZGVfbW9kdWxlcy90YWlsd2luZGNzcy90YWlsd2luZC5jc3NcIl0sXCJuYW1lc1wiOltdLFwibWFwcGluZ3NcIjpcIkFBQUE7O0NBQWMsQ0FBZDs7O0NBQWM7O0FBQWQ7OztFQUFBLHNC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Q0FBYztBQUFkO0VBQUEsZUFBYztBQUFBOztBQUFkOzs7O0NBQWM7O0FBQWQ7Ozs7Ozs7O0VBQUEsY0FBYyxFQUFkLE1BQWM7RUFBZCxzQkFBYyxFQUFkLE1BQWM7QUFBQTs7QUFBZDs7Q0FBYzs7QUFBZDs7RUFBQSxlQUFjO0VBQWQsWUFBYztBQUFBOztBQUFkLHdFQUFjO0FBQWQ7RUFBQSxhQUFjO0FBQUE7O0FBQWQ7RUFBQSx3QkFBYztFQUFkLHdCQUFjO0VBQWQsbUJBQWM7RUFBZCxtQkFBYztFQUFkLGNBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGVBQWM7RUFBZCxlQUFjO0VBQWQsYUFBYztFQUFkLGFBQWM7RUFBZCxrQkFBYztFQUFkLHNDQUFjO0VBQWQsZUFBYztFQUFkLG9CQUFjO0VBQWQsc0JBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQsa0JBQWM7RUFBZCwyQkFBYztFQUFkLDRCQUFjO0VBQWQsc0NBQWM7RUFBZCxrQ0FBYztFQUFkLDJCQUFjO0VBQWQsc0JBQWM7RUFBZCw4QkFBYztFQUFkLFlBQWM7RUFBZCxrQkFBYztFQUFkLGdCQUFjO0VBQWQsaUJBQWM7RUFBZCxrQkFBYztFQUFkLGNBQWM7RUFBZCxnQkFBYztFQUFkLGFBQWM7RUFBZCxtQkFBYztFQUFkLHFCQUFjO0VBQWQsMkJBQWM7RUFBZCx5QkFBYztFQUFkLDBCQUFjO0VBQWQsMkJBQWM7RUFBZCx1QkFBYztFQUFkLHdCQUFjO0VBQWQseUJBQWM7RUFBZDtBQUFjOztBQUFkO0VBQUEsd0JBQWM7RUFBZCx3QkFBYztFQUFkLG1CQUFjO0VBQWQsbUJBQWM7RUFBZCxjQUFjO0VBQWQsY0FBYztFQUFkLGNBQWM7RUFBZCxlQUFjO0VBQWQsZUFBYztFQUFkLGFBQWM7RUFBZCxhQUFjO0VBQWQsa0JBQWM7RUFBZCxzQ0FBYztFQUFkLGVBQWM7RUFBZCxvQkFBYztFQUFkLHNCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLGtCQUFjO0VBQWQsMkJBQWM7RUFBZCw0QkFBYztFQUFkLHNDQUFjO0VBQWQsa0NBQWM7RUFBZCwyQkFBYztFQUFkLHNCQUFjO0VBQWQsOEJBQWM7RUFBZCxZQUFjO0VBQWQsa0JBQWM7RUFBZCxnQkFBYztFQUFkLGlCQUFjO0VBQWQsa0JBQWM7RUFBZCxjQUFjO0VBQWQsZ0JBQWM7RUFBZCxhQUFjO0VBQWQsbUJBQWM7RUFBZCxxQkFBYztFQUFkLDJCQUFjO0VBQWQseUJBQWM7RUFBZCwwQkFBYztFQUFkLDJCQUFjO0VBQWQsdUJBQWM7RUFBZCx3QkFBYztFQUFkLHlCQUFjO0VBQWQ7QUFBY1wiLFwic291cmNlc0NvbnRlbnRcIjpbXCJAdGFpbHdpbmQgYmFzZTtcXG5cXG5AdGFpbHdpbmQgY29tcG9uZW50cztcXG5cXG5AdGFpbHdpbmQgdXRpbGl0aWVzO1xcblwiXSxcInNvdXJjZVJvb3RcIjpcIlwifV0pO1xuLy8gRXhwb3J0c1xuZXhwb3J0IGRlZmF1bHQgX19fQ1NTX0xPQURFUl9FWFBPUlRfX187XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js":
/*!************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js ***!
  \************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/*\n  MIT License http://www.opensource.org/licenses/mit-license.php\n  Author Tobias Koppers @sokra\n*/ // css base code, injected by the css-loader\n// eslint-disable-next-line func-names\n\nmodule.exports = function(useSourceMap) {\n    var list = [] // return the list of modules as css string\n    ;\n    list.toString = function toString() {\n        return this.map(function(item) {\n            // eslint-disable-next-line @typescript-eslint/no-use-before-define\n            var content = cssWithMappingToString(item, useSourceMap);\n            if (item[2]) {\n                return \"@media \".concat(item[2], \" {\").concat(content, \"}\");\n            }\n            return content;\n        }).join(\"\");\n    } // import a list of modules into the list\n    ;\n    // eslint-disable-next-line func-names\n    // @ts-expect-error TODO: fix type\n    list.i = function(modules, mediaQuery, dedupe) {\n        if (typeof modules === \"string\") {\n            // eslint-disable-next-line no-param-reassign\n            modules = [\n                [\n                    null,\n                    modules,\n                    \"\"\n                ]\n            ];\n        }\n        var alreadyImportedModules = {};\n        if (dedupe) {\n            for(var i = 0; i < this.length; i++){\n                // eslint-disable-next-line prefer-destructuring\n                var id = this[i][0];\n                if (id != null) {\n                    alreadyImportedModules[id] = true;\n                }\n            }\n        }\n        for(var _i = 0; _i < modules.length; _i++){\n            var item = [].concat(modules[_i]);\n            if (dedupe && alreadyImportedModules[item[0]]) {\n                continue;\n            }\n            if (mediaQuery) {\n                if (!item[2]) {\n                    item[2] = mediaQuery;\n                } else {\n                    item[2] = \"\".concat(mediaQuery, \" and \").concat(item[2]);\n                }\n            }\n            list.push(item);\n        }\n    };\n    return list;\n};\nfunction cssWithMappingToString(item, useSourceMap) {\n    var content = item[1] || \"\" // eslint-disable-next-line prefer-destructuring\n    ;\n    var cssMapping = item[3];\n    if (!cssMapping) {\n        return content;\n    }\n    if (useSourceMap && typeof btoa === \"function\") {\n        // eslint-disable-next-line @typescript-eslint/no-use-before-define\n        var sourceMapping = toComment(cssMapping);\n        var sourceURLs = cssMapping.sources.map(function(source) {\n            return \"/*# sourceURL=\".concat(cssMapping.sourceRoot || \"\").concat(source, \" */\");\n        });\n        return [\n            content\n        ].concat(sourceURLs).concat([\n            sourceMapping\n        ]).join(\"\\n\");\n    }\n    return [\n        content\n    ].join(\"\\n\");\n} // Adapted from convert-source-map (MIT)\nfunction toComment(sourceMap) {\n    // eslint-disable-next-line no-undef\n    var base64 = btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap))));\n    var data = \"sourceMappingURL=data:application/json;charset=utf-8;base64,\".concat(base64);\n    return \"/*# \".concat(data, \" */\");\n}\n\n//# sourceMappingURL=api.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9ydW50aW1lL2FwaS5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0RBQW9ELHFCQUFxQjtBQUN6RTtBQUNBO0FBQ0EsU0FBUztBQUNULE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixpQkFBaUI7QUFDNUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IscUJBQXFCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0JBQWtCO0FBQ2xCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCxjQUFjO0FBQ3JFO0FBQ0E7O0FBRUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvcnVudGltZS9hcGkuanM/Y2E0ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvKlxuICBNSVQgTGljZW5zZSBodHRwOi8vd3d3Lm9wZW5zb3VyY2Uub3JnL2xpY2Vuc2VzL21pdC1saWNlbnNlLnBocFxuICBBdXRob3IgVG9iaWFzIEtvcHBlcnMgQHNva3JhXG4qLyAvLyBjc3MgYmFzZSBjb2RlLCBpbmplY3RlZCBieSB0aGUgY3NzLWxvYWRlclxuLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIGZ1bmMtbmFtZXNcblwidXNlIHN0cmljdFwiO1xubW9kdWxlLmV4cG9ydHMgPSBmdW5jdGlvbih1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgbGlzdCA9IFtdIC8vIHJldHVybiB0aGUgbGlzdCBvZiBtb2R1bGVzIGFzIGNzcyBzdHJpbmdcbiAgICA7XG4gICAgbGlzdC50b1N0cmluZyA9IGZ1bmN0aW9uIHRvU3RyaW5nKCkge1xuICAgICAgICByZXR1cm4gdGhpcy5tYXAoZnVuY3Rpb24oaXRlbSkge1xuICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgdmFyIGNvbnRlbnQgPSBjc3NXaXRoTWFwcGluZ1RvU3RyaW5nKGl0ZW0sIHVzZVNvdXJjZU1hcCk7XG4gICAgICAgICAgICBpZiAoaXRlbVsyXSkge1xuICAgICAgICAgICAgICAgIHJldHVybiBcIkBtZWRpYSBcIi5jb25jYXQoaXRlbVsyXSwgXCIge1wiKS5jb25jYXQoY29udGVudCwgXCJ9XCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICAgIH0pLmpvaW4oXCJcIik7XG4gICAgfSAvLyBpbXBvcnQgYSBsaXN0IG9mIG1vZHVsZXMgaW50byB0aGUgbGlzdFxuICAgIDtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgZnVuYy1uYW1lc1xuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgVE9ETzogZml4IHR5cGVcbiAgICBsaXN0LmkgPSBmdW5jdGlvbihtb2R1bGVzLCBtZWRpYVF1ZXJ5LCBkZWR1cGUpIHtcbiAgICAgICAgaWYgKHR5cGVvZiBtb2R1bGVzID09PSBcInN0cmluZ1wiKSB7XG4gICAgICAgICAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcGFyYW0tcmVhc3NpZ25cbiAgICAgICAgICAgIG1vZHVsZXMgPSBbXG4gICAgICAgICAgICAgICAgW1xuICAgICAgICAgICAgICAgICAgICBudWxsLFxuICAgICAgICAgICAgICAgICAgICBtb2R1bGVzLFxuICAgICAgICAgICAgICAgICAgICBcIlwiXG4gICAgICAgICAgICAgICAgXVxuICAgICAgICAgICAgXTtcbiAgICAgICAgfVxuICAgICAgICB2YXIgYWxyZWFkeUltcG9ydGVkTW9kdWxlcyA9IHt9O1xuICAgICAgICBpZiAoZGVkdXBlKSB7XG4gICAgICAgICAgICBmb3IodmFyIGkgPSAwOyBpIDwgdGhpcy5sZW5ndGg7IGkrKyl7XG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHByZWZlci1kZXN0cnVjdHVyaW5nXG4gICAgICAgICAgICAgICAgdmFyIGlkID0gdGhpc1tpXVswXTtcbiAgICAgICAgICAgICAgICBpZiAoaWQgIT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBhbHJlYWR5SW1wb3J0ZWRNb2R1bGVzW2lkXSA9IHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGZvcih2YXIgX2kgPSAwOyBfaSA8IG1vZHVsZXMubGVuZ3RoOyBfaSsrKXtcbiAgICAgICAgICAgIHZhciBpdGVtID0gW10uY29uY2F0KG1vZHVsZXNbX2ldKTtcbiAgICAgICAgICAgIGlmIChkZWR1cGUgJiYgYWxyZWFkeUltcG9ydGVkTW9kdWxlc1tpdGVtWzBdXSkge1xuICAgICAgICAgICAgICAgIGNvbnRpbnVlO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKG1lZGlhUXVlcnkpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWl0ZW1bMl0pIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IG1lZGlhUXVlcnk7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgaXRlbVsyXSA9IFwiXCIuY29uY2F0KG1lZGlhUXVlcnksIFwiIGFuZCBcIikuY29uY2F0KGl0ZW1bMl0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGxpc3QucHVzaChpdGVtKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIGxpc3Q7XG59O1xuZnVuY3Rpb24gY3NzV2l0aE1hcHBpbmdUb1N0cmluZyhpdGVtLCB1c2VTb3VyY2VNYXApIHtcbiAgICB2YXIgY29udGVudCA9IGl0ZW1bMV0gfHwgXCJcIiAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcHJlZmVyLWRlc3RydWN0dXJpbmdcbiAgICA7XG4gICAgdmFyIGNzc01hcHBpbmcgPSBpdGVtWzNdO1xuICAgIGlmICghY3NzTWFwcGluZykge1xuICAgICAgICByZXR1cm4gY29udGVudDtcbiAgICB9XG4gICAgaWYgKHVzZVNvdXJjZU1hcCAmJiB0eXBlb2YgYnRvYSA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBAdHlwZXNjcmlwdC1lc2xpbnQvbm8tdXNlLWJlZm9yZS1kZWZpbmVcbiAgICAgICAgdmFyIHNvdXJjZU1hcHBpbmcgPSB0b0NvbW1lbnQoY3NzTWFwcGluZyk7XG4gICAgICAgIHZhciBzb3VyY2VVUkxzID0gY3NzTWFwcGluZy5zb3VyY2VzLm1hcChmdW5jdGlvbihzb3VyY2UpIHtcbiAgICAgICAgICAgIHJldHVybiBcIi8qIyBzb3VyY2VVUkw9XCIuY29uY2F0KGNzc01hcHBpbmcuc291cmNlUm9vdCB8fCBcIlwiKS5jb25jYXQoc291cmNlLCBcIiAqL1wiKTtcbiAgICAgICAgfSk7XG4gICAgICAgIHJldHVybiBbXG4gICAgICAgICAgICBjb250ZW50XG4gICAgICAgIF0uY29uY2F0KHNvdXJjZVVSTHMpLmNvbmNhdChbXG4gICAgICAgICAgICBzb3VyY2VNYXBwaW5nXG4gICAgICAgIF0pLmpvaW4oXCJcXG5cIik7XG4gICAgfVxuICAgIHJldHVybiBbXG4gICAgICAgIGNvbnRlbnRcbiAgICBdLmpvaW4oXCJcXG5cIik7XG59IC8vIEFkYXB0ZWQgZnJvbSBjb252ZXJ0LXNvdXJjZS1tYXAgKE1JVClcbmZ1bmN0aW9uIHRvQ29tbWVudChzb3VyY2VNYXApIHtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tdW5kZWZcbiAgICB2YXIgYmFzZTY0ID0gYnRvYSh1bmVzY2FwZShlbmNvZGVVUklDb21wb25lbnQoSlNPTi5zdHJpbmdpZnkoc291cmNlTWFwKSkpKTtcbiAgICB2YXIgZGF0YSA9IFwic291cmNlTWFwcGluZ1VSTD1kYXRhOmFwcGxpY2F0aW9uL2pzb247Y2hhcnNldD11dGYtODtiYXNlNjQsXCIuY29uY2F0KGJhc2U2NCk7XG4gICAgcmV0dXJuIFwiLyojIFwiLmNvbmNhdChkYXRhLCBcIiAqL1wiKTtcbn1cblxuLy8jIHNvdXJjZU1hcHBpbmdVUkw9YXBpLmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/css-loader/src/runtime/api.js\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CLENOVO%5CDesktop%5Civiewlabs-trial%5Cpages%5Cindex.js&page=%2F!":
/*!**********************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CLENOVO%5CDesktop%5Civiewlabs-trial%5Cpages%5Cindex.js&page=%2F! ***!
  \**********************************************************************************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("\n    (window.__NEXT_P = window.__NEXT_P || []).push([\n      \"/\",\n      function () {\n        return __webpack_require__(/*! ./pages/index.js */ \"./pages/index.js\");\n      }\n    ]);\n    if(true) {\n      module.hot.dispose(function () {\n        window.__NEXT_P.push([\"/\"])\n      });\n    }\n  //# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LWNsaWVudC1wYWdlcy1sb2FkZXIuanM/YWJzb2x1dGVQYWdlUGF0aD1DJTNBJTVDVXNlcnMlNUNMRU5PVk8lNUNEZXNrdG9wJTVDaXZpZXdsYWJzLXRyaWFsJTVDcGFnZXMlNUNpbmRleC5qcyZwYWdlPSUyRiEuanMiLCJtYXBwaW5ncyI6IjtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsbUJBQU8sQ0FBQywwQ0FBa0I7QUFDekM7QUFDQTtBQUNBLE9BQU8sSUFBVTtBQUNqQixNQUFNLFVBQVU7QUFDaEI7QUFDQSxPQUFPO0FBQ1A7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvPzI4ZDIiXSwic291cmNlc0NvbnRlbnQiOlsiXG4gICAgKHdpbmRvdy5fX05FWFRfUCA9IHdpbmRvdy5fX05FWFRfUCB8fCBbXSkucHVzaChbXG4gICAgICBcIi9cIixcbiAgICAgIGZ1bmN0aW9uICgpIHtcbiAgICAgICAgcmV0dXJuIHJlcXVpcmUoXCIuL3BhZ2VzL2luZGV4LmpzXCIpO1xuICAgICAgfVxuICAgIF0pO1xuICAgIGlmKG1vZHVsZS5ob3QpIHtcbiAgICAgIG1vZHVsZS5ob3QuZGlzcG9zZShmdW5jdGlvbiAoKSB7XG4gICAgICAgIHdpbmRvdy5fX05FWFRfUC5wdXNoKFtcIi9cIl0pXG4gICAgICB9KTtcbiAgICB9XG4gICJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CLENOVO%5CDesktop%5Civiewlabs-trial%5Cpages%5Cindex.js&page=%2F!\n"));

/***/ }),

/***/ "./node_modules/tailwindcss/tailwind.css":
/*!***********************************************!*\
  !*** ./node_modules/tailwindcss/tailwind.css ***!
  \***********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("var api = __webpack_require__(/*! !../next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js */ \"./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\");\n            var content = __webpack_require__(/*! !!../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./tailwind.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css\");\n\n            content = content.__esModule ? content.default : content;\n\n            if (typeof content === 'string') {\n              content = [[module.id, content, '']];\n            }\n\nvar options = {};\n\noptions.insert = function(element) {\n                    // By default, style-loader injects CSS into the bottom\n                    // of <head>. This causes ordering problems between dev\n                    // and prod. To fix this, we render a <noscript> tag as\n                    // an anchor for the styles to be placed before. These\n                    // styles will be applied _before_ <style jsx global>.\n                    // These elements should always exist. If they do not,\n                    // this code should fail.\n                    var anchorElement = document.querySelector(\"#__next_css__DO_NOT_USE__\");\n                    var parentNode = anchorElement.parentNode// Normally <head>\n                    ;\n                    // Each style tag should be placed right before our\n                    // anchor. By inserting before and not after, we do not\n                    // need to track the last inserted element.\n                    parentNode.insertBefore(element, anchorElement);\n                };\noptions.singleton = false;\n\nvar update = api(content, options);\n\n\nif (true) {\n  if (!content.locals || module.hot.invalidate) {\n    var isEqualLocals = function isEqualLocals(a, b, isNamedExport) {\n    if (!a && b || a && !b) {\n        return false;\n    }\n    let p;\n    for(p in a){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (a[p] !== b[p]) {\n            return false;\n        }\n    }\n    for(p in b){\n        if (isNamedExport && p === \"default\") {\n            continue;\n        }\n        if (!a[p]) {\n            return false;\n        }\n    }\n    return true;\n};\n    var oldLocals = content.locals;\n\n    module.hot.accept(\n      /*! !!../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./tailwind.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css\",\n      function () {\n        content = __webpack_require__(/*! !!../next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!../next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./tailwind.css */ \"./node_modules/next/dist/build/webpack/loaders/css-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[1]!./node_modules/next/dist/build/webpack/loaders/postcss-loader/src/index.js??ruleSet[1].rules[1].oneOf[11].use[2]!./node_modules/tailwindcss/tailwind.css\");\n\n              content = content.__esModule ? content.default : content;\n\n              if (typeof content === 'string') {\n                content = [[module.id, content, '']];\n              }\n\n              if (!isEqualLocals(oldLocals, content.locals)) {\n                module.hot.invalidate();\n\n                return;\n              }\n\n              oldLocals = content.locals;\n\n              update(content);\n      }\n    )\n  }\n\n  module.hot.dispose(function() {\n    update();\n  });\n}\n\nmodule.exports = content.locals || {};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvdGFpbHdpbmRjc3MvdGFpbHdpbmQuY3NzLmpzIiwibWFwcGluZ3MiOiJBQUFBLFVBQVUsbUJBQU8sQ0FBQyx1TUFBMkY7QUFDN0csMEJBQTBCLG1CQUFPLENBQUMscWVBQXdOOztBQUUxUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7O0FBR0EsSUFBSSxJQUFVO0FBQ2QseUJBQXlCLFVBQVU7QUFDbkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLElBQUksaUJBQWlCO0FBQ3JCLE1BQU0scWVBQXdOO0FBQzlOO0FBQ0Esa0JBQWtCLG1CQUFPLENBQUMscWVBQXdOOztBQUVsUDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxnQkFBZ0IsVUFBVTs7QUFFMUI7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxFQUFFLFVBQVU7QUFDWjtBQUNBLEdBQUc7QUFDSDs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGFpbHdpbmRjc3MvdGFpbHdpbmQuY3NzP2RkYjUiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGFwaSA9IHJlcXVpcmUoXCIhLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qc1wiKTtcbiAgICAgICAgICAgIHZhciBjb250ZW50ID0gcmVxdWlyZShcIiEhLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9jc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxMV0udXNlWzFdIS4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvcG9zdGNzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzExXS51c2VbMl0hLi90YWlsd2luZC5jc3NcIik7XG5cbiAgICAgICAgICAgIGNvbnRlbnQgPSBjb250ZW50Ll9fZXNNb2R1bGUgPyBjb250ZW50LmRlZmF1bHQgOiBjb250ZW50O1xuXG4gICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgIGNvbnRlbnQgPSBbW21vZHVsZS5pZCwgY29udGVudCwgJyddXTtcbiAgICAgICAgICAgIH1cblxudmFyIG9wdGlvbnMgPSB7fTtcblxub3B0aW9ucy5pbnNlcnQgPSBmdW5jdGlvbihlbGVtZW50KSB7XG4gICAgICAgICAgICAgICAgICAgIC8vIEJ5IGRlZmF1bHQsIHN0eWxlLWxvYWRlciBpbmplY3RzIENTUyBpbnRvIHRoZSBib3R0b21cbiAgICAgICAgICAgICAgICAgICAgLy8gb2YgPGhlYWQ+LiBUaGlzIGNhdXNlcyBvcmRlcmluZyBwcm9ibGVtcyBiZXR3ZWVuIGRldlxuICAgICAgICAgICAgICAgICAgICAvLyBhbmQgcHJvZC4gVG8gZml4IHRoaXMsIHdlIHJlbmRlciBhIDxub3NjcmlwdD4gdGFnIGFzXG4gICAgICAgICAgICAgICAgICAgIC8vIGFuIGFuY2hvciBmb3IgdGhlIHN0eWxlcyB0byBiZSBwbGFjZWQgYmVmb3JlLiBUaGVzZVxuICAgICAgICAgICAgICAgICAgICAvLyBzdHlsZXMgd2lsbCBiZSBhcHBsaWVkIF9iZWZvcmVfIDxzdHlsZSBqc3ggZ2xvYmFsPi5cbiAgICAgICAgICAgICAgICAgICAgLy8gVGhlc2UgZWxlbWVudHMgc2hvdWxkIGFsd2F5cyBleGlzdC4gSWYgdGhleSBkbyBub3QsXG4gICAgICAgICAgICAgICAgICAgIC8vIHRoaXMgY29kZSBzaG91bGQgZmFpbC5cbiAgICAgICAgICAgICAgICAgICAgdmFyIGFuY2hvckVsZW1lbnQgPSBkb2N1bWVudC5xdWVyeVNlbGVjdG9yKFwiI19fbmV4dF9jc3NfX0RPX05PVF9VU0VfX1wiKTtcbiAgICAgICAgICAgICAgICAgICAgdmFyIHBhcmVudE5vZGUgPSBhbmNob3JFbGVtZW50LnBhcmVudE5vZGUvLyBOb3JtYWxseSA8aGVhZD5cbiAgICAgICAgICAgICAgICAgICAgO1xuICAgICAgICAgICAgICAgICAgICAvLyBFYWNoIHN0eWxlIHRhZyBzaG91bGQgYmUgcGxhY2VkIHJpZ2h0IGJlZm9yZSBvdXJcbiAgICAgICAgICAgICAgICAgICAgLy8gYW5jaG9yLiBCeSBpbnNlcnRpbmcgYmVmb3JlIGFuZCBub3QgYWZ0ZXIsIHdlIGRvIG5vdFxuICAgICAgICAgICAgICAgICAgICAvLyBuZWVkIHRvIHRyYWNrIHRoZSBsYXN0IGluc2VydGVkIGVsZW1lbnQuXG4gICAgICAgICAgICAgICAgICAgIHBhcmVudE5vZGUuaW5zZXJ0QmVmb3JlKGVsZW1lbnQsIGFuY2hvckVsZW1lbnQpO1xuICAgICAgICAgICAgICAgIH07XG5vcHRpb25zLnNpbmdsZXRvbiA9IGZhbHNlO1xuXG52YXIgdXBkYXRlID0gYXBpKGNvbnRlbnQsIG9wdGlvbnMpO1xuXG5cbmlmIChtb2R1bGUuaG90KSB7XG4gIGlmICghY29udGVudC5sb2NhbHMgfHwgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKSB7XG4gICAgdmFyIGlzRXF1YWxMb2NhbHMgPSBmdW5jdGlvbiBpc0VxdWFsTG9jYWxzKGEsIGIsIGlzTmFtZWRFeHBvcnQpIHtcbiAgICBpZiAoIWEgJiYgYiB8fCBhICYmICFiKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgbGV0IHA7XG4gICAgZm9yKHAgaW4gYSl7XG4gICAgICAgIGlmIChpc05hbWVkRXhwb3J0ICYmIHAgPT09IFwiZGVmYXVsdFwiKSB7XG4gICAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoYVtwXSAhPT0gYltwXSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIGZvcihwIGluIGIpe1xuICAgICAgICBpZiAoaXNOYW1lZEV4cG9ydCAmJiBwID09PSBcImRlZmF1bHRcIikge1xuICAgICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKCFhW3BdKSB7XG4gICAgICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuICAgIHZhciBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgIG1vZHVsZS5ob3QuYWNjZXB0KFxuICAgICAgXCIhIS4uL25leHQvZGlzdC9idWlsZC93ZWJwYWNrL2xvYWRlcnMvY3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTFdLnVzZVsxXSEuLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL3Bvc3Rjc3MtbG9hZGVyL3NyYy9pbmRleC5qcz8/cnVsZVNldFsxXS5ydWxlc1sxXS5vbmVPZlsxMV0udXNlWzJdIS4vdGFpbHdpbmQuY3NzXCIsXG4gICAgICBmdW5jdGlvbiAoKSB7XG4gICAgICAgIGNvbnRlbnQgPSByZXF1aXJlKFwiISEuLi9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL2Nzcy1sb2FkZXIvc3JjL2luZGV4LmpzPz9ydWxlU2V0WzFdLnJ1bGVzWzFdLm9uZU9mWzExXS51c2VbMV0hLi4vbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9wb3N0Y3NzLWxvYWRlci9zcmMvaW5kZXguanM/P3J1bGVTZXRbMV0ucnVsZXNbMV0ub25lT2ZbMTFdLnVzZVsyXSEuL3RhaWx3aW5kLmNzc1wiKTtcblxuICAgICAgICAgICAgICBjb250ZW50ID0gY29udGVudC5fX2VzTW9kdWxlID8gY29udGVudC5kZWZhdWx0IDogY29udGVudDtcblxuICAgICAgICAgICAgICBpZiAodHlwZW9mIGNvbnRlbnQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgICAgICAgY29udGVudCA9IFtbbW9kdWxlLmlkLCBjb250ZW50LCAnJ11dO1xuICAgICAgICAgICAgICB9XG5cbiAgICAgICAgICAgICAgaWYgKCFpc0VxdWFsTG9jYWxzKG9sZExvY2FscywgY29udGVudC5sb2NhbHMpKSB7XG4gICAgICAgICAgICAgICAgbW9kdWxlLmhvdC5pbnZhbGlkYXRlKCk7XG5cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICAgIH1cblxuICAgICAgICAgICAgICBvbGRMb2NhbHMgPSBjb250ZW50LmxvY2FscztcblxuICAgICAgICAgICAgICB1cGRhdGUoY29udGVudCk7XG4gICAgICB9XG4gICAgKVxuICB9XG5cbiAgbW9kdWxlLmhvdC5kaXNwb3NlKGZ1bmN0aW9uKCkge1xuICAgIHVwZGF0ZSgpO1xuICB9KTtcbn1cblxubW9kdWxlLmV4cG9ydHMgPSBjb250ZW50LmxvY2FscyB8fCB7fTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./node_modules/tailwindcss/tailwind.css\n"));

/***/ }),

/***/ "./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js ***!
  \************************************************************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst isOldIE = function isOldIE() {\n    let memo;\n    return function memorize() {\n        if (typeof memo === \"undefined\") {\n            // Test for IE <= 9 as proposed by Browserhacks\n            // @see http://browserhacks.com/#hack-e71d8692f65334173fee715c222cb805\n            // Tests for existence of standard globals is to allow style-loader\n            // to operate correctly into non-standard environments\n            // @see https://github.com/webpack-contrib/style-loader/issues/177\n            memo = Boolean(window && document && document.all && !window.atob);\n        }\n        return memo;\n    };\n}();\nconst getTargetElement = function() {\n    const memo = {};\n    return function memorize(target) {\n        if (typeof memo[target] === \"undefined\") {\n            let styleTarget = document.querySelector(target);\n            // Special case to return head of iframe instead of iframe itself\n            if (window.HTMLIFrameElement && styleTarget instanceof window.HTMLIFrameElement) {\n                try {\n                    // This will throw an exception if access to iframe is blocked\n                    // due to cross-origin restrictions\n                    styleTarget = styleTarget.contentDocument.head;\n                } catch (e) {\n                    // istanbul ignore next\n                    styleTarget = null;\n                }\n            }\n            memo[target] = styleTarget;\n        }\n        return memo[target];\n    };\n}();\nconst stylesInDom = [];\nfunction getIndexByIdentifier(identifier) {\n    let result = -1;\n    for(let i = 0; i < stylesInDom.length; i++){\n        if (stylesInDom[i].identifier === identifier) {\n            result = i;\n            break;\n        }\n    }\n    return result;\n}\nfunction modulesToDom(list, options) {\n    const idCountMap = {};\n    const identifiers = [];\n    for(let i = 0; i < list.length; i++){\n        const item = list[i];\n        const id = options.base ? item[0] + options.base : item[0];\n        const count = idCountMap[id] || 0;\n        const identifier = id + \" \" + count.toString();\n        idCountMap[id] = count + 1;\n        const index = getIndexByIdentifier(identifier);\n        const obj = {\n            css: item[1],\n            media: item[2],\n            sourceMap: item[3]\n        };\n        if (index !== -1) {\n            stylesInDom[index].references++;\n            stylesInDom[index].updater(obj);\n        } else {\n            stylesInDom.push({\n                identifier: identifier,\n                // eslint-disable-next-line @typescript-eslint/no-use-before-define\n                updater: addStyle(obj, options),\n                references: 1\n            });\n        }\n        identifiers.push(identifier);\n    }\n    return identifiers;\n}\nfunction insertStyleElement(options) {\n    const style = document.createElement(\"style\");\n    const attributes = options.attributes || {};\n    if (typeof attributes.nonce === \"undefined\") {\n        const nonce = // eslint-disable-next-line no-undef\n         true ? __webpack_require__.nc : 0;\n        if (nonce) {\n            attributes.nonce = nonce;\n        }\n    }\n    Object.keys(attributes).forEach(function(key) {\n        style.setAttribute(key, attributes[key]);\n    });\n    if (typeof options.insert === \"function\") {\n        options.insert(style);\n    } else {\n        const target = getTargetElement(options.insert || \"head\");\n        if (!target) {\n            throw new Error(\"Couldn't find a style target. This probably means that the value for the 'insert' parameter is invalid.\");\n        }\n        target.appendChild(style);\n    }\n    return style;\n}\nfunction removeStyleElement(style) {\n    // istanbul ignore if\n    if (style.parentNode === null) {\n        return false;\n    }\n    style.parentNode.removeChild(style);\n}\n/* istanbul ignore next  */ const replaceText = function replaceText() {\n    const textStore = [];\n    return function replace(index, replacement) {\n        textStore[index] = replacement;\n        return textStore.filter(Boolean).join(\"\\n\");\n    };\n}();\nfunction applyToSingletonTag(style, index, remove, obj) {\n    const css = remove ? \"\" : obj.media ? \"@media \" + obj.media + \" {\" + obj.css + \"}\" : obj.css;\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = replaceText(index, css);\n    } else {\n        const cssNode = document.createTextNode(css);\n        const childNodes = style.childNodes;\n        if (childNodes[index]) {\n            style.removeChild(childNodes[index]);\n        }\n        if (childNodes.length) {\n            style.insertBefore(cssNode, childNodes[index]);\n        } else {\n            style.appendChild(cssNode);\n        }\n    }\n}\nfunction applyToTag(style, _options, obj) {\n    let css = obj.css;\n    const media = obj.media;\n    const sourceMap = obj.sourceMap;\n    if (media) {\n        style.setAttribute(\"media\", media);\n    } else {\n        style.removeAttribute(\"media\");\n    }\n    if (sourceMap && typeof btoa !== \"undefined\") {\n        css += \"\\n/*# sourceMappingURL=data:application/json;base64,\" + btoa(unescape(encodeURIComponent(JSON.stringify(sourceMap)))) + \" */\";\n    }\n    // For old IE\n    /* istanbul ignore if  */ if (style.styleSheet) {\n        style.styleSheet.cssText = css;\n    } else {\n        while(style.firstChild){\n            style.removeChild(style.firstChild);\n        }\n        style.appendChild(document.createTextNode(css));\n    }\n}\nlet singleton = null;\nlet singletonCounter = 0;\nfunction addStyle(obj, options) {\n    let style;\n    let update;\n    let remove;\n    if (options.singleton) {\n        const styleIndex = singletonCounter++;\n        style = singleton || (singleton = insertStyleElement(options));\n        update = applyToSingletonTag.bind(null, style, styleIndex, false);\n        remove = applyToSingletonTag.bind(null, style, styleIndex, true);\n    } else {\n        style = insertStyleElement(options);\n        update = applyToTag.bind(null, style, options);\n        remove = function() {\n            removeStyleElement(style);\n        };\n    }\n    update(obj);\n    return function updateStyle(newObj) {\n        if (newObj) {\n            if (newObj.css === obj.css && newObj.media === obj.media && newObj.sourceMap === obj.sourceMap) {\n                return;\n            }\n            update(obj = newObj);\n        } else {\n            remove();\n        }\n    };\n}\nmodule.exports = function(list, options) {\n    options = options || {};\n    // Force single-tag solution on IE6-9, which has a hard limit on the # of <style>\n    // tags it will allow on a page\n    if (!options.singleton && typeof options.singleton !== \"boolean\") {\n        options.singleton = isOldIE();\n    }\n    list = list || [];\n    let lastIdentifiers = modulesToDom(list, options);\n    return function update(newList) {\n        newList = newList || [];\n        if (Object.prototype.toString.call(newList) !== \"[object Array]\") {\n            return;\n        }\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            stylesInDom[index].references--;\n        }\n        const newLastIdentifiers = modulesToDom(newList, options);\n        for(let i = 0; i < lastIdentifiers.length; i++){\n            const identifier = lastIdentifiers[i];\n            const index = getIndexByIdentifier(identifier);\n            if (stylesInDom[index].references === 0) {\n                stylesInDom[index].updater();\n                stylesInDom.splice(index, 1);\n            }\n        }\n        lastIdentifiers = newLastIdentifiers;\n    };\n};\n\n//# sourceMappingURL=injectStylesIntoStyleTag.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2J1aWxkL3dlYnBhY2svbG9hZGVycy9uZXh0LXN0eWxlLWxvYWRlci9ydW50aW1lL2luamVjdFN0eWxlc0ludG9TdHlsZVRhZy5qcy5qcyIsIm1hcHBpbmdzIjoiQUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQSxtQkFBbUIsd0JBQXdCO0FBQzNDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbUJBQW1CLGlCQUFpQjtBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRLEtBQXdDLEdBQUcsc0JBQWlCLEdBQUcsQ0FBSTtBQUMzRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQSxxRUFBcUUsZ0JBQWdCO0FBQ3JGO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQSw2REFBNkQ7QUFDN0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxNQUFNO0FBQ047QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE1BQU07QUFDTjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1QkFBdUIsNEJBQTRCO0FBQ25EO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtc3R5bGUtbG9hZGVyL3J1bnRpbWUvaW5qZWN0U3R5bGVzSW50b1N0eWxlVGFnLmpzPzI2ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiXCJ1c2Ugc3RyaWN0XCI7XG5jb25zdCBpc09sZElFID0gZnVuY3Rpb24gaXNPbGRJRSgpIHtcbiAgICBsZXQgbWVtbztcbiAgICByZXR1cm4gZnVuY3Rpb24gbWVtb3JpemUoKSB7XG4gICAgICAgIGlmICh0eXBlb2YgbWVtbyA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgLy8gVGVzdCBmb3IgSUUgPD0gOSBhcyBwcm9wb3NlZCBieSBCcm93c2VyaGFja3NcbiAgICAgICAgICAgIC8vIEBzZWUgaHR0cDovL2Jyb3dzZXJoYWNrcy5jb20vI2hhY2stZTcxZDg2OTJmNjUzMzQxNzNmZWU3MTVjMjIyY2I4MDVcbiAgICAgICAgICAgIC8vIFRlc3RzIGZvciBleGlzdGVuY2Ugb2Ygc3RhbmRhcmQgZ2xvYmFscyBpcyB0byBhbGxvdyBzdHlsZS1sb2FkZXJcbiAgICAgICAgICAgIC8vIHRvIG9wZXJhdGUgY29ycmVjdGx5IGludG8gbm9uLXN0YW5kYXJkIGVudmlyb25tZW50c1xuICAgICAgICAgICAgLy8gQHNlZSBodHRwczovL2dpdGh1Yi5jb20vd2VicGFjay1jb250cmliL3N0eWxlLWxvYWRlci9pc3N1ZXMvMTc3XG4gICAgICAgICAgICBtZW1vID0gQm9vbGVhbih3aW5kb3cgJiYgZG9jdW1lbnQgJiYgZG9jdW1lbnQuYWxsICYmICF3aW5kb3cuYXRvYik7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIG1lbW87XG4gICAgfTtcbn0oKTtcbmNvbnN0IGdldFRhcmdldEVsZW1lbnQgPSBmdW5jdGlvbigpIHtcbiAgICBjb25zdCBtZW1vID0ge307XG4gICAgcmV0dXJuIGZ1bmN0aW9uIG1lbW9yaXplKHRhcmdldCkge1xuICAgICAgICBpZiAodHlwZW9mIG1lbW9bdGFyZ2V0XSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICAgICAgbGV0IHN0eWxlVGFyZ2V0ID0gZG9jdW1lbnQucXVlcnlTZWxlY3Rvcih0YXJnZXQpO1xuICAgICAgICAgICAgLy8gU3BlY2lhbCBjYXNlIHRvIHJldHVybiBoZWFkIG9mIGlmcmFtZSBpbnN0ZWFkIG9mIGlmcmFtZSBpdHNlbGZcbiAgICAgICAgICAgIGlmICh3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQgJiYgc3R5bGVUYXJnZXQgaW5zdGFuY2VvZiB3aW5kb3cuSFRNTElGcmFtZUVsZW1lbnQpIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICAvLyBUaGlzIHdpbGwgdGhyb3cgYW4gZXhjZXB0aW9uIGlmIGFjY2VzcyB0byBpZnJhbWUgaXMgYmxvY2tlZFxuICAgICAgICAgICAgICAgICAgICAvLyBkdWUgdG8gY3Jvc3Mtb3JpZ2luIHJlc3RyaWN0aW9uc1xuICAgICAgICAgICAgICAgICAgICBzdHlsZVRhcmdldCA9IHN0eWxlVGFyZ2V0LmNvbnRlbnREb2N1bWVudC5oZWFkO1xuICAgICAgICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgICAgICAgICAgLy8gaXN0YW5idWwgaWdub3JlIG5leHRcbiAgICAgICAgICAgICAgICAgICAgc3R5bGVUYXJnZXQgPSBudWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIG1lbW9bdGFyZ2V0XSA9IHN0eWxlVGFyZ2V0O1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBtZW1vW3RhcmdldF07XG4gICAgfTtcbn0oKTtcbmNvbnN0IHN0eWxlc0luRG9tID0gW107XG5mdW5jdGlvbiBnZXRJbmRleEJ5SWRlbnRpZmllcihpZGVudGlmaWVyKSB7XG4gICAgbGV0IHJlc3VsdCA9IC0xO1xuICAgIGZvcihsZXQgaSA9IDA7IGkgPCBzdHlsZXNJbkRvbS5sZW5ndGg7IGkrKyl7XG4gICAgICAgIGlmIChzdHlsZXNJbkRvbVtpXS5pZGVudGlmaWVyID09PSBpZGVudGlmaWVyKSB7XG4gICAgICAgICAgICByZXN1bHQgPSBpO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbn1cbmZ1bmN0aW9uIG1vZHVsZXNUb0RvbShsaXN0LCBvcHRpb25zKSB7XG4gICAgY29uc3QgaWRDb3VudE1hcCA9IHt9O1xuICAgIGNvbnN0IGlkZW50aWZpZXJzID0gW107XG4gICAgZm9yKGxldCBpID0gMDsgaSA8IGxpc3QubGVuZ3RoOyBpKyspe1xuICAgICAgICBjb25zdCBpdGVtID0gbGlzdFtpXTtcbiAgICAgICAgY29uc3QgaWQgPSBvcHRpb25zLmJhc2UgPyBpdGVtWzBdICsgb3B0aW9ucy5iYXNlIDogaXRlbVswXTtcbiAgICAgICAgY29uc3QgY291bnQgPSBpZENvdW50TWFwW2lkXSB8fCAwO1xuICAgICAgICBjb25zdCBpZGVudGlmaWVyID0gaWQgKyBcIiBcIiArIGNvdW50LnRvU3RyaW5nKCk7XG4gICAgICAgIGlkQ291bnRNYXBbaWRdID0gY291bnQgKyAxO1xuICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICBjb25zdCBvYmogPSB7XG4gICAgICAgICAgICBjc3M6IGl0ZW1bMV0sXG4gICAgICAgICAgICBtZWRpYTogaXRlbVsyXSxcbiAgICAgICAgICAgIHNvdXJjZU1hcDogaXRlbVszXVxuICAgICAgICB9O1xuICAgICAgICBpZiAoaW5kZXggIT09IC0xKSB7XG4gICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0ucmVmZXJlbmNlcysrO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnVwZGF0ZXIob2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHN0eWxlc0luRG9tLnB1c2goe1xuICAgICAgICAgICAgICAgIGlkZW50aWZpZXI6IGlkZW50aWZpZXIsXG4gICAgICAgICAgICAgICAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIEB0eXBlc2NyaXB0LWVzbGludC9uby11c2UtYmVmb3JlLWRlZmluZVxuICAgICAgICAgICAgICAgIHVwZGF0ZXI6IGFkZFN0eWxlKG9iaiwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgcmVmZXJlbmNlczogMVxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgaWRlbnRpZmllcnMucHVzaChpZGVudGlmaWVyKTtcbiAgICB9XG4gICAgcmV0dXJuIGlkZW50aWZpZXJzO1xufVxuZnVuY3Rpb24gaW5zZXJ0U3R5bGVFbGVtZW50KG9wdGlvbnMpIHtcbiAgICBjb25zdCBzdHlsZSA9IGRvY3VtZW50LmNyZWF0ZUVsZW1lbnQoXCJzdHlsZVwiKTtcbiAgICBjb25zdCBhdHRyaWJ1dGVzID0gb3B0aW9ucy5hdHRyaWJ1dGVzIHx8IHt9O1xuICAgIGlmICh0eXBlb2YgYXR0cmlidXRlcy5ub25jZSA9PT0gXCJ1bmRlZmluZWRcIikge1xuICAgICAgICBjb25zdCBub25jZSA9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSBuby11bmRlZlxuICAgICAgICB0eXBlb2YgX193ZWJwYWNrX25vbmNlX18gIT09IFwidW5kZWZpbmVkXCIgPyBfX3dlYnBhY2tfbm9uY2VfXyA6IG51bGw7XG4gICAgICAgIGlmIChub25jZSkge1xuICAgICAgICAgICAgYXR0cmlidXRlcy5ub25jZSA9IG5vbmNlO1xuICAgICAgICB9XG4gICAgfVxuICAgIE9iamVjdC5rZXlzKGF0dHJpYnV0ZXMpLmZvckVhY2goZnVuY3Rpb24oa2V5KSB7XG4gICAgICAgIHN0eWxlLnNldEF0dHJpYnV0ZShrZXksIGF0dHJpYnV0ZXNba2V5XSk7XG4gICAgfSk7XG4gICAgaWYgKHR5cGVvZiBvcHRpb25zLmluc2VydCA9PT0gXCJmdW5jdGlvblwiKSB7XG4gICAgICAgIG9wdGlvbnMuaW5zZXJ0KHN0eWxlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBnZXRUYXJnZXRFbGVtZW50KG9wdGlvbnMuaW5zZXJ0IHx8IFwiaGVhZFwiKTtcbiAgICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkNvdWxkbid0IGZpbmQgYSBzdHlsZSB0YXJnZXQuIFRoaXMgcHJvYmFibHkgbWVhbnMgdGhhdCB0aGUgdmFsdWUgZm9yIHRoZSAnaW5zZXJ0JyBwYXJhbWV0ZXIgaXMgaW52YWxpZC5cIik7XG4gICAgICAgIH1cbiAgICAgICAgdGFyZ2V0LmFwcGVuZENoaWxkKHN0eWxlKTtcbiAgICB9XG4gICAgcmV0dXJuIHN0eWxlO1xufVxuZnVuY3Rpb24gcmVtb3ZlU3R5bGVFbGVtZW50KHN0eWxlKSB7XG4gICAgLy8gaXN0YW5idWwgaWdub3JlIGlmXG4gICAgaWYgKHN0eWxlLnBhcmVudE5vZGUgPT09IG51bGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBzdHlsZS5wYXJlbnROb2RlLnJlbW92ZUNoaWxkKHN0eWxlKTtcbn1cbi8qIGlzdGFuYnVsIGlnbm9yZSBuZXh0ICAqLyBjb25zdCByZXBsYWNlVGV4dCA9IGZ1bmN0aW9uIHJlcGxhY2VUZXh0KCkge1xuICAgIGNvbnN0IHRleHRTdG9yZSA9IFtdO1xuICAgIHJldHVybiBmdW5jdGlvbiByZXBsYWNlKGluZGV4LCByZXBsYWNlbWVudCkge1xuICAgICAgICB0ZXh0U3RvcmVbaW5kZXhdID0gcmVwbGFjZW1lbnQ7XG4gICAgICAgIHJldHVybiB0ZXh0U3RvcmUuZmlsdGVyKEJvb2xlYW4pLmpvaW4oXCJcXG5cIik7XG4gICAgfTtcbn0oKTtcbmZ1bmN0aW9uIGFwcGx5VG9TaW5nbGV0b25UYWcoc3R5bGUsIGluZGV4LCByZW1vdmUsIG9iaikge1xuICAgIGNvbnN0IGNzcyA9IHJlbW92ZSA/IFwiXCIgOiBvYmoubWVkaWEgPyBcIkBtZWRpYSBcIiArIG9iai5tZWRpYSArIFwiIHtcIiArIG9iai5jc3MgKyBcIn1cIiA6IG9iai5jc3M7XG4gICAgLy8gRm9yIG9sZCBJRVxuICAgIC8qIGlzdGFuYnVsIGlnbm9yZSBpZiAgKi8gaWYgKHN0eWxlLnN0eWxlU2hlZXQpIHtcbiAgICAgICAgc3R5bGUuc3R5bGVTaGVldC5jc3NUZXh0ID0gcmVwbGFjZVRleHQoaW5kZXgsIGNzcyk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgY29uc3QgY3NzTm9kZSA9IGRvY3VtZW50LmNyZWF0ZVRleHROb2RlKGNzcyk7XG4gICAgICAgIGNvbnN0IGNoaWxkTm9kZXMgPSBzdHlsZS5jaGlsZE5vZGVzO1xuICAgICAgICBpZiAoY2hpbGROb2Rlc1tpbmRleF0pIHtcbiAgICAgICAgICAgIHN0eWxlLnJlbW92ZUNoaWxkKGNoaWxkTm9kZXNbaW5kZXhdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY2hpbGROb2Rlcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIHN0eWxlLmluc2VydEJlZm9yZShjc3NOb2RlLCBjaGlsZE5vZGVzW2luZGV4XSk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChjc3NOb2RlKTtcbiAgICAgICAgfVxuICAgIH1cbn1cbmZ1bmN0aW9uIGFwcGx5VG9UYWcoc3R5bGUsIF9vcHRpb25zLCBvYmopIHtcbiAgICBsZXQgY3NzID0gb2JqLmNzcztcbiAgICBjb25zdCBtZWRpYSA9IG9iai5tZWRpYTtcbiAgICBjb25zdCBzb3VyY2VNYXAgPSBvYmouc291cmNlTWFwO1xuICAgIGlmIChtZWRpYSkge1xuICAgICAgICBzdHlsZS5zZXRBdHRyaWJ1dGUoXCJtZWRpYVwiLCBtZWRpYSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgc3R5bGUucmVtb3ZlQXR0cmlidXRlKFwibWVkaWFcIik7XG4gICAgfVxuICAgIGlmIChzb3VyY2VNYXAgJiYgdHlwZW9mIGJ0b2EgIT09IFwidW5kZWZpbmVkXCIpIHtcbiAgICAgICAgY3NzICs9IFwiXFxuLyojIHNvdXJjZU1hcHBpbmdVUkw9ZGF0YTphcHBsaWNhdGlvbi9qc29uO2Jhc2U2NCxcIiArIGJ0b2EodW5lc2NhcGUoZW5jb2RlVVJJQ29tcG9uZW50KEpTT04uc3RyaW5naWZ5KHNvdXJjZU1hcCkpKSkgKyBcIiAqL1wiO1xuICAgIH1cbiAgICAvLyBGb3Igb2xkIElFXG4gICAgLyogaXN0YW5idWwgaWdub3JlIGlmICAqLyBpZiAoc3R5bGUuc3R5bGVTaGVldCkge1xuICAgICAgICBzdHlsZS5zdHlsZVNoZWV0LmNzc1RleHQgPSBjc3M7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgd2hpbGUoc3R5bGUuZmlyc3RDaGlsZCl7XG4gICAgICAgICAgICBzdHlsZS5yZW1vdmVDaGlsZChzdHlsZS5maXJzdENoaWxkKTtcbiAgICAgICAgfVxuICAgICAgICBzdHlsZS5hcHBlbmRDaGlsZChkb2N1bWVudC5jcmVhdGVUZXh0Tm9kZShjc3MpKTtcbiAgICB9XG59XG5sZXQgc2luZ2xldG9uID0gbnVsbDtcbmxldCBzaW5nbGV0b25Db3VudGVyID0gMDtcbmZ1bmN0aW9uIGFkZFN0eWxlKG9iaiwgb3B0aW9ucykge1xuICAgIGxldCBzdHlsZTtcbiAgICBsZXQgdXBkYXRlO1xuICAgIGxldCByZW1vdmU7XG4gICAgaWYgKG9wdGlvbnMuc2luZ2xldG9uKSB7XG4gICAgICAgIGNvbnN0IHN0eWxlSW5kZXggPSBzaW5nbGV0b25Db3VudGVyKys7XG4gICAgICAgIHN0eWxlID0gc2luZ2xldG9uIHx8IChzaW5nbGV0b24gPSBpbnNlcnRTdHlsZUVsZW1lbnQob3B0aW9ucykpO1xuICAgICAgICB1cGRhdGUgPSBhcHBseVRvU2luZ2xldG9uVGFnLmJpbmQobnVsbCwgc3R5bGUsIHN0eWxlSW5kZXgsIGZhbHNlKTtcbiAgICAgICAgcmVtb3ZlID0gYXBwbHlUb1NpbmdsZXRvblRhZy5iaW5kKG51bGwsIHN0eWxlLCBzdHlsZUluZGV4LCB0cnVlKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzdHlsZSA9IGluc2VydFN0eWxlRWxlbWVudChvcHRpb25zKTtcbiAgICAgICAgdXBkYXRlID0gYXBwbHlUb1RhZy5iaW5kKG51bGwsIHN0eWxlLCBvcHRpb25zKTtcbiAgICAgICAgcmVtb3ZlID0gZnVuY3Rpb24oKSB7XG4gICAgICAgICAgICByZW1vdmVTdHlsZUVsZW1lbnQoc3R5bGUpO1xuICAgICAgICB9O1xuICAgIH1cbiAgICB1cGRhdGUob2JqKTtcbiAgICByZXR1cm4gZnVuY3Rpb24gdXBkYXRlU3R5bGUobmV3T2JqKSB7XG4gICAgICAgIGlmIChuZXdPYmopIHtcbiAgICAgICAgICAgIGlmIChuZXdPYmouY3NzID09PSBvYmouY3NzICYmIG5ld09iai5tZWRpYSA9PT0gb2JqLm1lZGlhICYmIG5ld09iai5zb3VyY2VNYXAgPT09IG9iai5zb3VyY2VNYXApIHtcbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB1cGRhdGUob2JqID0gbmV3T2JqKTtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlbW92ZSgpO1xuICAgICAgICB9XG4gICAgfTtcbn1cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24obGlzdCwgb3B0aW9ucykge1xuICAgIG9wdGlvbnMgPSBvcHRpb25zIHx8IHt9O1xuICAgIC8vIEZvcmNlIHNpbmdsZS10YWcgc29sdXRpb24gb24gSUU2LTksIHdoaWNoIGhhcyBhIGhhcmQgbGltaXQgb24gdGhlICMgb2YgPHN0eWxlPlxuICAgIC8vIHRhZ3MgaXQgd2lsbCBhbGxvdyBvbiBhIHBhZ2VcbiAgICBpZiAoIW9wdGlvbnMuc2luZ2xldG9uICYmIHR5cGVvZiBvcHRpb25zLnNpbmdsZXRvbiAhPT0gXCJib29sZWFuXCIpIHtcbiAgICAgICAgb3B0aW9ucy5zaW5nbGV0b24gPSBpc09sZElFKCk7XG4gICAgfVxuICAgIGxpc3QgPSBsaXN0IHx8IFtdO1xuICAgIGxldCBsYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obGlzdCwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIGZ1bmN0aW9uIHVwZGF0ZShuZXdMaXN0KSB7XG4gICAgICAgIG5ld0xpc3QgPSBuZXdMaXN0IHx8IFtdO1xuICAgICAgICBpZiAoT2JqZWN0LnByb3RvdHlwZS50b1N0cmluZy5jYWxsKG5ld0xpc3QpICE9PSBcIltvYmplY3QgQXJyYXldXCIpIHtcbiAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgfVxuICAgICAgICBmb3IobGV0IGkgPSAwOyBpIDwgbGFzdElkZW50aWZpZXJzLmxlbmd0aDsgaSsrKXtcbiAgICAgICAgICAgIGNvbnN0IGlkZW50aWZpZXIgPSBsYXN0SWRlbnRpZmllcnNbaV07XG4gICAgICAgICAgICBjb25zdCBpbmRleCA9IGdldEluZGV4QnlJZGVudGlmaWVyKGlkZW50aWZpZXIpO1xuICAgICAgICAgICAgc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMtLTtcbiAgICAgICAgfVxuICAgICAgICBjb25zdCBuZXdMYXN0SWRlbnRpZmllcnMgPSBtb2R1bGVzVG9Eb20obmV3TGlzdCwgb3B0aW9ucyk7XG4gICAgICAgIGZvcihsZXQgaSA9IDA7IGkgPCBsYXN0SWRlbnRpZmllcnMubGVuZ3RoOyBpKyspe1xuICAgICAgICAgICAgY29uc3QgaWRlbnRpZmllciA9IGxhc3RJZGVudGlmaWVyc1tpXTtcbiAgICAgICAgICAgIGNvbnN0IGluZGV4ID0gZ2V0SW5kZXhCeUlkZW50aWZpZXIoaWRlbnRpZmllcik7XG4gICAgICAgICAgICBpZiAoc3R5bGVzSW5Eb21baW5kZXhdLnJlZmVyZW5jZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBzdHlsZXNJbkRvbVtpbmRleF0udXBkYXRlcigpO1xuICAgICAgICAgICAgICAgIHN0eWxlc0luRG9tLnNwbGljZShpbmRleCwgMSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgbGFzdElkZW50aWZpZXJzID0gbmV3TGFzdElkZW50aWZpZXJzO1xuICAgIH07XG59O1xuXG4vLyMgc291cmNlTWFwcGluZ1VSTD1pbmplY3RTdHlsZXNJbnRvU3R5bGVUYWcuanMubWFwIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./node_modules/next/dist/build/webpack/loaders/next-style-loader/runtime/injectStylesIntoStyleTag.js\n"));

/***/ }),

/***/ "./pages/index.js":
/*!************************!*\
  !*** ./pages/index.js ***!
  \************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"./node_modules/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"./node_modules/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var react_redux__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-redux */ \"./node_modules/react-redux/es/index.js\");\n/* harmony import */ var tailwindcss_tailwind_css__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! tailwindcss/tailwind.css */ \"./node_modules/tailwindcss/tailwind.css\");\n/* harmony import */ var tailwindcss_tailwind_css__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(tailwindcss_tailwind_css__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var _redux_contentfulActions__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../redux/contentfulActions */ \"./redux/contentfulActions.js\");\n\nvar _s = $RefreshSig$();\n\n\n\n\nconst HomePage = ()=>{\n    _s();\n    const dispatch = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch)();\n    const entries = (0,react_redux__WEBPACK_IMPORTED_MODULE_2__.useSelector)((state)=>state.contentful.entries);\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)(()=>{\n        dispatch((0,_redux_contentfulActions__WEBPACK_IMPORTED_MODULE_4__.fetchContentfulData)());\n    }, [\n        dispatch\n    ]);\n    console.log(entries);\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.Fragment, {\n        children: /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h1\", {\n            children: \"Hello World!\"\n        }, void 0, false, {\n            fileName: \"C:\\\\Users\\\\LENOVO\\\\Desktop\\\\iviewlabs-trial\\\\pages\\\\index.js\",\n            lineNumber: 17,\n            columnNumber: 7\n        }, undefined)\n    }, void 0, false);\n};\n_s(HomePage, \"0XYRdv2qJE75n7KPfyWrzb8DVSc=\", false, function() {\n    return [\n        react_redux__WEBPACK_IMPORTED_MODULE_2__.useDispatch,\n        react_redux__WEBPACK_IMPORTED_MODULE_2__.useSelector\n    ];\n});\n_c = HomePage;\n/* harmony default export */ __webpack_exports__[\"default\"] = (HomePage);\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9wYWdlcy9pbmRleC5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF5QztBQUNjO0FBQ3JCO0FBQytCO0FBRWpFLE1BQU1LLFdBQVcsSUFBTTs7SUFDckIsTUFBTUMsV0FBV0osd0RBQVdBO0lBQzVCLE1BQU1LLFVBQVVKLHdEQUFXQSxDQUFDLENBQUNLLFFBQVVBLE1BQU1DLFVBQVUsQ0FBQ0YsT0FBTztJQUUvRE4sZ0RBQVNBLENBQUMsSUFBTTtRQUNkSyxTQUFTRiw2RUFBbUJBO0lBQzlCLEdBQUc7UUFBQ0U7S0FBUztJQUNiSSxRQUFRQyxHQUFHLENBQUNKO0lBRVoscUJBQ0U7a0JBQ0UsNEVBQUNLO3NCQUFHOzs7Ozs7O0FBR1Y7R0FkTVA7O1FBQ2FILG9EQUFXQTtRQUNaQyxvREFBV0E7OztLQUZ2QkU7QUFnQk4sK0RBQWVBLFFBQVFBLEVBQUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vcGFnZXMvaW5kZXguanM/YmVlNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgUmVhY3QsIHsgdXNlRWZmZWN0IH0gZnJvbSBcInJlYWN0XCI7XHJcbmltcG9ydCB7IHVzZURpc3BhdGNoLCB1c2VTZWxlY3RvciB9IGZyb20gXCJyZWFjdC1yZWR1eFwiO1xyXG5pbXBvcnQgXCJ0YWlsd2luZGNzcy90YWlsd2luZC5jc3NcIjtcclxuaW1wb3J0IHsgZmV0Y2hDb250ZW50ZnVsRGF0YSB9IGZyb20gXCIuLi9yZWR1eC9jb250ZW50ZnVsQWN0aW9uc1wiO1xyXG5cclxuY29uc3QgSG9tZVBhZ2UgPSAoKSA9PiB7XHJcbiAgY29uc3QgZGlzcGF0Y2ggPSB1c2VEaXNwYXRjaCgpO1xyXG4gIGNvbnN0IGVudHJpZXMgPSB1c2VTZWxlY3Rvcigoc3RhdGUpID0+IHN0YXRlLmNvbnRlbnRmdWwuZW50cmllcyk7XHJcblxyXG4gIHVzZUVmZmVjdCgoKSA9PiB7XHJcbiAgICBkaXNwYXRjaChmZXRjaENvbnRlbnRmdWxEYXRhKCkpO1xyXG4gIH0sIFtkaXNwYXRjaF0pO1xyXG4gIGNvbnNvbGUubG9nKGVudHJpZXMpO1xyXG5cclxuICByZXR1cm4gKFxyXG4gICAgPD5cclxuICAgICAgPGgxPkhlbGxvIFdvcmxkITwvaDE+XHJcbiAgICA8Lz5cclxuICApO1xyXG59O1xyXG5cclxuZXhwb3J0IGRlZmF1bHQgSG9tZVBhZ2U7XHJcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZUVmZmVjdCIsInVzZURpc3BhdGNoIiwidXNlU2VsZWN0b3IiLCJmZXRjaENvbnRlbnRmdWxEYXRhIiwiSG9tZVBhZ2UiLCJkaXNwYXRjaCIsImVudHJpZXMiLCJzdGF0ZSIsImNvbnRlbnRmdWwiLCJjb25zb2xlIiwibG9nIiwiaDEiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///./pages/index.js\n"));

/***/ }),

/***/ "./redux/contentfulActions.js":
/*!************************************!*\
  !*** ./redux/contentfulActions.js ***!
  \************************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"fetchContentfulData\": function() { return /* binding */ fetchContentfulData; }\n/* harmony export */ });\n/* harmony import */ var contentful__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! contentful */ \"./node_modules/contentful/dist/contentful.browser.js\");\n/* harmony import */ var contentful__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(contentful__WEBPACK_IMPORTED_MODULE_0__);\n\n// const space = process.env.CONTENTFUL_SPACE;\n// const accessToken = process.env.CONTENTFUL_ACCESS_TOKEN;\nconst fetchContentfulData = ()=>{\n    return (dispatch)=>{\n        const client = contentful__WEBPACK_IMPORTED_MODULE_0__.createClient({\n            space: \"oovsmbukyz6f\",\n            accessToken: \"RGz1-MZ11eexyDYU-VoNVSQinU-bovMXNI-og_qRUVM\"\n        });\n        client.getEntries().then((response)=>{\n            dispatch({\n                type: \"FETCH_CONTENTFUL_DATA_SUCCESS\",\n                payload: response.items\n            });\n        }).catch((error)=>{\n            dispatch({\n                type: \"FETCH_CONTENTFUL_DATA_FAILURE\",\n                error: error\n            });\n        });\n    };\n};\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevExports = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevExports) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports on update so we can compare the boundary\n                // signatures.\n                module.hot.dispose(function (data) {\n                    data.prevExports = currentExports;\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevExports !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevExports, currentExports)) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevExports !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiLi9yZWR1eC9jb250ZW50ZnVsQWN0aW9ucy5qcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBeUM7QUFFekMsOENBQThDO0FBQzlDLDJEQUEyRDtBQUVwRCxNQUFNQyxzQkFBc0IsSUFBTTtJQUN2QyxPQUFPLENBQUNDLFdBQWE7UUFDbkIsTUFBTUMsU0FBU0gsb0RBQXVCLENBQUM7WUFDckNLLE9BQU87WUFDUEMsYUFBYTtRQUNmO1FBRUFILE9BQU9JLFVBQVUsR0FDZEMsSUFBSSxDQUFDQyxDQUFBQSxXQUFZO1lBQ2hCUCxTQUFTO2dCQUFFUSxNQUFNO2dCQUFpQ0MsU0FBU0YsU0FBU0csS0FBSztZQUFDO1FBQzVFLEdBQ0NDLEtBQUssQ0FBQ0MsQ0FBQUEsUUFBUztZQUNkWixTQUFTO2dCQUFFUSxNQUFNO2dCQUFpQ0ksT0FBT0E7WUFBTTtRQUNqRTtJQUNKO0FBQ0YsRUFBRSIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9yZWR1eC9jb250ZW50ZnVsQWN0aW9ucy5qcz8zZDE5Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIGNvbnRlbnRmdWwgZnJvbSAnY29udGVudGZ1bCc7XHJcblxyXG4vLyBjb25zdCBzcGFjZSA9IHByb2Nlc3MuZW52LkNPTlRFTlRGVUxfU1BBQ0U7XHJcbi8vIGNvbnN0IGFjY2Vzc1Rva2VuID0gcHJvY2Vzcy5lbnYuQ09OVEVOVEZVTF9BQ0NFU1NfVE9LRU47XHJcblxyXG5leHBvcnQgY29uc3QgZmV0Y2hDb250ZW50ZnVsRGF0YSA9ICgpID0+IHtcclxuICByZXR1cm4gKGRpc3BhdGNoKSA9PiB7XHJcbiAgICBjb25zdCBjbGllbnQgPSBjb250ZW50ZnVsLmNyZWF0ZUNsaWVudCh7XHJcbiAgICAgIHNwYWNlOiBcIm9vdnNtYnVreXo2ZlwiLFxyXG4gICAgICBhY2Nlc3NUb2tlbjogXCJSR3oxLU1aMTFlZXh5RFlVLVZvTlZTUWluVS1ib3ZNWE5JLW9nX3FSVVZNXCJcclxuICAgIH0pO1xyXG4gICAgXHJcbiAgICBjbGllbnQuZ2V0RW50cmllcygpXHJcbiAgICAgIC50aGVuKHJlc3BvbnNlID0+IHtcclxuICAgICAgICBkaXNwYXRjaCh7IHR5cGU6ICdGRVRDSF9DT05URU5URlVMX0RBVEFfU1VDQ0VTUycsIHBheWxvYWQ6IHJlc3BvbnNlLml0ZW1zIH0pO1xyXG4gICAgICB9KVxyXG4gICAgICAuY2F0Y2goZXJyb3IgPT4ge1xyXG4gICAgICAgIGRpc3BhdGNoKHsgdHlwZTogJ0ZFVENIX0NPTlRFTlRGVUxfREFUQV9GQUlMVVJFJywgZXJyb3I6IGVycm9yIH0pO1xyXG4gICAgICB9KTtcclxuICB9O1xyXG59OyJdLCJuYW1lcyI6WyJjb250ZW50ZnVsIiwiZmV0Y2hDb250ZW50ZnVsRGF0YSIsImRpc3BhdGNoIiwiY2xpZW50IiwiY3JlYXRlQ2xpZW50Iiwic3BhY2UiLCJhY2Nlc3NUb2tlbiIsImdldEVudHJpZXMiLCJ0aGVuIiwicmVzcG9uc2UiLCJ0eXBlIiwicGF5bG9hZCIsIml0ZW1zIiwiY2F0Y2giLCJlcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///./redux/contentfulActions.js\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["pages/_app","main"], function() { return __webpack_exec__("./node_modules/next/dist/build/webpack/loaders/next-client-pages-loader.js?absolutePagePath=C%3A%5CUsers%5CLENOVO%5CDesktop%5Civiewlabs-trial%5Cpages%5Cindex.js&page=%2F!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);